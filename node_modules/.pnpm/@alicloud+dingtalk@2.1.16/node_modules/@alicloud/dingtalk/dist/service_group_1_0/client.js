"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchQueryGroupMemberResponse = exports.BatchQueryGroupMemberResponseBody = exports.BatchQueryGroupMemberRequest = exports.BatchQueryGroupMemberHeaders = exports.BatchQueryCustomerSendTaskResponse = exports.BatchQueryCustomerSendTaskResponseBody = exports.BatchQueryCustomerSendTaskRequest = exports.BatchQueryCustomerSendTaskHeaders = exports.BatchGetGroupSetConfigResponse = exports.BatchGetGroupSetConfigResponseBody = exports.BatchGetGroupSetConfigRequest = exports.BatchGetGroupSetConfigHeaders = exports.BatchBindingGroupBizIdsResponse = exports.BatchBindingGroupBizIdsResponseBody = exports.BatchBindingGroupBizIdsRequest = exports.BatchBindingGroupBizIdsHeaders = exports.AssignTicketResponse = exports.AssignTicketRequest = exports.AssignTicketHeaders = exports.AddTicketMemoResponse = exports.AddTicketMemoRequest = exports.AddTicketMemoHeaders = exports.AddOpenLibraryResponse = exports.AddOpenLibraryResponseBody = exports.AddOpenLibraryRequest = exports.AddOpenLibraryHeaders = exports.AddOpenKnowledgeResponse = exports.AddOpenKnowledgeResponseBody = exports.AddOpenKnowledgeRequest = exports.AddOpenKnowledgeHeaders = exports.AddOpenCategoryResponse = exports.AddOpenCategoryResponseBody = exports.AddOpenCategoryRequest = exports.AddOpenCategoryHeaders = exports.AddMemberToServiceGroupResponse = exports.AddMemberToServiceGroupResponseBody = exports.AddMemberToServiceGroupRequest = exports.AddMemberToServiceGroupHeaders = exports.AddLibraryResponse = exports.AddLibraryResponseBody = exports.AddLibraryRequest = exports.AddLibraryHeaders = exports.AddKnowledgeResponse = exports.AddKnowledgeResponseBody = exports.AddKnowledgeRequest = exports.AddKnowledgeHeaders = exports.AddContactMemberToGroupResponse = exports.AddContactMemberToGroupResponseBody = exports.AddContactMemberToGroupRequest = exports.AddContactMemberToGroupHeaders = void 0;
exports.CreateInstanceResponseBody = exports.CreateInstanceRequest = exports.CreateInstanceHeaders = exports.CreateGroupSetResponse = exports.CreateGroupSetResponseBody = exports.CreateGroupSetRequest = exports.CreateGroupSetHeaders = exports.CreateGroupConversationResponse = exports.CreateGroupConversationResponseBody = exports.CreateGroupConversationRequest = exports.CreateGroupConversationHeaders = exports.CreateGroupResponse = exports.CreateGroupResponseBody = exports.CreateGroupRequest = exports.CreateGroupHeaders = exports.ConversationTransferCompleteNotifyResponse = exports.ConversationTransferCompleteNotifyResponseBody = exports.ConversationTransferCompleteNotifyRequest = exports.ConversationTransferCompleteNotifyHeaders = exports.ConversationTransferBeginNotifyResponse = exports.ConversationTransferBeginNotifyResponseBody = exports.ConversationTransferBeginNotifyRequest = exports.ConversationTransferBeginNotifyHeaders = exports.ConversationCreatedNotifyResponse = exports.ConversationCreatedNotifyResponseBody = exports.ConversationCreatedNotifyRequest = exports.ConversationCreatedNotifyHeaders = exports.CloseHumanSessionResponse = exports.CloseHumanSessionResponseBody = exports.CloseHumanSessionRequest = exports.CloseHumanSessionHeaders = exports.CloseConversationResponse = exports.CloseConversationResponseBody = exports.CloseConversationRequest = exports.CloseConversationHeaders = exports.CategoryStatisticsResponse = exports.CategoryStatisticsResponseBody = exports.CategoryStatisticsRequest = exports.CategoryStatisticsHeaders = exports.CancelTicketResponse = exports.CancelTicketRequest = exports.CancelTicketHeaders = exports.BoundTemplateToTeamResponse = exports.BoundTemplateToTeamResponseBody = exports.BoundTemplateToTeamRequest = exports.BoundTemplateToTeamHeaders = exports.BatchQuerySendMessageTaskResponse = exports.BatchQuerySendMessageTaskResponseBody = exports.BatchQuerySendMessageTaskRequest = exports.BatchQuerySendMessageTaskHeaders = void 0;
exports.GetStoragePolicyRequest = exports.GetStoragePolicyHeaders = exports.GetOssTempUrlResponse = exports.GetOssTempUrlResponseBody = exports.GetOssTempUrlRequest = exports.GetOssTempUrlHeaders = exports.GetNegativeWordCloudResponse = exports.GetNegativeWordCloudResponseBody = exports.GetNegativeWordCloudRequest = exports.GetNegativeWordCloudHeaders = exports.GetInstancesByIdsResponse = exports.GetInstancesByIdsResponseBody = exports.GetInstancesByIdsRequest = exports.GetInstancesByIdsHeaders = exports.GetAuthTokenResponse = exports.GetAuthTokenResponseBody = exports.GetAuthTokenRequest = exports.GetAuthTokenHeaders = exports.FinishTicketResponse = exports.FinishTicketRequest = exports.FinishTicketHeaders = exports.EmotionStatisticsResponse = exports.EmotionStatisticsResponseBody = exports.EmotionStatisticsRequest = exports.EmotionStatisticsHeaders = exports.DeleteKnowledgeResponse = exports.DeleteKnowledgeResponseBody = exports.DeleteKnowledgeRequest = exports.DeleteKnowledgeHeaders = exports.DeleteInstanceResponse = exports.DeleteInstanceResponseBody = exports.DeleteInstanceRequest = exports.DeleteInstanceHeaders = exports.DeleteGroupMembersFromGroupResponse = exports.DeleteGroupMembersFromGroupResponseBody = exports.DeleteGroupMembersFromGroupRequest = exports.DeleteGroupMembersFromGroupHeaders = exports.CustomerSendMsgTaskResponse = exports.CustomerSendMsgTaskResponseBody = exports.CustomerSendMsgTaskRequest = exports.CustomerSendMsgTaskHeaders = exports.CreateTicketResponse = exports.CreateTicketResponseBody = exports.CreateTicketRequest = exports.CreateTicketHeaders = exports.CreateTeamResponse = exports.CreateTeamResponseBody = exports.CreateTeamRequest = exports.CreateTeamHeaders = exports.CreateInstanceResponse = void 0;
exports.QueryGroupMemberHeaders = exports.QueryGroupResponse = exports.QueryGroupResponseBody = exports.QueryGroupRequest = exports.QueryGroupHeaders = exports.QueryCustomerTaskUserDetailResponse = exports.QueryCustomerTaskUserDetailResponseBody = exports.QueryCustomerTaskUserDetailRequest = exports.QueryCustomerTaskUserDetailHeaders = exports.QueryCustomerCardResponse = exports.QueryCustomerCardResponseBody = exports.QueryCustomerCardRequest = exports.QueryCustomerCardHeaders = exports.QueryCrmGroupContactResponse = exports.QueryCrmGroupContactResponseBody = exports.QueryCrmGroupContactRequest = exports.QueryCrmGroupContactHeaders = exports.QueryActiveUsersResponse = exports.QueryActiveUsersResponseBody = exports.QueryActiveUsersRequest = exports.QueryActiveUsersHeaders = exports.ListUserTeamsResponse = exports.ListUserTeamsResponseBody = exports.ListUserTeamsHeaders = exports.ListTicketOperateRecordResponse = exports.ListTicketOperateRecordResponseBody = exports.ListTicketOperateRecordRequest = exports.ListTicketOperateRecordHeaders = exports.IntentionStatisticsResponse = exports.IntentionStatisticsResponseBody = exports.IntentionStatisticsRequest = exports.IntentionStatisticsHeaders = exports.IntentionCategoryStatisticsResponse = exports.IntentionCategoryStatisticsResponseBody = exports.IntentionCategoryStatisticsRequest = exports.IntentionCategoryStatisticsHeaders = exports.GroupStatisticsResponse = exports.GroupStatisticsResponseBody = exports.GroupStatisticsRequest = exports.GroupStatisticsHeaders = exports.GetWordCloudResponse = exports.GetWordCloudResponseBody = exports.GetWordCloudRequest = exports.GetWordCloudHeaders = exports.GetTicketResponse = exports.GetTicketResponseBody = exports.GetTicketRequest = exports.GetTicketHeaders = exports.GetStoragePolicyResponse = exports.GetStoragePolicyResponseBody = void 0;
exports.SaveFormInstanceHeaders = exports.RobotMessageRecallResponse = exports.RobotMessageRecallResponseBody = exports.RobotMessageRecallRequest = exports.RobotMessageRecallHeaders = exports.RetractTicketResponse = exports.RetractTicketRequest = exports.RetractTicketHeaders = exports.ResubmitTicketResponse = exports.ResubmitTicketRequest = exports.ResubmitTicketHeaders = exports.ReportCustomerStatisticsResponse = exports.ReportCustomerStatisticsResponseBody = exports.ReportCustomerStatisticsRequest = exports.ReportCustomerStatisticsHeaders = exports.ReportCustomerDetailResponse = exports.ReportCustomerDetailResponseBody = exports.ReportCustomerDetailRequest = exports.ReportCustomerDetailHeaders = exports.RemoveContactFromOrgResponse = exports.RemoveContactFromOrgResponseBody = exports.RemoveContactFromOrgRequest = exports.RemoveContactFromOrgHeaders = exports.QueueNotifyResponse = exports.QueueNotifyResponseBody = exports.QueueNotifyRequest = exports.QueueNotifyHeaders = exports.QueryServiceGroupMessageReadStatusResponse = exports.QueryServiceGroupMessageReadStatusResponseBody = exports.QueryServiceGroupMessageReadStatusRequest = exports.QueryServiceGroupMessageReadStatusHeaders = exports.QuerySendMsgTaskStatisticsDetailResponse = exports.QuerySendMsgTaskStatisticsDetailResponseBody = exports.QuerySendMsgTaskStatisticsDetailRequest = exports.QuerySendMsgTaskStatisticsDetailHeaders = exports.QuerySendMsgTaskStatisticsResponse = exports.QuerySendMsgTaskStatisticsResponseBody = exports.QuerySendMsgTaskStatisticsRequest = exports.QuerySendMsgTaskStatisticsHeaders = exports.QueryInstancesByMultiConditionsResponse = exports.QueryInstancesByMultiConditionsResponseBody = exports.QueryInstancesByMultiConditionsRequest = exports.QueryInstancesByMultiConditionsHeaders = exports.QueryGroupSetResponse = exports.QueryGroupSetResponseBody = exports.QueryGroupSetRequest = exports.QueryGroupSetHeaders = exports.QueryGroupMemberResponse = exports.QueryGroupMemberResponseBody = exports.QueryGroupMemberRequest = void 0;
exports.UpgradeCloudGroupResponse = exports.UpgradeCloudGroupRequest = exports.UpgradeCloudGroupHeaders = exports.UpdateTicketResponse = exports.UpdateTicketRequest = exports.UpdateTicketHeaders = exports.UpdateInstanceResponse = exports.UpdateInstanceResponseBody = exports.UpdateInstanceRequest = exports.UpdateInstanceHeaders = exports.UpdateGroupTagResponse = exports.UpdateGroupTagRequest = exports.UpdateGroupTagHeaders = exports.UpdateGroupSetResponse = exports.UpdateGroupSetResponseBody = exports.UpdateGroupSetRequest = exports.UpdateGroupSetHeaders = exports.TransferTicketResponse = exports.TransferTicketRequest = exports.TransferTicketHeaders = exports.TopicStatisticsResponse = exports.TopicStatisticsResponseBody = exports.TopicStatisticsRequest = exports.TopicStatisticsHeaders = exports.TakeTicketResponse = exports.TakeTicketRequest = exports.TakeTicketHeaders = exports.SetRobotConfigResponse = exports.SetRobotConfigResponseBody = exports.SetRobotConfigRequest = exports.SetRobotConfigHeaders = exports.SendServiceGroupMessageResponse = exports.SendServiceGroupMessageResponseBody = exports.SendServiceGroupMessageRequest = exports.SendServiceGroupMessageHeaders = exports.SendMsgByTaskSupportInviteJoinOrgResponse = exports.SendMsgByTaskSupportInviteJoinOrgResponseBody = exports.SendMsgByTaskSupportInviteJoinOrgRequest = exports.SendMsgByTaskSupportInviteJoinOrgHeaders = exports.SendMsgByTaskResponse = exports.SendMsgByTaskResponseBody = exports.SendMsgByTaskRequest = exports.SendMsgByTaskHeaders = exports.SearchGroupResponse = exports.SearchGroupResponseBody = exports.SearchGroupRequest = exports.SearchGroupHeaders = exports.SaveFormInstanceResponse = exports.SaveFormInstanceResponseBody = exports.SaveFormInstanceRequest = void 0;
exports.IntentionStatisticsResponseBodyIntentionTrend = exports.IntentionStatisticsResponseBodyIntentionStatisticsRecords = exports.IntentionCategoryStatisticsResponseBodyIntentionCategoryRecords = exports.GroupStatisticsResponseBodyGroupTrend = exports.GetWordCloudResponseBodyWords = exports.GetTicketResponseBodyTemplate = exports.GetTicketResponseBodyTakers = exports.GetTicketResponseBodyProcessor = exports.GetTicketResponseBodyCreator = exports.GetNegativeWordCloudResponseBodyWords = exports.GetInstancesByIdsResponseBodyCustomFormInstanceResponseList = exports.GetAuthTokenResponseBodyResult = exports.FinishTicketRequestTicketMemo = exports.FinishTicketRequestTicketMemoAttachments = exports.FinishTicketRequestNotify = exports.EmotionStatisticsResponseBodyEmotionStatisticsRecords = exports.CustomerSendMsgTaskRequestSendConfig = exports.CustomerSendMsgTaskRequestSendConfigUrlTrackConfig = exports.CustomerSendMsgTaskRequestQueryCustomer = exports.CustomerSendMsgTaskRequestMessageContent = exports.CustomerSendMsgTaskRequestMessageContentBtns = exports.CreateTicketRequestSceneContext = exports.CreateTicketRequestSceneContextGroupMsgs = exports.CreateTicketRequestNotify = exports.CategoryStatisticsResponseBodyCategoryTrend = exports.CategoryStatisticsResponseBodyCategoryStatisticsRecords = exports.CancelTicketRequestTicketMemo = exports.CancelTicketRequestTicketMemoAttachments = exports.CancelTicketRequestNotify = exports.BatchQuerySendMessageTaskResponseBodyRecords = exports.BatchQueryGroupMemberResponseBodyRecords = exports.BatchQueryCustomerSendTaskResponseBodyRecords = exports.BatchGetGroupSetConfigResponseBodyGroupSetConfigs = exports.BatchBindingGroupBizIdsRequestBindingGroupBizIds = exports.AssignTicketRequestTicketMemo = exports.AssignTicketRequestTicketMemoAttachments = exports.AssignTicketRequestNotify = exports.AddTicketMemoRequestTicketMemo = exports.AddTicketMemoRequestTicketMemoAttachments = exports.AddOpenLibraryResponseBodyResult = exports.AddOpenKnowledgeResponseBodyResult = exports.AddOpenKnowledgeRequestAttachments = exports.AddOpenCategoryResponseBodyResult = exports.AddKnowledgeRequestAttachmentList = exports.UrgeTicketResponse = exports.UrgeTicketRequest = exports.UrgeTicketHeaders = exports.UpgradeNormalGroupResponse = exports.UpgradeNormalGroupRequest = exports.UpgradeNormalGroupHeaders = void 0;
exports.UrgeTicketRequestTicketMemo = exports.UrgeTicketRequestTicketMemoAttachments = exports.UpdateTicketRequestTicketMemo = exports.UpdateTicketRequestTicketMemoAttachments = exports.TransferTicketRequestTicketMemo = exports.TransferTicketRequestTicketMemoAttachments = exports.TransferTicketRequestNotify = exports.TopicStatisticsResponseBodyTopicStatisticsRecords = exports.SetRobotConfigResponseBodyResult = exports.SendServiceGroupMessageRequestBtns = exports.SendMsgByTaskSupportInviteJoinOrgRequestMessageContent = exports.SendMsgByTaskSupportInviteJoinOrgRequestMessageContentBtns = exports.SendMsgByTaskRequestSendConfig = exports.SendMsgByTaskRequestSendConfigUrlTrackConfig = exports.SendMsgByTaskRequestQueryGroup = exports.SendMsgByTaskRequestMessageContent = exports.SendMsgByTaskRequestMessageContentBtns = exports.SearchGroupResponseBodyRecords = exports.RetractTicketRequestTicketMemo = exports.RetractTicketRequestTicketMemoAttachments = exports.RetractTicketRequestNotify = exports.ResubmitTicketRequestTicketMemo = exports.ResubmitTicketRequestTicketMemoAttachments = exports.ResubmitTicketRequestSceneContext = exports.ResubmitTicketRequestSceneContextGroupMsgs = exports.ResubmitTicketRequestNotify = exports.ReportCustomerStatisticsResponseBodyRecords = exports.ReportCustomerDetailResponseBodyRecords = exports.QueryServiceGroupMessageReadStatusResponseBodyRecords = exports.QuerySendMsgTaskStatisticsDetailResponseBodyRecords = exports.QuerySendMsgTaskStatisticsResponseBodyRecords = exports.QuerySendMsgTaskStatisticsResponseBodyRecordsGroupUserReadStatistics = exports.QuerySendMsgTaskStatisticsResponseBodyRecordsGroup = exports.QueryInstancesByMultiConditionsResponseBodyRecords = exports.QueryInstancesByMultiConditionsRequestSortFields = exports.QueryGroupSetResponseBodyRecords = exports.QueryGroupMemberResponseBodyResult = exports.QueryGroupMemberResponseBodyResultGroupMemberList = exports.QueryCustomerTaskUserDetailResponseBodyRecords = exports.QueryCustomerTaskUserDetailResponseBodyRecordsEventTrackResponses = exports.QueryCrmGroupContactResponseBodyRecords = exports.QueryActiveUsersResponseBodyActiveUserInfos = exports.ListUserTeamsResponseBodyTeams = exports.ListTicketOperateRecordResponseBodyRecords = exports.ListTicketOperateRecordResponseBodyRecordsTicketMemo = exports.ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments = exports.ListTicketOperateRecordResponseBodyRecordsOperator = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddContactMemberToGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddContactMemberToGroupHeaders = AddContactMemberToGroupHeaders;
class AddContactMemberToGroupRequest extends $tea.Model {
    static names() {
        return {
            fissionType: 'fissionType',
            memberUnionId: 'memberUnionId',
            memberUserId: 'memberUserId',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            fissionType: 'string',
            memberUnionId: 'string',
            memberUserId: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddContactMemberToGroupRequest = AddContactMemberToGroupRequest;
class AddContactMemberToGroupResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddContactMemberToGroupResponseBody = AddContactMemberToGroupResponseBody;
class AddContactMemberToGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddContactMemberToGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddContactMemberToGroupResponse = AddContactMemberToGroupResponse;
class AddKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddKnowledgeHeaders = AddKnowledgeHeaders;
class AddKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            attachmentList: 'attachmentList',
            content: 'content',
            effectTimeend: 'effectTimeend',
            effectTimestart: 'effectTimestart',
            extTitle: 'extTitle',
            keyword: 'keyword',
            libraryKey: 'libraryKey',
            linkUrl: 'linkUrl',
            openTeamId: 'openTeamId',
            questionIds: 'questionIds',
            source: 'source',
            sourcePrimaryKey: 'sourcePrimaryKey',
            title: 'title',
            type: 'type',
            version: 'version',
        };
    }
    static types() {
        return {
            attachmentList: { 'type': 'array', 'itemType': AddKnowledgeRequestAttachmentList },
            content: 'string',
            effectTimeend: 'number',
            effectTimestart: 'number',
            extTitle: 'string',
            keyword: 'string',
            libraryKey: 'string',
            linkUrl: 'string',
            openTeamId: 'string',
            questionIds: { 'type': 'array', 'itemType': 'number' },
            source: 'string',
            sourcePrimaryKey: 'string',
            title: 'string',
            type: 'string',
            version: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddKnowledgeRequest = AddKnowledgeRequest;
class AddKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            openKnowledgeId: 'openKnowledgeId',
        };
    }
    static types() {
        return {
            openKnowledgeId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddKnowledgeResponseBody = AddKnowledgeResponseBody;
class AddKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddKnowledgeResponse = AddKnowledgeResponse;
class AddLibraryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddLibraryHeaders = AddLibraryHeaders;
class AddLibraryRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
            openTeamIds: 'openTeamIds',
            source: 'source',
            sourcePrimaryKey: 'sourcePrimaryKey',
            title: 'title',
            type: 'type',
            userId: 'userId',
        };
    }
    static types() {
        return {
            description: 'string',
            openTeamIds: { 'type': 'array', 'itemType': 'string' },
            source: 'string',
            sourcePrimaryKey: 'string',
            title: 'string',
            type: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddLibraryRequest = AddLibraryRequest;
class AddLibraryResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddLibraryResponseBody = AddLibraryResponseBody;
class AddLibraryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddLibraryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddLibraryResponse = AddLibraryResponse;
class AddMemberToServiceGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddMemberToServiceGroupHeaders = AddMemberToServiceGroupHeaders;
class AddMemberToServiceGroupRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openTeamId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddMemberToServiceGroupRequest = AddMemberToServiceGroupRequest;
class AddMemberToServiceGroupResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddMemberToServiceGroupResponseBody = AddMemberToServiceGroupResponseBody;
class AddMemberToServiceGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddMemberToServiceGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddMemberToServiceGroupResponse = AddMemberToServiceGroupResponse;
class AddOpenCategoryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenCategoryHeaders = AddOpenCategoryHeaders;
class AddOpenCategoryRequest extends $tea.Model {
    static names() {
        return {
            libraryId: 'libraryId',
            openTeamId: 'openTeamId',
            parentId: 'parentId',
            title: 'title',
            userId: 'userId',
            userName: 'userName',
        };
    }
    static types() {
        return {
            libraryId: 'number',
            openTeamId: 'string',
            parentId: 'number',
            title: 'string',
            userId: 'string',
            userName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenCategoryRequest = AddOpenCategoryRequest;
class AddOpenCategoryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: AddOpenCategoryResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenCategoryResponseBody = AddOpenCategoryResponseBody;
class AddOpenCategoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddOpenCategoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenCategoryResponse = AddOpenCategoryResponse;
class AddOpenKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeHeaders = AddOpenKnowledgeHeaders;
class AddOpenKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            categoryId: 'categoryId',
            content: 'content',
            effectTimeend: 'effectTimeend',
            effectTimestart: 'effectTimestart',
            extTitle: 'extTitle',
            keyword: 'keyword',
            libraryId: 'libraryId',
            openTeamId: 'openTeamId',
            source: 'source',
            tags: 'tags',
            title: 'title',
            type: 'type',
            userId: 'userId',
            userName: 'userName',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': AddOpenKnowledgeRequestAttachments },
            categoryId: 'number',
            content: 'string',
            effectTimeend: 'string',
            effectTimestart: 'string',
            extTitle: 'string',
            keyword: 'string',
            libraryId: 'number',
            openTeamId: 'string',
            source: 'string',
            tags: 'string',
            title: 'string',
            type: 'string',
            userId: 'string',
            userName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeRequest = AddOpenKnowledgeRequest;
class AddOpenKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: AddOpenKnowledgeResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeResponseBody = AddOpenKnowledgeResponseBody;
class AddOpenKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddOpenKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeResponse = AddOpenKnowledgeResponse;
class AddOpenLibraryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenLibraryHeaders = AddOpenLibraryHeaders;
class AddOpenLibraryRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
            openTeamId: 'openTeamId',
            source: 'source',
            title: 'title',
            type: 'type',
            userId: 'userId',
            userName: 'userName',
        };
    }
    static types() {
        return {
            description: 'string',
            openTeamId: 'string',
            source: 'string',
            title: 'string',
            type: 'string',
            userId: 'string',
            userName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenLibraryRequest = AddOpenLibraryRequest;
class AddOpenLibraryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: AddOpenLibraryResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenLibraryResponseBody = AddOpenLibraryResponseBody;
class AddOpenLibraryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddOpenLibraryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenLibraryResponse = AddOpenLibraryResponse;
class AddTicketMemoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTicketMemoHeaders = AddTicketMemoHeaders;
class AddTicketMemoRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            processorUnionId: 'processorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            openTicketId: 'string',
            processorUnionId: 'string',
            ticketMemo: AddTicketMemoRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTicketMemoRequest = AddTicketMemoRequest;
class AddTicketMemoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTicketMemoResponse = AddTicketMemoResponse;
class AssignTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketHeaders = AssignTicketHeaders;
class AssignTicketRequest extends $tea.Model {
    static names() {
        return {
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            operatorUnionId: 'operatorUnionId',
            processorUnionIds: 'processorUnionIds',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            notify: AssignTicketRequestNotify,
            openTeamId: 'string',
            openTicketId: 'string',
            operatorUnionId: 'string',
            processorUnionIds: { 'type': 'array', 'itemType': 'string' },
            ticketMemo: AssignTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketRequest = AssignTicketRequest;
class AssignTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketResponse = AssignTicketResponse;
class BatchBindingGroupBizIdsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchBindingGroupBizIdsHeaders = BatchBindingGroupBizIdsHeaders;
class BatchBindingGroupBizIdsRequest extends $tea.Model {
    static names() {
        return {
            bindingGroupBizIds: 'bindingGroupBizIds',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            bindingGroupBizIds: { 'type': 'array', 'itemType': BatchBindingGroupBizIdsRequestBindingGroupBizIds },
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchBindingGroupBizIdsRequest = BatchBindingGroupBizIdsRequest;
class BatchBindingGroupBizIdsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchBindingGroupBizIdsResponseBody = BatchBindingGroupBizIdsResponseBody;
class BatchBindingGroupBizIdsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchBindingGroupBizIdsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchBindingGroupBizIdsResponse = BatchBindingGroupBizIdsResponse;
class BatchGetGroupSetConfigHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetGroupSetConfigHeaders = BatchGetGroupSetConfigHeaders;
class BatchGetGroupSetConfigRequest extends $tea.Model {
    static names() {
        return {
            configKeys: 'configKeys',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            configKeys: { 'type': 'array', 'itemType': 'string' },
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetGroupSetConfigRequest = BatchGetGroupSetConfigRequest;
class BatchGetGroupSetConfigResponseBody extends $tea.Model {
    static names() {
        return {
            groupSetConfigs: 'groupSetConfigs',
        };
    }
    static types() {
        return {
            groupSetConfigs: { 'type': 'array', 'itemType': BatchGetGroupSetConfigResponseBodyGroupSetConfigs },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetGroupSetConfigResponseBody = BatchGetGroupSetConfigResponseBody;
class BatchGetGroupSetConfigResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetGroupSetConfigResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetGroupSetConfigResponse = BatchGetGroupSetConfigResponse;
class BatchQueryCustomerSendTaskHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryCustomerSendTaskHeaders = BatchQueryCustomerSendTaskHeaders;
class BatchQueryCustomerSendTaskRequest extends $tea.Model {
    static names() {
        return {
            gmtCreateEnd: 'gmtCreateEnd',
            gmtCreateStart: 'gmtCreateStart',
            maxResults: 'maxResults',
            needRichStatistics: 'needRichStatistics',
            nextToken: 'nextToken',
            openBatchTaskIds: 'openBatchTaskIds',
            openTeamId: 'openTeamId',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            gmtCreateEnd: 'string',
            gmtCreateStart: 'string',
            maxResults: 'number',
            needRichStatistics: 'boolean',
            nextToken: 'string',
            openBatchTaskIds: { 'type': 'array', 'itemType': 'string' },
            openTeamId: 'string',
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryCustomerSendTaskRequest = BatchQueryCustomerSendTaskRequest;
class BatchQueryCustomerSendTaskResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': BatchQueryCustomerSendTaskResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryCustomerSendTaskResponseBody = BatchQueryCustomerSendTaskResponseBody;
class BatchQueryCustomerSendTaskResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryCustomerSendTaskResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryCustomerSendTaskResponse = BatchQueryCustomerSendTaskResponse;
class BatchQueryGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberHeaders = BatchQueryGroupMemberHeaders;
class BatchQueryGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberRequest = BatchQueryGroupMemberRequest;
class BatchQueryGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            records: 'records',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            openConversationId: 'string',
            records: { 'type': 'array', 'itemType': BatchQueryGroupMemberResponseBodyRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberResponseBody = BatchQueryGroupMemberResponseBody;
class BatchQueryGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberResponse = BatchQueryGroupMemberResponse;
class BatchQuerySendMessageTaskHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQuerySendMessageTaskHeaders = BatchQuerySendMessageTaskHeaders;
class BatchQuerySendMessageTaskRequest extends $tea.Model {
    static names() {
        return {
            getReadCount: 'getReadCount',
            gmtCreateEnd: 'gmtCreateEnd',
            gmtCreateStart: 'gmtCreateStart',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            getReadCount: 'boolean',
            gmtCreateEnd: 'string',
            gmtCreateStart: 'string',
            maxResults: 'number',
            nextToken: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQuerySendMessageTaskRequest = BatchQuerySendMessageTaskRequest;
class BatchQuerySendMessageTaskResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': BatchQuerySendMessageTaskResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQuerySendMessageTaskResponseBody = BatchQuerySendMessageTaskResponseBody;
class BatchQuerySendMessageTaskResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQuerySendMessageTaskResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQuerySendMessageTaskResponse = BatchQuerySendMessageTaskResponse;
class BoundTemplateToTeamHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BoundTemplateToTeamHeaders = BoundTemplateToTeamHeaders;
class BoundTemplateToTeamRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            robotConfig: 'robotConfig',
            templateDesc: 'templateDesc',
            templateId: 'templateId',
            templateName: 'templateName',
            templateType: 'templateType',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            robotConfig: 'string',
            templateDesc: 'string',
            templateId: 'string',
            templateName: 'string',
            templateType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BoundTemplateToTeamRequest = BoundTemplateToTeamRequest;
class BoundTemplateToTeamResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BoundTemplateToTeamResponseBody = BoundTemplateToTeamResponseBody;
class BoundTemplateToTeamResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BoundTemplateToTeamResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BoundTemplateToTeamResponse = BoundTemplateToTeamResponse;
class CancelTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketHeaders = CancelTicketHeaders;
class CancelTicketRequest extends $tea.Model {
    static names() {
        return {
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            operatorUnionId: 'operatorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            notify: CancelTicketRequestNotify,
            openTeamId: 'string',
            openTicketId: 'string',
            operatorUnionId: 'string',
            ticketMemo: CancelTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketRequest = CancelTicketRequest;
class CancelTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketResponse = CancelTicketResponse;
class CategoryStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsHeaders = CategoryStatisticsHeaders;
class CategoryStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            minDt: 'minDt',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            minDt: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsRequest = CategoryStatisticsRequest;
class CategoryStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            categoryStatisticsRecords: 'categoryStatisticsRecords',
            categoryTrend: 'categoryTrend',
        };
    }
    static types() {
        return {
            categoryStatisticsRecords: { 'type': 'array', 'itemType': CategoryStatisticsResponseBodyCategoryStatisticsRecords },
            categoryTrend: { 'type': 'array', 'itemType': CategoryStatisticsResponseBodyCategoryTrend },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsResponseBody = CategoryStatisticsResponseBody;
class CategoryStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CategoryStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsResponse = CategoryStatisticsResponse;
class CloseConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseConversationHeaders = CloseConversationHeaders;
class CloseConversationRequest extends $tea.Model {
    static names() {
        return {
            conversationId: 'conversationId',
            openTeamId: 'openTeamId',
            serverTips: 'serverTips',
            serviceToken: 'serviceToken',
            targetChannel: 'targetChannel',
            visitorToken: 'visitorToken',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            openTeamId: 'string',
            serverTips: 'string',
            serviceToken: 'string',
            targetChannel: 'string',
            visitorToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseConversationRequest = CloseConversationRequest;
class CloseConversationResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseConversationResponseBody = CloseConversationResponseBody;
class CloseConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseConversationResponse = CloseConversationResponse;
class CloseHumanSessionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseHumanSessionHeaders = CloseHumanSessionHeaders;
class CloseHumanSessionRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseHumanSessionRequest = CloseHumanSessionRequest;
class CloseHumanSessionResponseBody extends $tea.Model {
    static names() {
        return {
            sessionId: 'sessionId',
        };
    }
    static types() {
        return {
            sessionId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseHumanSessionResponseBody = CloseHumanSessionResponseBody;
class CloseHumanSessionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseHumanSessionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseHumanSessionResponse = CloseHumanSessionResponse;
class ConversationCreatedNotifyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationCreatedNotifyHeaders = ConversationCreatedNotifyHeaders;
class ConversationCreatedNotifyRequest extends $tea.Model {
    static names() {
        return {
            alipayUserId: 'alipayUserId',
            conversationId: 'conversationId',
            nickName: 'nickName',
            openTeamId: 'openTeamId',
            serverName: 'serverName',
            serverTips: 'serverTips',
            serviceToken: 'serviceToken',
            timeoutRemindTips: 'timeoutRemindTips',
            userId: 'userId',
            visitorToken: 'visitorToken',
        };
    }
    static types() {
        return {
            alipayUserId: 'string',
            conversationId: 'string',
            nickName: 'string',
            openTeamId: 'string',
            serverName: 'string',
            serverTips: 'string',
            serviceToken: 'string',
            timeoutRemindTips: 'string',
            userId: 'string',
            visitorToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationCreatedNotifyRequest = ConversationCreatedNotifyRequest;
class ConversationCreatedNotifyResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationCreatedNotifyResponseBody = ConversationCreatedNotifyResponseBody;
class ConversationCreatedNotifyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConversationCreatedNotifyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationCreatedNotifyResponse = ConversationCreatedNotifyResponse;
class ConversationTransferBeginNotifyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferBeginNotifyHeaders = ConversationTransferBeginNotifyHeaders;
class ConversationTransferBeginNotifyRequest extends $tea.Model {
    static names() {
        return {
            conversationId: 'conversationId',
            memo: 'memo',
            openTeamId: 'openTeamId',
            serviceToken: 'serviceToken',
            sourceSkillGroupId: 'sourceSkillGroupId',
            targetSkillGroupId: 'targetSkillGroupId',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            memo: 'string',
            openTeamId: 'string',
            serviceToken: 'string',
            sourceSkillGroupId: 'string',
            targetSkillGroupId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferBeginNotifyRequest = ConversationTransferBeginNotifyRequest;
class ConversationTransferBeginNotifyResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferBeginNotifyResponseBody = ConversationTransferBeginNotifyResponseBody;
class ConversationTransferBeginNotifyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConversationTransferBeginNotifyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferBeginNotifyResponse = ConversationTransferBeginNotifyResponse;
class ConversationTransferCompleteNotifyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferCompleteNotifyHeaders = ConversationTransferCompleteNotifyHeaders;
class ConversationTransferCompleteNotifyRequest extends $tea.Model {
    static names() {
        return {
            alipayUserId: 'alipayUserId',
            conversationId: 'conversationId',
            nickName: 'nickName',
            openTeamId: 'openTeamId',
            serviceToken: 'serviceToken',
            userId: 'userId',
            visitorToken: 'visitorToken',
        };
    }
    static types() {
        return {
            alipayUserId: 'string',
            conversationId: 'string',
            nickName: 'string',
            openTeamId: 'string',
            serviceToken: 'string',
            userId: 'string',
            visitorToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferCompleteNotifyRequest = ConversationTransferCompleteNotifyRequest;
class ConversationTransferCompleteNotifyResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferCompleteNotifyResponseBody = ConversationTransferCompleteNotifyResponseBody;
class ConversationTransferCompleteNotifyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConversationTransferCompleteNotifyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ConversationTransferCompleteNotifyResponse = ConversationTransferCompleteNotifyResponse;
class CreateGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupHeaders = CreateGroupHeaders;
class CreateGroupRequest extends $tea.Model {
    static names() {
        return {
            groupBizId: 'groupBizId',
            groupName: 'groupName',
            groupTagNames: 'groupTagNames',
            memberStaffIds: 'memberStaffIds',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            ownerStaffId: 'ownerStaffId',
        };
    }
    static types() {
        return {
            groupBizId: 'string',
            groupName: 'string',
            groupTagNames: { 'type': 'array', 'itemType': 'string' },
            memberStaffIds: { 'type': 'array', 'itemType': 'string' },
            openGroupSetId: 'string',
            openTeamId: 'string',
            ownerStaffId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupRequest = CreateGroupRequest;
class CreateGroupResponseBody extends $tea.Model {
    static names() {
        return {
            groupUrl: 'groupUrl',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupUrl: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupResponseBody = CreateGroupResponseBody;
class CreateGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupResponse = CreateGroupResponse;
class CreateGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationHeaders = CreateGroupConversationHeaders;
class CreateGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            dingGroupId: 'dingGroupId',
            dingSuiteKey: 'dingSuiteKey',
            dingTokenGrantType: 'dingTokenGrantType',
            dingUserId: 'dingUserId',
            dingUserName: 'dingUserName',
            extValues: 'extValues',
            openTeamId: 'openTeamId',
            serverGroupId: 'serverGroupId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            dingGroupId: 'string',
            dingSuiteKey: 'string',
            dingTokenGrantType: 'number',
            dingUserId: 'string',
            dingUserName: 'string',
            extValues: 'string',
            openTeamId: 'string',
            serverGroupId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationRequest = CreateGroupConversationRequest;
class CreateGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationResponseBody = CreateGroupConversationResponseBody;
class CreateGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationResponse = CreateGroupConversationResponse;
class CreateGroupSetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupSetHeaders = CreateGroupSetHeaders;
class CreateGroupSetRequest extends $tea.Model {
    static names() {
        return {
            groupSetName: 'groupSetName',
            groupTemplateId: 'groupTemplateId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            groupSetName: 'string',
            groupTemplateId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupSetRequest = CreateGroupSetRequest;
class CreateGroupSetResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupSetResponseBody = CreateGroupSetResponseBody;
class CreateGroupSetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupSetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupSetResponse = CreateGroupSetResponse;
class CreateInstanceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInstanceHeaders = CreateInstanceHeaders;
class CreateInstanceRequest extends $tea.Model {
    static names() {
        return {
            channel: 'channel',
            externalBizId: 'externalBizId',
            formCode: 'formCode',
            formDataList: 'formDataList',
            openTeamId: 'openTeamId',
            operatorUnionId: 'operatorUnionId',
            ownerUnionId: 'ownerUnionId',
        };
    }
    static types() {
        return {
            channel: 'string',
            externalBizId: 'string',
            formCode: 'string',
            formDataList: 'string',
            openTeamId: 'string',
            operatorUnionId: 'string',
            ownerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInstanceRequest = CreateInstanceRequest;
class CreateInstanceResponseBody extends $tea.Model {
    static names() {
        return {
            openDataInstanceId: 'openDataInstanceId',
        };
    }
    static types() {
        return {
            openDataInstanceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInstanceResponseBody = CreateInstanceResponseBody;
class CreateInstanceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateInstanceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInstanceResponse = CreateInstanceResponse;
class CreateTeamHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTeamHeaders = CreateTeamHeaders;
class CreateTeamRequest extends $tea.Model {
    static names() {
        return {
            creatorDingUnionId: 'creatorDingUnionId',
            teamName: 'teamName',
        };
    }
    static types() {
        return {
            creatorDingUnionId: 'string',
            teamName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTeamRequest = CreateTeamRequest;
class CreateTeamResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTeamResponseBody = CreateTeamResponseBody;
class CreateTeamResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTeamResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTeamResponse = CreateTeamResponse;
class CreateTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketHeaders = CreateTicketHeaders;
class CreateTicketRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            customFields: 'customFields',
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTemplateBizId: 'openTemplateBizId',
            processorUnionIds: 'processorUnionIds',
            scene: 'scene',
            sceneContext: 'sceneContext',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            customFields: 'string',
            notify: CreateTicketRequestNotify,
            openTeamId: 'string',
            openTemplateBizId: 'string',
            processorUnionIds: { 'type': 'array', 'itemType': 'string' },
            scene: 'string',
            sceneContext: CreateTicketRequestSceneContext,
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketRequest = CreateTicketRequest;
class CreateTicketResponseBody extends $tea.Model {
    static names() {
        return {
            openTicketId: 'openTicketId',
        };
    }
    static types() {
        return {
            openTicketId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketResponseBody = CreateTicketResponseBody;
class CreateTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTicketResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketResponse = CreateTicketResponse;
class CustomerSendMsgTaskHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskHeaders = CustomerSendMsgTaskHeaders;
class CustomerSendMsgTaskRequest extends $tea.Model {
    static names() {
        return {
            messageContent: 'messageContent',
            openTeamId: 'openTeamId',
            queryCustomer: 'queryCustomer',
            sendConfig: 'sendConfig',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            messageContent: CustomerSendMsgTaskRequestMessageContent,
            openTeamId: 'string',
            queryCustomer: CustomerSendMsgTaskRequestQueryCustomer,
            sendConfig: CustomerSendMsgTaskRequestSendConfig,
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequest = CustomerSendMsgTaskRequest;
class CustomerSendMsgTaskResponseBody extends $tea.Model {
    static names() {
        return {
            openBatchTaskId: 'openBatchTaskId',
        };
    }
    static types() {
        return {
            openBatchTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskResponseBody = CustomerSendMsgTaskResponseBody;
class CustomerSendMsgTaskResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CustomerSendMsgTaskResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskResponse = CustomerSendMsgTaskResponse;
class DeleteGroupMembersFromGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteGroupMembersFromGroupHeaders = DeleteGroupMembersFromGroupHeaders;
class DeleteGroupMembersFromGroupRequest extends $tea.Model {
    static names() {
        return {
            deleteGroupType: 'deleteGroupType',
            memberUnionId: 'memberUnionId',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            deleteGroupType: 'string',
            memberUnionId: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteGroupMembersFromGroupRequest = DeleteGroupMembersFromGroupRequest;
class DeleteGroupMembersFromGroupResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteGroupMembersFromGroupResponseBody = DeleteGroupMembersFromGroupResponseBody;
class DeleteGroupMembersFromGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteGroupMembersFromGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteGroupMembersFromGroupResponse = DeleteGroupMembersFromGroupResponse;
class DeleteInstanceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteInstanceHeaders = DeleteInstanceHeaders;
class DeleteInstanceRequest extends $tea.Model {
    static names() {
        return {
            formCode: 'formCode',
            openDataInstanceId: 'openDataInstanceId',
            openTeamId: 'openTeamId',
            operatorUnionId: 'operatorUnionId',
        };
    }
    static types() {
        return {
            formCode: 'string',
            openDataInstanceId: 'string',
            openTeamId: 'string',
            operatorUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteInstanceRequest = DeleteInstanceRequest;
class DeleteInstanceResponseBody extends $tea.Model {
    static names() {
        return {
            openDataInstanceId: 'openDataInstanceId',
        };
    }
    static types() {
        return {
            openDataInstanceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteInstanceResponseBody = DeleteInstanceResponseBody;
class DeleteInstanceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteInstanceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteInstanceResponse = DeleteInstanceResponse;
class DeleteKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeHeaders = DeleteKnowledgeHeaders;
class DeleteKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            libraryKey: 'libraryKey',
            openTeamId: 'openTeamId',
            source: 'source',
            sourcePrimaryKey: 'sourcePrimaryKey',
        };
    }
    static types() {
        return {
            libraryKey: 'string',
            openTeamId: 'string',
            source: 'string',
            sourcePrimaryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeRequest = DeleteKnowledgeRequest;
class DeleteKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeResponseBody = DeleteKnowledgeResponseBody;
class DeleteKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeResponse = DeleteKnowledgeResponse;
class EmotionStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmotionStatisticsHeaders = EmotionStatisticsHeaders;
class EmotionStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            maxEmotion: 'maxEmotion',
            minDt: 'minDt',
            minEmotion: 'minEmotion',
            openConversationIds: 'openConversationIds',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            maxEmotion: 'number',
            minDt: 'string',
            minEmotion: 'number',
            openConversationIds: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmotionStatisticsRequest = EmotionStatisticsRequest;
class EmotionStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            emotionStatisticsRecords: 'emotionStatisticsRecords',
        };
    }
    static types() {
        return {
            emotionStatisticsRecords: { 'type': 'array', 'itemType': EmotionStatisticsResponseBodyEmotionStatisticsRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmotionStatisticsResponseBody = EmotionStatisticsResponseBody;
class EmotionStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EmotionStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmotionStatisticsResponse = EmotionStatisticsResponse;
class FinishTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketHeaders = FinishTicketHeaders;
class FinishTicketRequest extends $tea.Model {
    static names() {
        return {
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            processorUnionId: 'processorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            notify: FinishTicketRequestNotify,
            openTeamId: 'string',
            openTicketId: 'string',
            processorUnionId: 'string',
            ticketMemo: FinishTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketRequest = FinishTicketRequest;
class FinishTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketResponse = FinishTicketResponse;
class GetAuthTokenHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenHeaders = GetAuthTokenHeaders;
class GetAuthTokenRequest extends $tea.Model {
    static names() {
        return {
            channel: 'channel',
            effectiveTime: 'effectiveTime',
            openTeamId: 'openTeamId',
            serverId: 'serverId',
            serverName: 'serverName',
        };
    }
    static types() {
        return {
            channel: 'string',
            effectiveTime: 'number',
            openTeamId: 'string',
            serverId: 'string',
            serverName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenRequest = GetAuthTokenRequest;
class GetAuthTokenResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: GetAuthTokenResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponseBody = GetAuthTokenResponseBody;
class GetAuthTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAuthTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponse = GetAuthTokenResponse;
class GetInstancesByIdsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInstancesByIdsHeaders = GetInstancesByIdsHeaders;
class GetInstancesByIdsRequest extends $tea.Model {
    static names() {
        return {
            formCode: 'formCode',
            openDataInstanceIdList: 'openDataInstanceIdList',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            formCode: 'string',
            openDataInstanceIdList: { 'type': 'array', 'itemType': 'string' },
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInstancesByIdsRequest = GetInstancesByIdsRequest;
class GetInstancesByIdsResponseBody extends $tea.Model {
    static names() {
        return {
            customFormInstanceResponseList: 'customFormInstanceResponseList',
        };
    }
    static types() {
        return {
            customFormInstanceResponseList: { 'type': 'array', 'itemType': GetInstancesByIdsResponseBodyCustomFormInstanceResponseList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInstancesByIdsResponseBody = GetInstancesByIdsResponseBody;
class GetInstancesByIdsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetInstancesByIdsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInstancesByIdsResponse = GetInstancesByIdsResponse;
class GetNegativeWordCloudHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNegativeWordCloudHeaders = GetNegativeWordCloudHeaders;
class GetNegativeWordCloudRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNegativeWordCloudRequest = GetNegativeWordCloudRequest;
class GetNegativeWordCloudResponseBody extends $tea.Model {
    static names() {
        return {
            words: 'words',
        };
    }
    static types() {
        return {
            words: { 'type': 'array', 'itemType': GetNegativeWordCloudResponseBodyWords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNegativeWordCloudResponseBody = GetNegativeWordCloudResponseBody;
class GetNegativeWordCloudResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetNegativeWordCloudResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNegativeWordCloudResponse = GetNegativeWordCloudResponse;
class GetOssTempUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOssTempUrlHeaders = GetOssTempUrlHeaders;
class GetOssTempUrlRequest extends $tea.Model {
    static names() {
        return {
            fetchMode: 'fetchMode',
            fileName: 'fileName',
            key: 'key',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            fetchMode: 'string',
            fileName: 'string',
            key: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOssTempUrlRequest = GetOssTempUrlRequest;
class GetOssTempUrlResponseBody extends $tea.Model {
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOssTempUrlResponseBody = GetOssTempUrlResponseBody;
class GetOssTempUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOssTempUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOssTempUrlResponse = GetOssTempUrlResponse;
class GetStoragePolicyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetStoragePolicyHeaders = GetStoragePolicyHeaders;
class GetStoragePolicyRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            fileName: 'fileName',
            fileSize: 'fileSize',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            fileName: 'string',
            fileSize: 'number',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetStoragePolicyRequest = GetStoragePolicyRequest;
class GetStoragePolicyResponseBody extends $tea.Model {
    static names() {
        return {
            accessKeyId: 'accessKeyId',
            endpoint: 'endpoint',
            key: 'key',
            policy: 'policy',
            signature: 'signature',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            endpoint: 'string',
            key: 'string',
            policy: 'string',
            signature: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetStoragePolicyResponseBody = GetStoragePolicyResponseBody;
class GetStoragePolicyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetStoragePolicyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetStoragePolicyResponse = GetStoragePolicyResponse;
class GetTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketHeaders = GetTicketHeaders;
class GetTicketRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            openTicketId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketRequest = GetTicketRequest;
class GetTicketResponseBody extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            creator: 'creator',
            customFields: 'customFields',
            openConversationId: 'openConversationId',
            openTicketId: 'openTicketId',
            processor: 'processor',
            scene: 'scene',
            sceneContext: 'sceneContext',
            stage: 'stage',
            takers: 'takers',
            template: 'template',
            title: 'title',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            createTime: 'string',
            creator: GetTicketResponseBodyCreator,
            customFields: 'string',
            openConversationId: 'string',
            openTicketId: 'string',
            processor: GetTicketResponseBodyProcessor,
            scene: 'string',
            sceneContext: 'string',
            stage: 'string',
            takers: { 'type': 'array', 'itemType': GetTicketResponseBodyTakers },
            template: GetTicketResponseBodyTemplate,
            title: 'string',
            updateTime: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponseBody = GetTicketResponseBody;
class GetTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTicketResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponse = GetTicketResponse;
class GetWordCloudHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWordCloudHeaders = GetWordCloudHeaders;
class GetWordCloudRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWordCloudRequest = GetWordCloudRequest;
class GetWordCloudResponseBody extends $tea.Model {
    static names() {
        return {
            words: 'words',
        };
    }
    static types() {
        return {
            words: { 'type': 'array', 'itemType': GetWordCloudResponseBodyWords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWordCloudResponseBody = GetWordCloudResponseBody;
class GetWordCloudResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWordCloudResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWordCloudResponse = GetWordCloudResponse;
class GroupStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupStatisticsHeaders = GroupStatisticsHeaders;
class GroupStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            minDt: 'minDt',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            minDt: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupStatisticsRequest = GroupStatisticsRequest;
class GroupStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            groupCount: 'groupCount',
            groupTrend: 'groupTrend',
            increaseGroupCount: 'increaseGroupCount',
            increaseRate: 'increaseRate',
        };
    }
    static types() {
        return {
            groupCount: 'number',
            groupTrend: { 'type': 'array', 'itemType': GroupStatisticsResponseBodyGroupTrend },
            increaseGroupCount: 'number',
            increaseRate: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupStatisticsResponseBody = GroupStatisticsResponseBody;
class GroupStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupStatisticsResponse = GroupStatisticsResponse;
class IntentionCategoryStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionCategoryStatisticsHeaders = IntentionCategoryStatisticsHeaders;
class IntentionCategoryStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            minDt: 'minDt',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            minDt: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionCategoryStatisticsRequest = IntentionCategoryStatisticsRequest;
class IntentionCategoryStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            intentionCategoryRecords: 'intentionCategoryRecords',
        };
    }
    static types() {
        return {
            intentionCategoryRecords: { 'type': 'array', 'itemType': IntentionCategoryStatisticsResponseBodyIntentionCategoryRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionCategoryStatisticsResponseBody = IntentionCategoryStatisticsResponseBody;
class IntentionCategoryStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: IntentionCategoryStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionCategoryStatisticsResponse = IntentionCategoryStatisticsResponse;
class IntentionStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsHeaders = IntentionStatisticsHeaders;
class IntentionStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            minDt: 'minDt',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            minDt: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsRequest = IntentionStatisticsRequest;
class IntentionStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            intentionStatisticsRecords: 'intentionStatisticsRecords',
            intentionTrend: 'intentionTrend',
        };
    }
    static types() {
        return {
            intentionStatisticsRecords: { 'type': 'array', 'itemType': IntentionStatisticsResponseBodyIntentionStatisticsRecords },
            intentionTrend: { 'type': 'array', 'itemType': IntentionStatisticsResponseBodyIntentionTrend },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsResponseBody = IntentionStatisticsResponseBody;
class IntentionStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: IntentionStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsResponse = IntentionStatisticsResponse;
class ListTicketOperateRecordHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordHeaders = ListTicketOperateRecordHeaders;
class ListTicketOperateRecordRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            openTicketId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordRequest = ListTicketOperateRecordRequest;
class ListTicketOperateRecordResponseBody extends $tea.Model {
    static names() {
        return {
            records: 'records',
        };
    }
    static types() {
        return {
            records: { 'type': 'array', 'itemType': ListTicketOperateRecordResponseBodyRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponseBody = ListTicketOperateRecordResponseBody;
class ListTicketOperateRecordResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTicketOperateRecordResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponse = ListTicketOperateRecordResponse;
class ListUserTeamsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListUserTeamsHeaders = ListUserTeamsHeaders;
class ListUserTeamsResponseBody extends $tea.Model {
    static names() {
        return {
            teams: 'teams',
        };
    }
    static types() {
        return {
            teams: { 'type': 'array', 'itemType': ListUserTeamsResponseBodyTeams },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListUserTeamsResponseBody = ListUserTeamsResponseBody;
class ListUserTeamsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListUserTeamsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListUserTeamsResponse = ListUserTeamsResponse;
class QueryActiveUsersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryActiveUsersHeaders = QueryActiveUsersHeaders;
class QueryActiveUsersRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
            topN: 'topN',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openTeamId: 'string',
            topN: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryActiveUsersRequest = QueryActiveUsersRequest;
class QueryActiveUsersResponseBody extends $tea.Model {
    static names() {
        return {
            activeUserInfos: 'activeUserInfos',
        };
    }
    static types() {
        return {
            activeUserInfos: { 'type': 'array', 'itemType': QueryActiveUsersResponseBodyActiveUserInfos },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryActiveUsersResponseBody = QueryActiveUsersResponseBody;
class QueryActiveUsersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryActiveUsersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryActiveUsersResponse = QueryActiveUsersResponse;
class QueryCrmGroupContactHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCrmGroupContactHeaders = QueryCrmGroupContactHeaders;
class QueryCrmGroupContactRequest extends $tea.Model {
    static names() {
        return {
            minResult: 'minResult',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
            searchFields: 'searchFields',
        };
    }
    static types() {
        return {
            minResult: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
            searchFields: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCrmGroupContactRequest = QueryCrmGroupContactRequest;
class QueryCrmGroupContactResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            records: 'records',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            openConversationId: 'string',
            records: { 'type': 'array', 'itemType': QueryCrmGroupContactResponseBodyRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCrmGroupContactResponseBody = QueryCrmGroupContactResponseBody;
class QueryCrmGroupContactResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCrmGroupContactResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCrmGroupContactResponse = QueryCrmGroupContactResponse;
class QueryCustomerCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerCardHeaders = QueryCustomerCardHeaders;
class QueryCustomerCardRequest extends $tea.Model {
    static names() {
        return {
            jsonParams: 'jsonParams',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            jsonParams: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerCardRequest = QueryCustomerCardRequest;
class QueryCustomerCardResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerCardResponseBody = QueryCustomerCardResponseBody;
class QueryCustomerCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCustomerCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerCardResponse = QueryCustomerCardResponse;
class QueryCustomerTaskUserDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailHeaders = QueryCustomerTaskUserDetailHeaders;
class QueryCustomerTaskUserDetailRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openBatchTaskId: 'openBatchTaskId',
            openTeamId: 'openTeamId',
            receiverUnionIds: 'receiverUnionIds',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openBatchTaskId: 'string',
            openTeamId: 'string',
            receiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailRequest = QueryCustomerTaskUserDetailRequest;
class QueryCustomerTaskUserDetailResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': QueryCustomerTaskUserDetailResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailResponseBody = QueryCustomerTaskUserDetailResponseBody;
class QueryCustomerTaskUserDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCustomerTaskUserDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailResponse = QueryCustomerTaskUserDetailResponse;
class QueryGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupHeaders = QueryGroupHeaders;
class QueryGroupRequest extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupRequest = QueryGroupRequest;
class QueryGroupResponseBody extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            groupName: 'groupName',
            groupUrl: 'groupUrl',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            robotCode: 'robotCode',
            robotName: 'robotName',
        };
    }
    static types() {
        return {
            bizId: 'string',
            groupName: 'string',
            groupUrl: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
            robotCode: 'string',
            robotName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupResponseBody = QueryGroupResponseBody;
class QueryGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupResponse = QueryGroupResponse;
class QueryGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberHeaders = QueryGroupMemberHeaders;
class QueryGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
            targetCorpId: 'targetCorpId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openTeamId: 'string',
            targetCorpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberRequest = QueryGroupMemberRequest;
class QueryGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryGroupMemberResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponseBody = QueryGroupMemberResponseBody;
class QueryGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponse = QueryGroupMemberResponse;
class QueryGroupSetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupSetHeaders = QueryGroupSetHeaders;
class QueryGroupSetRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupSetRequest = QueryGroupSetRequest;
class QueryGroupSetResponseBody extends $tea.Model {
    static names() {
        return {
            records: 'records',
        };
    }
    static types() {
        return {
            records: { 'type': 'array', 'itemType': QueryGroupSetResponseBodyRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupSetResponseBody = QueryGroupSetResponseBody;
class QueryGroupSetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupSetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupSetResponse = QueryGroupSetResponse;
class QueryInstancesByMultiConditionsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsHeaders = QueryInstancesByMultiConditionsHeaders;
class QueryInstancesByMultiConditionsRequest extends $tea.Model {
    static names() {
        return {
            formCode: 'formCode',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openTeamId: 'openTeamId',
            searchFields: 'searchFields',
            sortFields: 'sortFields',
        };
    }
    static types() {
        return {
            formCode: 'string',
            maxResults: 'number',
            nextToken: 'string',
            openTeamId: 'string',
            searchFields: 'string',
            sortFields: { 'type': 'array', 'itemType': QueryInstancesByMultiConditionsRequestSortFields },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsRequest = QueryInstancesByMultiConditionsRequest;
class QueryInstancesByMultiConditionsResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': QueryInstancesByMultiConditionsResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsResponseBody = QueryInstancesByMultiConditionsResponseBody;
class QueryInstancesByMultiConditionsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInstancesByMultiConditionsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsResponse = QueryInstancesByMultiConditionsResponse;
class QuerySendMsgTaskStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsHeaders = QuerySendMsgTaskStatisticsHeaders;
class QuerySendMsgTaskStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openBatchTaskId: 'openBatchTaskId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openBatchTaskId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsRequest = QuerySendMsgTaskStatisticsRequest;
class QuerySendMsgTaskStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': QuerySendMsgTaskStatisticsResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsResponseBody = QuerySendMsgTaskStatisticsResponseBody;
class QuerySendMsgTaskStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySendMsgTaskStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsResponse = QuerySendMsgTaskStatisticsResponse;
class QuerySendMsgTaskStatisticsDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsDetailHeaders = QuerySendMsgTaskStatisticsDetailHeaders;
class QuerySendMsgTaskStatisticsDetailRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openBatchTaskId: 'openBatchTaskId',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openBatchTaskId: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsDetailRequest = QuerySendMsgTaskStatisticsDetailRequest;
class QuerySendMsgTaskStatisticsDetailResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': QuerySendMsgTaskStatisticsDetailResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsDetailResponseBody = QuerySendMsgTaskStatisticsDetailResponseBody;
class QuerySendMsgTaskStatisticsDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySendMsgTaskStatisticsDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsDetailResponse = QuerySendMsgTaskStatisticsDetailResponse;
class QueryServiceGroupMessageReadStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryServiceGroupMessageReadStatusHeaders = QueryServiceGroupMessageReadStatusHeaders;
class QueryServiceGroupMessageReadStatusRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            openMsgTaskId: 'openMsgTaskId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            openMsgTaskId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryServiceGroupMessageReadStatusRequest = QueryServiceGroupMessageReadStatusRequest;
class QueryServiceGroupMessageReadStatusResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': QueryServiceGroupMessageReadStatusResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryServiceGroupMessageReadStatusResponseBody = QueryServiceGroupMessageReadStatusResponseBody;
class QueryServiceGroupMessageReadStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryServiceGroupMessageReadStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryServiceGroupMessageReadStatusResponse = QueryServiceGroupMessageReadStatusResponse;
class QueueNotifyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueueNotifyHeaders = QueueNotifyHeaders;
class QueueNotifyRequest extends $tea.Model {
    static names() {
        return {
            estimateWaitMin: 'estimateWaitMin',
            openTeamId: 'openTeamId',
            queuePlace: 'queuePlace',
            serviceToken: 'serviceToken',
            targetChannel: 'targetChannel',
            tips: 'tips',
            visitorToken: 'visitorToken',
        };
    }
    static types() {
        return {
            estimateWaitMin: 'number',
            openTeamId: 'string',
            queuePlace: 'number',
            serviceToken: 'string',
            targetChannel: 'string',
            tips: 'string',
            visitorToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueueNotifyRequest = QueueNotifyRequest;
class QueueNotifyResponseBody extends $tea.Model {
    static names() {
        return {
            dingOpenErrcode: 'dingOpenErrcode',
            errorMsg: 'errorMsg',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            dingOpenErrcode: 'number',
            errorMsg: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueueNotifyResponseBody = QueueNotifyResponseBody;
class QueueNotifyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueueNotifyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueueNotifyResponse = QueueNotifyResponse;
class RemoveContactFromOrgHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveContactFromOrgHeaders = RemoveContactFromOrgHeaders;
class RemoveContactFromOrgRequest extends $tea.Model {
    static names() {
        return {
            contactUnionId: 'contactUnionId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            contactUnionId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveContactFromOrgRequest = RemoveContactFromOrgRequest;
class RemoveContactFromOrgResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveContactFromOrgResponseBody = RemoveContactFromOrgResponseBody;
class RemoveContactFromOrgResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveContactFromOrgResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveContactFromOrgResponse = RemoveContactFromOrgResponse;
class ReportCustomerDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerDetailHeaders = ReportCustomerDetailHeaders;
class ReportCustomerDetailRequest extends $tea.Model {
    static names() {
        return {
            hasLogin: 'hasLogin',
            hasOpenConv: 'hasOpenConv',
            maxDt: 'maxDt',
            minDt: 'minDt',
            openConversationId: 'openConversationId',
            openTeamId: 'openTeamId',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            hasLogin: 'boolean',
            hasOpenConv: 'boolean',
            maxDt: 'string',
            minDt: 'string',
            openConversationId: 'string',
            openTeamId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerDetailRequest = ReportCustomerDetailRequest;
class ReportCustomerDetailResponseBody extends $tea.Model {
    static names() {
        return {
            currentPage: 'currentPage',
            pageSize: 'pageSize',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            records: { 'type': 'array', 'itemType': ReportCustomerDetailResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerDetailResponseBody = ReportCustomerDetailResponseBody;
class ReportCustomerDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReportCustomerDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerDetailResponse = ReportCustomerDetailResponse;
class ReportCustomerStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerStatisticsHeaders = ReportCustomerStatisticsHeaders;
class ReportCustomerStatisticsRequest extends $tea.Model {
    static names() {
        return {
            groupOwnerUserIds: 'groupOwnerUserIds',
            groupTags: 'groupTags',
            maxDt: 'maxDt',
            minDt: 'minDt',
            openConversationIds: 'openConversationIds',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            groupOwnerUserIds: { 'type': 'array', 'itemType': 'string' },
            groupTags: { 'type': 'array', 'itemType': 'string' },
            maxDt: 'string',
            minDt: 'string',
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            openGroupSetId: 'string',
            openTeamId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerStatisticsRequest = ReportCustomerStatisticsRequest;
class ReportCustomerStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            currentPage: 'currentPage',
            pageSize: 'pageSize',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            currentPage: 'number',
            pageSize: 'number',
            records: { 'type': 'array', 'itemType': ReportCustomerStatisticsResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerStatisticsResponseBody = ReportCustomerStatisticsResponseBody;
class ReportCustomerStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReportCustomerStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerStatisticsResponse = ReportCustomerStatisticsResponse;
class ResubmitTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketHeaders = ResubmitTicketHeaders;
class ResubmitTicketRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            customFields: 'customFields',
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTemplateBizId: 'openTemplateBizId',
            openTicketId: 'openTicketId',
            processorUnionIds: 'processorUnionIds',
            scene: 'scene',
            sceneContext: 'sceneContext',
            ticketMemo: 'ticketMemo',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            customFields: 'string',
            notify: ResubmitTicketRequestNotify,
            openTeamId: 'string',
            openTemplateBizId: 'string',
            openTicketId: 'string',
            processorUnionIds: { 'type': 'array', 'itemType': 'string' },
            scene: 'string',
            sceneContext: ResubmitTicketRequestSceneContext,
            ticketMemo: ResubmitTicketRequestTicketMemo,
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequest = ResubmitTicketRequest;
class ResubmitTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketResponse = ResubmitTicketResponse;
class RetractTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketHeaders = RetractTicketHeaders;
class RetractTicketRequest extends $tea.Model {
    static names() {
        return {
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            operatorUnionId: 'operatorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            notify: RetractTicketRequestNotify,
            openTeamId: 'string',
            openTicketId: 'string',
            operatorUnionId: 'string',
            ticketMemo: RetractTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketRequest = RetractTicketRequest;
class RetractTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketResponse = RetractTicketResponse;
class RobotMessageRecallHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RobotMessageRecallHeaders = RobotMessageRecallHeaders;
class RobotMessageRecallRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openMsgId: 'openMsgId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openMsgId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RobotMessageRecallRequest = RobotMessageRecallRequest;
class RobotMessageRecallResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RobotMessageRecallResponseBody = RobotMessageRecallResponseBody;
class RobotMessageRecallResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RobotMessageRecallResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RobotMessageRecallResponse = RobotMessageRecallResponse;
class SaveFormInstanceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SaveFormInstanceHeaders = SaveFormInstanceHeaders;
class SaveFormInstanceRequest extends $tea.Model {
    static names() {
        return {
            formDataList: 'formDataList',
            openTeamId: 'openTeamId',
            operatorUnionId: 'operatorUnionId',
            ownerUnionId: 'ownerUnionId',
        };
    }
    static types() {
        return {
            formDataList: 'string',
            openTeamId: 'string',
            operatorUnionId: 'string',
            ownerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SaveFormInstanceRequest = SaveFormInstanceRequest;
class SaveFormInstanceResponseBody extends $tea.Model {
    static names() {
        return {
            openContactId: 'openContactId',
            openCustomerId: 'openCustomerId',
        };
    }
    static types() {
        return {
            openContactId: 'string',
            openCustomerId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SaveFormInstanceResponseBody = SaveFormInstanceResponseBody;
class SaveFormInstanceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveFormInstanceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SaveFormInstanceResponse = SaveFormInstanceResponse;
class SearchGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchGroupHeaders = SearchGroupHeaders;
class SearchGroupRequest extends $tea.Model {
    static names() {
        return {
            groupName: 'groupName',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            searchType: 'searchType',
        };
    }
    static types() {
        return {
            groupName: 'string',
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
            searchType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchGroupRequest = SearchGroupRequest;
class SearchGroupResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            records: 'records',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            records: { 'type': 'array', 'itemType': SearchGroupResponseBodyRecords },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchGroupResponseBody = SearchGroupResponseBody;
class SearchGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchGroupResponse = SearchGroupResponse;
class SendMsgByTaskHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskHeaders = SendMsgByTaskHeaders;
class SendMsgByTaskRequest extends $tea.Model {
    static names() {
        return {
            messageContent: 'messageContent',
            openTeamId: 'openTeamId',
            queryGroup: 'queryGroup',
            sendConfig: 'sendConfig',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            messageContent: SendMsgByTaskRequestMessageContent,
            openTeamId: 'string',
            queryGroup: SendMsgByTaskRequestQueryGroup,
            sendConfig: SendMsgByTaskRequestSendConfig,
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequest = SendMsgByTaskRequest;
class SendMsgByTaskResponseBody extends $tea.Model {
    static names() {
        return {
            openBatchTaskId: 'openBatchTaskId',
        };
    }
    static types() {
        return {
            openBatchTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskResponseBody = SendMsgByTaskResponseBody;
class SendMsgByTaskResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendMsgByTaskResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskResponse = SendMsgByTaskResponse;
class SendMsgByTaskSupportInviteJoinOrgHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgHeaders = SendMsgByTaskSupportInviteJoinOrgHeaders;
class SendMsgByTaskSupportInviteJoinOrgRequest extends $tea.Model {
    static names() {
        return {
            messageContent: 'messageContent',
            mobilePhones: 'mobilePhones',
            needUrlTrack: 'needUrlTrack',
            openTeamId: 'openTeamId',
            sendChannel: 'sendChannel',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            messageContent: SendMsgByTaskSupportInviteJoinOrgRequestMessageContent,
            mobilePhones: { 'type': 'array', 'itemType': 'string' },
            needUrlTrack: 'boolean',
            openTeamId: 'string',
            sendChannel: 'string',
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgRequest = SendMsgByTaskSupportInviteJoinOrgRequest;
class SendMsgByTaskSupportInviteJoinOrgResponseBody extends $tea.Model {
    static names() {
        return {
            openBatchTaskId: 'openBatchTaskId',
        };
    }
    static types() {
        return {
            openBatchTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgResponseBody = SendMsgByTaskSupportInviteJoinOrgResponseBody;
class SendMsgByTaskSupportInviteJoinOrgResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendMsgByTaskSupportInviteJoinOrgResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgResponse = SendMsgByTaskSupportInviteJoinOrgResponse;
class SendServiceGroupMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendServiceGroupMessageHeaders = SendServiceGroupMessageHeaders;
class SendServiceGroupMessageRequest extends $tea.Model {
    static names() {
        return {
            atDingtalkIds: 'atDingtalkIds',
            atMobiles: 'atMobiles',
            atUnionIds: 'atUnionIds',
            btnOrientation: 'btnOrientation',
            btns: 'btns',
            content: 'content',
            hasContentLinks: 'hasContentLinks',
            isAtAll: 'isAtAll',
            messageType: 'messageType',
            receiverDingtalkIds: 'receiverDingtalkIds',
            receiverMobiles: 'receiverMobiles',
            receiverUnionIds: 'receiverUnionIds',
            targetOpenConversationId: 'targetOpenConversationId',
            title: 'title',
        };
    }
    static types() {
        return {
            atDingtalkIds: { 'type': 'array', 'itemType': 'string' },
            atMobiles: { 'type': 'array', 'itemType': 'string' },
            atUnionIds: { 'type': 'array', 'itemType': 'string' },
            btnOrientation: 'string',
            btns: { 'type': 'array', 'itemType': SendServiceGroupMessageRequestBtns },
            content: 'string',
            hasContentLinks: 'boolean',
            isAtAll: 'boolean',
            messageType: 'string',
            receiverDingtalkIds: { 'type': 'array', 'itemType': 'string' },
            receiverMobiles: { 'type': 'array', 'itemType': 'string' },
            receiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            targetOpenConversationId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendServiceGroupMessageRequest = SendServiceGroupMessageRequest;
class SendServiceGroupMessageResponseBody extends $tea.Model {
    static names() {
        return {
            openMsgTaskId: 'openMsgTaskId',
        };
    }
    static types() {
        return {
            openMsgTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendServiceGroupMessageResponseBody = SendServiceGroupMessageResponseBody;
class SendServiceGroupMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendServiceGroupMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendServiceGroupMessageResponse = SendServiceGroupMessageResponse;
class SetRobotConfigHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRobotConfigHeaders = SetRobotConfigHeaders;
class SetRobotConfigRequest extends $tea.Model {
    static names() {
        return {
            dingIsvOrgId: 'dingIsvOrgId',
            dingOrgId: 'dingOrgId',
            dingSuiteKey: 'dingSuiteKey',
            dingTokenGrantType: 'dingTokenGrantType',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            status: 'status',
        };
    }
    static types() {
        return {
            dingIsvOrgId: 'number',
            dingOrgId: 'number',
            dingSuiteKey: 'string',
            dingTokenGrantType: 'number',
            openGroupSetId: 'string',
            openTeamId: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRobotConfigRequest = SetRobotConfigRequest;
class SetRobotConfigResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: SetRobotConfigResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRobotConfigResponseBody = SetRobotConfigResponseBody;
class SetRobotConfigResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRobotConfigResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRobotConfigResponse = SetRobotConfigResponse;
class TakeTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TakeTicketHeaders = TakeTicketHeaders;
class TakeTicketRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            takerUnionId: 'takerUnionId',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            openTicketId: 'string',
            takerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TakeTicketRequest = TakeTicketRequest;
class TakeTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TakeTicketResponse = TakeTicketResponse;
class TopicStatisticsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopicStatisticsHeaders = TopicStatisticsHeaders;
class TopicStatisticsRequest extends $tea.Model {
    static names() {
        return {
            maxDt: 'maxDt',
            minDt: 'minDt',
            openConversationIds: 'openConversationIds',
            openTeamId: 'openTeamId',
            searchContent: 'searchContent',
        };
    }
    static types() {
        return {
            maxDt: 'string',
            minDt: 'string',
            openConversationIds: 'string',
            openTeamId: 'string',
            searchContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopicStatisticsRequest = TopicStatisticsRequest;
class TopicStatisticsResponseBody extends $tea.Model {
    static names() {
        return {
            topicStatisticsRecords: 'topicStatisticsRecords',
        };
    }
    static types() {
        return {
            topicStatisticsRecords: { 'type': 'array', 'itemType': TopicStatisticsResponseBodyTopicStatisticsRecords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopicStatisticsResponseBody = TopicStatisticsResponseBody;
class TopicStatisticsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TopicStatisticsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopicStatisticsResponse = TopicStatisticsResponse;
class TransferTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketHeaders = TransferTicketHeaders;
class TransferTicketRequest extends $tea.Model {
    static names() {
        return {
            notify: 'notify',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            processorUnionId: 'processorUnionId',
            processorUnionIds: 'processorUnionIds',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            notify: TransferTicketRequestNotify,
            openTeamId: 'string',
            openTicketId: 'string',
            processorUnionId: 'string',
            processorUnionIds: { 'type': 'array', 'itemType': 'string' },
            ticketMemo: TransferTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketRequest = TransferTicketRequest;
class TransferTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketResponse = TransferTicketResponse;
class UpdateGroupSetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSetHeaders = UpdateGroupSetHeaders;
class UpdateGroupSetRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSetRequest = UpdateGroupSetRequest;
class UpdateGroupSetResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSetResponseBody = UpdateGroupSetResponseBody;
class UpdateGroupSetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateGroupSetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSetResponse = UpdateGroupSetResponse;
class UpdateGroupTagHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupTagHeaders = UpdateGroupTagHeaders;
class UpdateGroupTagRequest extends $tea.Model {
    static names() {
        return {
            openConversationIds: 'openConversationIds',
            tagNames: 'tagNames',
            updateType: 'updateType',
        };
    }
    static types() {
        return {
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            tagNames: { 'type': 'array', 'itemType': 'string' },
            updateType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupTagRequest = UpdateGroupTagRequest;
class UpdateGroupTagResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupTagResponse = UpdateGroupTagResponse;
class UpdateInstanceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInstanceHeaders = UpdateInstanceHeaders;
class UpdateInstanceRequest extends $tea.Model {
    static names() {
        return {
            externalBizId: 'externalBizId',
            formCode: 'formCode',
            formDataList: 'formDataList',
            openDataInstanceId: 'openDataInstanceId',
            openTeamId: 'openTeamId',
            operatorUnionId: 'operatorUnionId',
            ownerUnionId: 'ownerUnionId',
        };
    }
    static types() {
        return {
            externalBizId: 'string',
            formCode: 'string',
            formDataList: 'string',
            openDataInstanceId: 'string',
            openTeamId: 'string',
            operatorUnionId: 'string',
            ownerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInstanceRequest = UpdateInstanceRequest;
class UpdateInstanceResponseBody extends $tea.Model {
    static names() {
        return {
            openDataInstanceId: 'openDataInstanceId',
        };
    }
    static types() {
        return {
            openDataInstanceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInstanceResponseBody = UpdateInstanceResponseBody;
class UpdateInstanceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateInstanceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInstanceResponse = UpdateInstanceResponse;
class UpdateTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTicketHeaders = UpdateTicketHeaders;
class UpdateTicketRequest extends $tea.Model {
    static names() {
        return {
            customFields: 'customFields',
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            processorUnionId: 'processorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            customFields: 'string',
            openTeamId: 'string',
            openTicketId: 'string',
            processorUnionId: 'string',
            ticketMemo: UpdateTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTicketRequest = UpdateTicketRequest;
class UpdateTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTicketResponse = UpdateTicketResponse;
class UpgradeCloudGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeCloudGroupHeaders = UpgradeCloudGroupHeaders;
class UpgradeCloudGroupRequest extends $tea.Model {
    static names() {
        return {
            ccsInstanceId: 'ccsInstanceId',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            ccsInstanceId: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
            templateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeCloudGroupRequest = UpgradeCloudGroupRequest;
class UpgradeCloudGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeCloudGroupResponse = UpgradeCloudGroupResponse;
class UpgradeNormalGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeNormalGroupHeaders = UpgradeNormalGroupHeaders;
class UpgradeNormalGroupRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
            templateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeNormalGroupRequest = UpgradeNormalGroupRequest;
class UpgradeNormalGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpgradeNormalGroupResponse = UpgradeNormalGroupResponse;
class UrgeTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UrgeTicketHeaders = UrgeTicketHeaders;
class UrgeTicketRequest extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            openTicketId: 'openTicketId',
            operatorUnionId: 'operatorUnionId',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            openTicketId: 'string',
            operatorUnionId: 'string',
            ticketMemo: UrgeTicketRequestTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UrgeTicketRequest = UrgeTicketRequest;
class UrgeTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UrgeTicketResponse = UrgeTicketResponse;
class AddKnowledgeRequestAttachmentList extends $tea.Model {
    static names() {
        return {
            mimeType: 'mime_type',
            path: 'path',
            size: 'size',
            suffix: 'suffix',
            title: 'title',
        };
    }
    static types() {
        return {
            mimeType: 'string',
            path: 'string',
            size: 'number',
            suffix: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddKnowledgeRequestAttachmentList = AddKnowledgeRequestAttachmentList;
class AddOpenCategoryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            id: 'id',
            message: 'message',
            success: 'success',
        };
    }
    static types() {
        return {
            id: 'number',
            message: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenCategoryResponseBodyResult = AddOpenCategoryResponseBodyResult;
class AddOpenKnowledgeRequestAttachments extends $tea.Model {
    static names() {
        return {
            mimeType: 'mimeType',
            path: 'path',
            size: 'size',
            suffix: 'suffix',
            title: 'title',
        };
    }
    static types() {
        return {
            mimeType: 'string',
            path: 'string',
            size: 'number',
            suffix: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeRequestAttachments = AddOpenKnowledgeRequestAttachments;
class AddOpenKnowledgeResponseBodyResult extends $tea.Model {
    static names() {
        return {
            id: 'id',
            message: 'message',
            success: 'success',
        };
    }
    static types() {
        return {
            id: 'number',
            message: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenKnowledgeResponseBodyResult = AddOpenKnowledgeResponseBodyResult;
class AddOpenLibraryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            id: 'id',
            message: 'message',
            success: 'success',
        };
    }
    static types() {
        return {
            id: 'number',
            message: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOpenLibraryResponseBodyResult = AddOpenLibraryResponseBodyResult;
class AddTicketMemoRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTicketMemoRequestTicketMemoAttachments = AddTicketMemoRequestTicketMemoAttachments;
class AddTicketMemoRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': AddTicketMemoRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTicketMemoRequestTicketMemo = AddTicketMemoRequestTicketMemo;
class AssignTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketRequestNotify = AssignTicketRequestNotify;
class AssignTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketRequestTicketMemoAttachments = AssignTicketRequestTicketMemoAttachments;
class AssignTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': AssignTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AssignTicketRequestTicketMemo = AssignTicketRequestTicketMemo;
class BatchBindingGroupBizIdsRequestBindingGroupBizIds extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchBindingGroupBizIdsRequestBindingGroupBizIds = BatchBindingGroupBizIdsRequestBindingGroupBizIds;
class BatchGetGroupSetConfigResponseBodyGroupSetConfigs extends $tea.Model {
    static names() {
        return {
            configKey: 'configKey',
            configValue: 'configValue',
        };
    }
    static types() {
        return {
            configKey: 'string',
            configValue: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetGroupSetConfigResponseBodyGroupSetConfigs = BatchGetGroupSetConfigResponseBodyGroupSetConfigs;
class BatchQueryCustomerSendTaskResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            createName: 'createName',
            createTimeStr: 'createTimeStr',
            createUnionId: 'createUnionId',
            openBatchTaskId: 'openBatchTaskId',
            readCustomerInc: 'readCustomerInc',
            readUserInc: 'readUserInc',
            sendCustomerInc: 'sendCustomerInc',
            sendMessageStatus: 'sendMessageStatus',
            sendTaskTimeStr: 'sendTaskTimeStr',
            sendUserInc: 'sendUserInc',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            createName: 'string',
            createTimeStr: 'string',
            createUnionId: 'string',
            openBatchTaskId: 'string',
            readCustomerInc: 'number',
            readUserInc: 'number',
            sendCustomerInc: 'number',
            sendMessageStatus: 'string',
            sendTaskTimeStr: 'string',
            sendUserInc: 'number',
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryCustomerSendTaskResponseBodyRecords = BatchQueryCustomerSendTaskResponseBodyRecords;
class BatchQueryGroupMemberResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            innerStaff: 'innerStaff',
            nickName: 'nickName',
            owner: 'owner',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            innerStaff: 'boolean',
            nickName: 'string',
            owner: 'boolean',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberResponseBodyRecords = BatchQueryGroupMemberResponseBodyRecords;
class BatchQuerySendMessageTaskResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            createName: 'createName',
            createTimeStr: 'createTimeStr',
            createUnionId: 'createUnionId',
            openBatchTaskId: 'openBatchTaskId',
            readGroupInc: 'readGroupInc',
            sendGroupInc: 'sendGroupInc',
            sendMessageStatus: 'sendMessageStatus',
            sendTaskTimeStr: 'sendTaskTimeStr',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            createName: 'string',
            createTimeStr: 'string',
            createUnionId: 'string',
            openBatchTaskId: 'string',
            readGroupInc: 'number',
            sendGroupInc: 'number',
            sendMessageStatus: 'string',
            sendTaskTimeStr: 'string',
            taskName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQuerySendMessageTaskResponseBodyRecords = BatchQuerySendMessageTaskResponseBodyRecords;
class CancelTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketRequestNotify = CancelTicketRequestNotify;
class CancelTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketRequestTicketMemoAttachments = CancelTicketRequestTicketMemoAttachments;
class CancelTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': CancelTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelTicketRequestTicketMemo = CancelTicketRequestTicketMemo;
class CategoryStatisticsResponseBodyCategoryStatisticsRecords extends $tea.Model {
    static names() {
        return {
            count: 'count',
            lastCount: 'lastCount',
            name: 'name',
        };
    }
    static types() {
        return {
            count: 'number',
            lastCount: 'number',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsResponseBodyCategoryStatisticsRecords = CategoryStatisticsResponseBodyCategoryStatisticsRecords;
class CategoryStatisticsResponseBodyCategoryTrend extends $tea.Model {
    static names() {
        return {
            count: 'count',
            dt: 'dt',
            name: 'name',
        };
    }
    static types() {
        return {
            count: 'number',
            dt: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CategoryStatisticsResponseBodyCategoryTrend = CategoryStatisticsResponseBodyCategoryTrend;
class CreateTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketRequestNotify = CreateTicketRequestNotify;
class CreateTicketRequestSceneContextGroupMsgs extends $tea.Model {
    static names() {
        return {
            anchor: 'anchor',
            openMsgId: 'openMsgId',
        };
    }
    static types() {
        return {
            anchor: 'boolean',
            openMsgId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketRequestSceneContextGroupMsgs = CreateTicketRequestSceneContextGroupMsgs;
class CreateTicketRequestSceneContext extends $tea.Model {
    static names() {
        return {
            groupMsgs: 'groupMsgs',
            openConversationId: 'openConversationId',
            relevantorUnionIds: 'relevantorUnionIds',
            topicId: 'topicId',
        };
    }
    static types() {
        return {
            groupMsgs: { 'type': 'array', 'itemType': CreateTicketRequestSceneContextGroupMsgs },
            openConversationId: 'string',
            relevantorUnionIds: { 'type': 'array', 'itemType': 'string' },
            topicId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateTicketRequestSceneContext = CreateTicketRequestSceneContext;
class CustomerSendMsgTaskRequestMessageContentBtns extends $tea.Model {
    static names() {
        return {
            actionURL: 'actionURL',
            title: 'title',
        };
    }
    static types() {
        return {
            actionURL: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequestMessageContentBtns = CustomerSendMsgTaskRequestMessageContentBtns;
class CustomerSendMsgTaskRequestMessageContent extends $tea.Model {
    static names() {
        return {
            btns: 'btns',
            content: 'content',
            messageType: 'messageType',
            title: 'title',
        };
    }
    static types() {
        return {
            btns: { 'type': 'array', 'itemType': CustomerSendMsgTaskRequestMessageContentBtns },
            content: 'string',
            messageType: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequestMessageContent = CustomerSendMsgTaskRequestMessageContent;
class CustomerSendMsgTaskRequestQueryCustomer extends $tea.Model {
    static names() {
        return {
            openContactIds: 'openContactIds',
            queryType: 'queryType',
            searchContactConditions: 'searchContactConditions',
            searchCustomerConditions: 'searchCustomerConditions',
        };
    }
    static types() {
        return {
            openContactIds: { 'type': 'array', 'itemType': 'string' },
            queryType: 'string',
            searchContactConditions: 'string',
            searchCustomerConditions: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequestQueryCustomer = CustomerSendMsgTaskRequestQueryCustomer;
class CustomerSendMsgTaskRequestSendConfigUrlTrackConfig extends $tea.Model {
    static names() {
        return {
            title: 'title',
            trackId: 'trackId',
            trackUrl: 'trackUrl',
        };
    }
    static types() {
        return {
            title: 'string',
            trackId: 'string',
            trackUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequestSendConfigUrlTrackConfig = CustomerSendMsgTaskRequestSendConfigUrlTrackConfig;
class CustomerSendMsgTaskRequestSendConfig extends $tea.Model {
    static names() {
        return {
            needUrlTrack: 'needUrlTrack',
            sendTime: 'sendTime',
            sendType: 'sendType',
            urlTrackConfig: 'urlTrackConfig',
        };
    }
    static types() {
        return {
            needUrlTrack: 'boolean',
            sendTime: 'string',
            sendType: 'string',
            urlTrackConfig: { 'type': 'array', 'itemType': CustomerSendMsgTaskRequestSendConfigUrlTrackConfig },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CustomerSendMsgTaskRequestSendConfig = CustomerSendMsgTaskRequestSendConfig;
class EmotionStatisticsResponseBodyEmotionStatisticsRecords extends $tea.Model {
    static names() {
        return {
            count: 'count',
            dt: 'dt',
            emotionScore: 'emotionScore',
        };
    }
    static types() {
        return {
            count: 'number',
            dt: 'string',
            emotionScore: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmotionStatisticsResponseBodyEmotionStatisticsRecords = EmotionStatisticsResponseBodyEmotionStatisticsRecords;
class FinishTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketRequestNotify = FinishTicketRequestNotify;
class FinishTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketRequestTicketMemoAttachments = FinishTicketRequestTicketMemoAttachments;
class FinishTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': FinishTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FinishTicketRequestTicketMemo = FinishTicketRequestTicketMemo;
class GetAuthTokenResponseBodyResult extends $tea.Model {
    static names() {
        return {
            authToken: 'authToken',
            channel: 'channel',
            effectiveTime: 'effectiveTime',
            serverId: 'serverId',
            serverName: 'serverName',
        };
    }
    static types() {
        return {
            authToken: 'string',
            channel: 'string',
            effectiveTime: 'number',
            serverId: 'string',
            serverName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthTokenResponseBodyResult = GetAuthTokenResponseBodyResult;
class GetInstancesByIdsResponseBodyCustomFormInstanceResponseList extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            fields: 'fields',
            formCode: 'formCode',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            modifiedUnionId: 'modifiedUnionId',
            openDataInstanceId: 'openDataInstanceId',
            openTeamId: 'openTeamId',
            ownerUnionId: 'ownerUnionId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            fields: 'string',
            formCode: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            modifiedUnionId: 'string',
            openDataInstanceId: 'string',
            openTeamId: 'string',
            ownerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInstancesByIdsResponseBodyCustomFormInstanceResponseList = GetInstancesByIdsResponseBodyCustomFormInstanceResponseList;
class GetNegativeWordCloudResponseBodyWords extends $tea.Model {
    static names() {
        return {
            count: 'count',
            word: 'word',
        };
    }
    static types() {
        return {
            count: 'number',
            word: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNegativeWordCloudResponseBodyWords = GetNegativeWordCloudResponseBodyWords;
class GetTicketResponseBodyCreator extends $tea.Model {
    static names() {
        return {
            nickName: 'nickName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nickName: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponseBodyCreator = GetTicketResponseBodyCreator;
class GetTicketResponseBodyProcessor extends $tea.Model {
    static names() {
        return {
            nickName: 'nickName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nickName: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponseBodyProcessor = GetTicketResponseBodyProcessor;
class GetTicketResponseBodyTakers extends $tea.Model {
    static names() {
        return {
            nickName: 'nickName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nickName: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponseBodyTakers = GetTicketResponseBodyTakers;
class GetTicketResponseBodyTemplate extends $tea.Model {
    static names() {
        return {
            openTemplateBizId: 'openTemplateBizId',
            openTemplateId: 'openTemplateId',
            templateName: 'templateName',
        };
    }
    static types() {
        return {
            openTemplateBizId: 'string',
            openTemplateId: 'string',
            templateName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTicketResponseBodyTemplate = GetTicketResponseBodyTemplate;
class GetWordCloudResponseBodyWords extends $tea.Model {
    static names() {
        return {
            count: 'count',
            word: 'word',
        };
    }
    static types() {
        return {
            count: 'number',
            word: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWordCloudResponseBodyWords = GetWordCloudResponseBodyWords;
class GroupStatisticsResponseBodyGroupTrend extends $tea.Model {
    static names() {
        return {
            count: 'count',
            dt: 'dt',
        };
    }
    static types() {
        return {
            count: 'number',
            dt: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupStatisticsResponseBodyGroupTrend = GroupStatisticsResponseBodyGroupTrend;
class IntentionCategoryStatisticsResponseBodyIntentionCategoryRecords extends $tea.Model {
    static names() {
        return {
            askCount: 'askCount',
            categoryName: 'categoryName',
            dissatisfiedCount: 'dissatisfiedCount',
            errorCount: 'errorCount',
            praiseCount: 'praiseCount',
            suggestCount: 'suggestCount',
        };
    }
    static types() {
        return {
            askCount: 'number',
            categoryName: 'string',
            dissatisfiedCount: 'number',
            errorCount: 'number',
            praiseCount: 'number',
            suggestCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionCategoryStatisticsResponseBodyIntentionCategoryRecords = IntentionCategoryStatisticsResponseBodyIntentionCategoryRecords;
class IntentionStatisticsResponseBodyIntentionStatisticsRecords extends $tea.Model {
    static names() {
        return {
            count: 'count',
            intention: 'intention',
            lastCount: 'lastCount',
        };
    }
    static types() {
        return {
            count: 'number',
            intention: 'string',
            lastCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsResponseBodyIntentionStatisticsRecords = IntentionStatisticsResponseBodyIntentionStatisticsRecords;
class IntentionStatisticsResponseBodyIntentionTrend extends $tea.Model {
    static names() {
        return {
            count: 'count',
            dt: 'dt',
            intention: 'intention',
        };
    }
    static types() {
        return {
            count: 'number',
            dt: 'string',
            intention: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.IntentionStatisticsResponseBodyIntentionTrend = IntentionStatisticsResponseBodyIntentionTrend;
class ListTicketOperateRecordResponseBodyRecordsOperator extends $tea.Model {
    static names() {
        return {
            nickName: 'nickName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nickName: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponseBodyRecordsOperator = ListTicketOperateRecordResponseBodyRecordsOperator;
class ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments = ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments;
class ListTicketOperateRecordResponseBodyRecordsTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': ListTicketOperateRecordResponseBodyRecordsTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponseBodyRecordsTicketMemo = ListTicketOperateRecordResponseBodyRecordsTicketMemo;
class ListTicketOperateRecordResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            openTicketId: 'openTicketId',
            operateData: 'operateData',
            operateTime: 'operateTime',
            operation: 'operation',
            operationDisplayName: 'operationDisplayName',
            operator: 'operator',
            ticketMemo: 'ticketMemo',
        };
    }
    static types() {
        return {
            openTicketId: 'string',
            operateData: 'string',
            operateTime: 'string',
            operation: 'string',
            operationDisplayName: 'string',
            operator: ListTicketOperateRecordResponseBodyRecordsOperator,
            ticketMemo: ListTicketOperateRecordResponseBodyRecordsTicketMemo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTicketOperateRecordResponseBodyRecords = ListTicketOperateRecordResponseBodyRecords;
class ListUserTeamsResponseBodyTeams extends $tea.Model {
    static names() {
        return {
            openTeamId: 'openTeamId',
            teamName: 'teamName',
        };
    }
    static types() {
        return {
            openTeamId: 'string',
            teamName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListUserTeamsResponseBodyTeams = ListUserTeamsResponseBodyTeams;
class QueryActiveUsersResponseBodyActiveUserInfos extends $tea.Model {
    static names() {
        return {
            actionIndexL14d: 'actionIndexL14d',
            actionIndexL30d: 'actionIndexL30d',
            actionIndexL7d: 'actionIndexL7d',
            activeScore: 'activeScore',
            nickName: 'nickName',
            ranking: 'ranking',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            actionIndexL14d: 'number',
            actionIndexL30d: 'number',
            actionIndexL7d: 'number',
            activeScore: 'number',
            nickName: 'string',
            ranking: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryActiveUsersResponseBodyActiveUserInfos = QueryActiveUsersResponseBodyActiveUserInfos;
class QueryCrmGroupContactResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            contactData: 'contactData',
            memberUnionId: 'memberUnionId',
            nickName: 'nickName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            contactData: 'string',
            memberUnionId: 'string',
            nickName: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCrmGroupContactResponseBodyRecords = QueryCrmGroupContactResponseBodyRecords;
class QueryCustomerTaskUserDetailResponseBodyRecordsEventTrackResponses extends $tea.Model {
    static names() {
        return {
            clickTime: 'clickTime',
            eventTrackId: 'eventTrackId',
            onClick: 'onClick',
            title: 'title',
        };
    }
    static types() {
        return {
            clickTime: 'string',
            eventTrackId: 'string',
            onClick: 'boolean',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailResponseBodyRecordsEventTrackResponses = QueryCustomerTaskUserDetailResponseBodyRecordsEventTrackResponses;
class QueryCustomerTaskUserDetailResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            customerNames: 'customerNames',
            errorCode: 'errorCode',
            errorDetail: 'errorDetail',
            eventTrackResponses: 'eventTrackResponses',
            openBatchTaskId: 'openBatchTaskId',
            readStatus: 'readStatus',
            readTime: 'readTime',
            receiverName: 'receiverName',
            receiverUnionId: 'receiverUnionId',
            sendTime: 'sendTime',
            status: 'status',
        };
    }
    static types() {
        return {
            customerNames: 'string',
            errorCode: 'string',
            errorDetail: 'string',
            eventTrackResponses: { 'type': 'array', 'itemType': QueryCustomerTaskUserDetailResponseBodyRecordsEventTrackResponses },
            openBatchTaskId: 'string',
            readStatus: 'number',
            readTime: 'string',
            receiverName: 'string',
            receiverUnionId: 'string',
            sendTime: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomerTaskUserDetailResponseBodyRecords = QueryCustomerTaskUserDetailResponseBodyRecords;
class QueryGroupMemberResponseBodyResultGroupMemberList extends $tea.Model {
    static names() {
        return {
            avatarMediaId: 'avatarMediaId',
            isUser: 'isUser',
            nickName: 'nickName',
            owner: 'owner',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            avatarMediaId: 'string',
            isUser: 'boolean',
            nickName: 'string',
            owner: 'boolean',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponseBodyResultGroupMemberList = QueryGroupMemberResponseBodyResultGroupMemberList;
class QueryGroupMemberResponseBodyResult extends $tea.Model {
    static names() {
        return {
            groupMemberList: 'groupMemberList',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupMemberList: { 'type': 'array', 'itemType': QueryGroupMemberResponseBodyResultGroupMemberList },
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponseBodyResult = QueryGroupMemberResponseBodyResult;
class QueryGroupSetResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            groupSetName: 'groupSetName',
            openGroupSetId: 'openGroupSetId',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtModified: 'string',
            groupSetName: 'string',
            openGroupSetId: 'string',
            templateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupSetResponseBodyRecords = QueryGroupSetResponseBodyRecords;
class QueryInstancesByMultiConditionsRequestSortFields extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            sortBy: 'sortBy',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            sortBy: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsRequestSortFields = QueryInstancesByMultiConditionsRequestSortFields;
class QueryInstancesByMultiConditionsResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            fields: 'fields',
            formCode: 'formCode',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            modifiedUnionId: 'modifiedUnionId',
            openDataInstanceId: 'openDataInstanceId',
            openTeamId: 'openTeamId',
            ownerUnionId: 'ownerUnionId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            fields: 'string',
            formCode: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            modifiedUnionId: 'string',
            openDataInstanceId: 'string',
            openTeamId: 'string',
            ownerUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInstancesByMultiConditionsResponseBodyRecords = QueryInstancesByMultiConditionsResponseBodyRecords;
class QuerySendMsgTaskStatisticsResponseBodyRecordsGroup extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            groupName: 'groupName',
            groupSetName: 'groupSetName',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            groupName: 'string',
            groupSetName: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsResponseBodyRecordsGroup = QuerySendMsgTaskStatisticsResponseBodyRecordsGroup;
class QuerySendMsgTaskStatisticsResponseBodyRecordsGroupUserReadStatistics extends $tea.Model {
    static names() {
        return {
            openBatchTaskId: 'openBatchTaskId',
            openConversationId: 'openConversationId',
            readUserInc: 'readUserInc',
            sendUserInc: 'sendUserInc',
            unReadUserInc: 'unReadUserInc',
        };
    }
    static types() {
        return {
            openBatchTaskId: 'string',
            openConversationId: 'string',
            readUserInc: 'number',
            sendUserInc: 'number',
            unReadUserInc: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsResponseBodyRecordsGroupUserReadStatistics = QuerySendMsgTaskStatisticsResponseBodyRecordsGroupUserReadStatistics;
class QuerySendMsgTaskStatisticsResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            errorDetail: 'errorDetail',
            group: 'group',
            groupUserReadStatistics: 'groupUserReadStatistics',
            openMsgId: 'openMsgId',
            status: 'status',
        };
    }
    static types() {
        return {
            errorDetail: 'string',
            group: QuerySendMsgTaskStatisticsResponseBodyRecordsGroup,
            groupUserReadStatistics: QuerySendMsgTaskStatisticsResponseBodyRecordsGroupUserReadStatistics,
            openMsgId: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsResponseBodyRecords = QuerySendMsgTaskStatisticsResponseBodyRecords;
class QuerySendMsgTaskStatisticsDetailResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            openBatchTaskId: 'openBatchTaskId',
            openConversationId: 'openConversationId',
            readStatus: 'readStatus',
            readTimeStr: 'readTimeStr',
            receiverName: 'receiverName',
            receiverUnionId: 'receiverUnionId',
        };
    }
    static types() {
        return {
            openBatchTaskId: 'string',
            openConversationId: 'string',
            readStatus: 'number',
            readTimeStr: 'string',
            receiverName: 'string',
            receiverUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySendMsgTaskStatisticsDetailResponseBodyRecords = QuerySendMsgTaskStatisticsDetailResponseBodyRecords;
class QueryServiceGroupMessageReadStatusResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            readStatus: 'readStatus',
            readTimeStr: 'readTimeStr',
            receiverDingTalkId: 'receiverDingTalkId',
            receiverName: 'receiverName',
            receiverUnionId: 'receiverUnionId',
            receiverUserId: 'receiverUserId',
            sendTimeStr: 'sendTimeStr',
        };
    }
    static types() {
        return {
            readStatus: 'number',
            readTimeStr: 'string',
            receiverDingTalkId: 'string',
            receiverName: 'string',
            receiverUnionId: 'string',
            receiverUserId: 'string',
            sendTimeStr: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryServiceGroupMessageReadStatusResponseBodyRecords = QueryServiceGroupMessageReadStatusResponseBodyRecords;
class ReportCustomerDetailResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            atRobotCnt: 'atRobotCnt',
            customerName: 'customerName',
            groupName: 'groupName',
            hasLogin: 'hasLogin',
            hasOpenConv: 'hasOpenConv',
            sendMsgCnt: 'sendMsgCnt',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            atRobotCnt: 'number',
            customerName: 'string',
            groupName: 'string',
            hasLogin: 'boolean',
            hasOpenConv: 'boolean',
            sendMsgCnt: 'number',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerDetailResponseBodyRecords = ReportCustomerDetailResponseBodyRecords;
class ReportCustomerStatisticsResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            atRobotCnt: 'atRobotCnt',
            bizId: 'bizId',
            customerCnt: 'customerCnt',
            groupName: 'groupName',
            groupSetName: 'groupSetName',
            loginCnt: 'loginCnt',
            openConvCnt: 'openConvCnt',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            sendMsgCnt: 'sendMsgCnt',
            senderCnt: 'senderCnt',
        };
    }
    static types() {
        return {
            atRobotCnt: 'number',
            bizId: 'string',
            customerCnt: 'number',
            groupName: 'string',
            groupSetName: 'string',
            loginCnt: 'number',
            openConvCnt: 'number',
            openConversationId: 'string',
            openGroupSetId: 'string',
            sendMsgCnt: 'number',
            senderCnt: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReportCustomerStatisticsResponseBodyRecords = ReportCustomerStatisticsResponseBodyRecords;
class ResubmitTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequestNotify = ResubmitTicketRequestNotify;
class ResubmitTicketRequestSceneContextGroupMsgs extends $tea.Model {
    static names() {
        return {
            anchor: 'anchor',
            openMsgId: 'openMsgId',
            topicId: 'topicId',
        };
    }
    static types() {
        return {
            anchor: 'boolean',
            openMsgId: 'string',
            topicId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequestSceneContextGroupMsgs = ResubmitTicketRequestSceneContextGroupMsgs;
class ResubmitTicketRequestSceneContext extends $tea.Model {
    static names() {
        return {
            groupMsgs: 'groupMsgs',
            openConversationId: 'openConversationId',
            relevantorUnionIds: 'relevantorUnionIds',
        };
    }
    static types() {
        return {
            groupMsgs: { 'type': 'array', 'itemType': ResubmitTicketRequestSceneContextGroupMsgs },
            openConversationId: 'string',
            relevantorUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequestSceneContext = ResubmitTicketRequestSceneContext;
class ResubmitTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequestTicketMemoAttachments = ResubmitTicketRequestTicketMemoAttachments;
class ResubmitTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': ResubmitTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ResubmitTicketRequestTicketMemo = ResubmitTicketRequestTicketMemo;
class RetractTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketRequestNotify = RetractTicketRequestNotify;
class RetractTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketRequestTicketMemoAttachments = RetractTicketRequestTicketMemoAttachments;
class RetractTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': RetractTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetractTicketRequestTicketMemo = RetractTicketRequestTicketMemo;
class SearchGroupResponseBodyRecords extends $tea.Model {
    static names() {
        return {
            groupName: 'groupName',
            groupUrl: 'groupUrl',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            openTeamId: 'openTeamId',
        };
    }
    static types() {
        return {
            groupName: 'string',
            groupUrl: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            openTeamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchGroupResponseBodyRecords = SearchGroupResponseBodyRecords;
class SendMsgByTaskRequestMessageContentBtns extends $tea.Model {
    static names() {
        return {
            actionURL: 'actionURL',
            title: 'title',
        };
    }
    static types() {
        return {
            actionURL: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequestMessageContentBtns = SendMsgByTaskRequestMessageContentBtns;
class SendMsgByTaskRequestMessageContent extends $tea.Model {
    static names() {
        return {
            atActiveMemberNum: 'atActiveMemberNum',
            atActiveUser: 'atActiveUser',
            atAll: 'atAll',
            btns: 'btns',
            content: 'content',
            images: 'images',
            messageType: 'messageType',
            remind: 'remind',
            title: 'title',
            top: 'top',
        };
    }
    static types() {
        return {
            atActiveMemberNum: 'number',
            atActiveUser: 'boolean',
            atAll: 'boolean',
            btns: { 'type': 'array', 'itemType': SendMsgByTaskRequestMessageContentBtns },
            content: 'string',
            images: { 'type': 'array', 'itemType': 'string' },
            messageType: 'string',
            remind: 'boolean',
            title: 'string',
            top: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequestMessageContent = SendMsgByTaskRequestMessageContent;
class SendMsgByTaskRequestQueryGroup extends $tea.Model {
    static names() {
        return {
            groupTagNames: 'groupTagNames',
            lastActiveDateFilterType: 'lastActiveDateFilterType',
            lastActiveTimeEnd: 'lastActiveTimeEnd',
            lastActiveTimeStart: 'lastActiveTimeStart',
            openConversationIds: 'openConversationIds',
            openGroupSetId: 'openGroupSetId',
            queryType: 'queryType',
        };
    }
    static types() {
        return {
            groupTagNames: { 'type': 'array', 'itemType': 'string' },
            lastActiveDateFilterType: 'string',
            lastActiveTimeEnd: 'string',
            lastActiveTimeStart: 'string',
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            openGroupSetId: 'string',
            queryType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequestQueryGroup = SendMsgByTaskRequestQueryGroup;
class SendMsgByTaskRequestSendConfigUrlTrackConfig extends $tea.Model {
    static names() {
        return {
            title: 'title',
            trackId: 'trackId',
            trackUrl: 'trackUrl',
        };
    }
    static types() {
        return {
            title: 'string',
            trackId: 'string',
            trackUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequestSendConfigUrlTrackConfig = SendMsgByTaskRequestSendConfigUrlTrackConfig;
class SendMsgByTaskRequestSendConfig extends $tea.Model {
    static names() {
        return {
            needUrlTrack: 'needUrlTrack',
            sendTime: 'sendTime',
            sendType: 'sendType',
            urlTrackConfig: 'urlTrackConfig',
        };
    }
    static types() {
        return {
            needUrlTrack: 'boolean',
            sendTime: 'string',
            sendType: 'string',
            urlTrackConfig: { 'type': 'array', 'itemType': SendMsgByTaskRequestSendConfigUrlTrackConfig },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskRequestSendConfig = SendMsgByTaskRequestSendConfig;
class SendMsgByTaskSupportInviteJoinOrgRequestMessageContentBtns extends $tea.Model {
    static names() {
        return {
            actionURL: 'actionURL',
            title: 'title',
        };
    }
    static types() {
        return {
            actionURL: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgRequestMessageContentBtns = SendMsgByTaskSupportInviteJoinOrgRequestMessageContentBtns;
class SendMsgByTaskSupportInviteJoinOrgRequestMessageContent extends $tea.Model {
    static names() {
        return {
            btns: 'btns',
            content: 'content',
            messageType: 'messageType',
            title: 'title',
        };
    }
    static types() {
        return {
            btns: { 'type': 'array', 'itemType': SendMsgByTaskSupportInviteJoinOrgRequestMessageContentBtns },
            content: 'string',
            messageType: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMsgByTaskSupportInviteJoinOrgRequestMessageContent = SendMsgByTaskSupportInviteJoinOrgRequestMessageContent;
class SendServiceGroupMessageRequestBtns extends $tea.Model {
    static names() {
        return {
            actionURL: 'actionURL',
            title: 'title',
        };
    }
    static types() {
        return {
            actionURL: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendServiceGroupMessageRequestBtns = SendServiceGroupMessageRequestBtns;
class SetRobotConfigResponseBodyResult extends $tea.Model {
    static names() {
        return {
            configKey: 'configKey',
            configValue: 'configValue',
        };
    }
    static types() {
        return {
            configKey: 'string',
            configValue: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRobotConfigResponseBodyResult = SetRobotConfigResponseBodyResult;
class TopicStatisticsResponseBodyTopicStatisticsRecords extends $tea.Model {
    static names() {
        return {
            dt: 'dt',
            msgCount: 'msgCount',
            participantsNum: 'participantsNum',
            topicNum: 'topicNum',
        };
    }
    static types() {
        return {
            dt: 'string',
            msgCount: 'number',
            participantsNum: 'number',
            topicNum: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopicStatisticsResponseBodyTopicStatisticsRecords = TopicStatisticsResponseBodyTopicStatisticsRecords;
class TransferTicketRequestNotify extends $tea.Model {
    static names() {
        return {
            groupNoticeReceiverUnionIds: 'groupNoticeReceiverUnionIds',
            noticeAllGroupMember: 'noticeAllGroupMember',
            workNoticeReceiverUnionIds: 'workNoticeReceiverUnionIds',
        };
    }
    static types() {
        return {
            groupNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
            noticeAllGroupMember: 'boolean',
            workNoticeReceiverUnionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketRequestNotify = TransferTicketRequestNotify;
class TransferTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketRequestTicketMemoAttachments = TransferTicketRequestTicketMemoAttachments;
class TransferTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': TransferTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TransferTicketRequestTicketMemo = TransferTicketRequestTicketMemo;
class UpdateTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTicketRequestTicketMemoAttachments = UpdateTicketRequestTicketMemoAttachments;
class UpdateTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': UpdateTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTicketRequestTicketMemo = UpdateTicketRequestTicketMemo;
class UrgeTicketRequestTicketMemoAttachments extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            key: 'key',
        };
    }
    static types() {
        return {
            fileName: 'string',
            key: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UrgeTicketRequestTicketMemoAttachments = UrgeTicketRequestTicketMemoAttachments;
class UrgeTicketRequestTicketMemo extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            memo: 'memo',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': UrgeTicketRequestTicketMemoAttachments },
            memo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UrgeTicketRequestTicketMemo = UrgeTicketRequestTicketMemo;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request AddContactMemberToGroupRequest
     * @param headers AddContactMemberToGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddContactMemberToGroupResponse
     */
    async addContactMemberToGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fissionType)) {
            body["fissionType"] = request.fissionType;
        }
        if (!tea_util_1.default.isUnset(request.memberUnionId)) {
            body["memberUnionId"] = request.memberUnionId;
        }
        if (!tea_util_1.default.isUnset(request.memberUserId)) {
            body["memberUserId"] = request.memberUserId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddContactMemberToGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/contacts`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddContactMemberToGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddContactMemberToGroupRequest
     * @return AddContactMemberToGroupResponse
     */
    async addContactMemberToGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddContactMemberToGroupHeaders({});
        return await this.addContactMemberToGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddKnowledgeRequest
     * @param headers AddKnowledgeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddKnowledgeResponse
     */
    async addKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attachmentList)) {
            body["attachmentList"] = request.attachmentList;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.effectTimeend)) {
            body["effectTimeend"] = request.effectTimeend;
        }
        if (!tea_util_1.default.isUnset(request.effectTimestart)) {
            body["effectTimestart"] = request.effectTimestart;
        }
        if (!tea_util_1.default.isUnset(request.extTitle)) {
            body["extTitle"] = request.extTitle;
        }
        if (!tea_util_1.default.isUnset(request.keyword)) {
            body["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.libraryKey)) {
            body["libraryKey"] = request.libraryKey;
        }
        if (!tea_util_1.default.isUnset(request.linkUrl)) {
            body["linkUrl"] = request.linkUrl;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.questionIds)) {
            body["questionIds"] = request.questionIds;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.sourcePrimaryKey)) {
            body["sourcePrimaryKey"] = request.sourcePrimaryKey;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.version)) {
            body["version"] = request.version;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddKnowledge",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/knowledges`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddKnowledgeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddKnowledgeRequest
     * @return AddKnowledgeResponse
     */
    async addKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddKnowledgeHeaders({});
        return await this.addKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddLibraryRequest
     * @param headers AddLibraryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddLibraryResponse
     */
    async addLibraryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.openTeamIds)) {
            body["openTeamIds"] = request.openTeamIds;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.sourcePrimaryKey)) {
            body["sourcePrimaryKey"] = request.sourcePrimaryKey;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddLibrary",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/librarys`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddLibraryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddLibraryRequest
     * @return AddLibraryResponse
     */
    async addLibrary(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddLibraryHeaders({});
        return await this.addLibraryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddMemberToServiceGroupRequest
     * @param headers AddMemberToServiceGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddMemberToServiceGroupResponse
     */
    async addMemberToServiceGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddMemberToServiceGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/members`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddMemberToServiceGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddMemberToServiceGroupRequest
     * @return AddMemberToServiceGroupResponse
     */
    async addMemberToServiceGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddMemberToServiceGroupHeaders({});
        return await this.addMemberToServiceGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary OpenApi
     *
     * @param request AddOpenCategoryRequest
     * @param headers AddOpenCategoryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddOpenCategoryResponse
     */
    async addOpenCategoryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.libraryId)) {
            body["libraryId"] = request.libraryId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            body["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.userName)) {
            body["userName"] = request.userName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddOpenCategory",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/openCategories`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddOpenCategoryResponse({}));
    }
    /**
     * @summary OpenApi
     *
     * @param request AddOpenCategoryRequest
     * @return AddOpenCategoryResponse
     */
    async addOpenCategory(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddOpenCategoryHeaders({});
        return await this.addOpenCategoryWithOptions(request, headers, runtime);
    }
    /**
     * @summary OpenApi
     *
     * @param request AddOpenKnowledgeRequest
     * @param headers AddOpenKnowledgeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddOpenKnowledgeResponse
     */
    async addOpenKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attachments)) {
            body["attachments"] = request.attachments;
        }
        if (!tea_util_1.default.isUnset(request.categoryId)) {
            body["categoryId"] = request.categoryId;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.effectTimeend)) {
            body["effectTimeend"] = request.effectTimeend;
        }
        if (!tea_util_1.default.isUnset(request.effectTimestart)) {
            body["effectTimestart"] = request.effectTimestart;
        }
        if (!tea_util_1.default.isUnset(request.extTitle)) {
            body["extTitle"] = request.extTitle;
        }
        if (!tea_util_1.default.isUnset(request.keyword)) {
            body["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.libraryId)) {
            body["libraryId"] = request.libraryId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.userName)) {
            body["userName"] = request.userName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddOpenKnowledge",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/openKnowledges`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddOpenKnowledgeResponse({}));
    }
    /**
     * @summary OpenApi
     *
     * @param request AddOpenKnowledgeRequest
     * @return AddOpenKnowledgeResponse
     */
    async addOpenKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddOpenKnowledgeHeaders({});
        return await this.addOpenKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddOpenLibraryRequest
     * @param headers AddOpenLibraryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddOpenLibraryResponse
     */
    async addOpenLibraryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.userName)) {
            body["userName"] = request.userName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddOpenLibrary",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/openLibraries`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddOpenLibraryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddOpenLibraryRequest
     * @return AddOpenLibraryResponse
     */
    async addOpenLibrary(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddOpenLibraryHeaders({});
        return await this.addOpenLibraryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddTicketMemoRequest
     * @param headers AddTicketMemoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddTicketMemoResponse
     */
    async addTicketMemoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionId)) {
            body["processorUnionId"] = request.processorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddTicketMemo",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/memos`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddTicketMemoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddTicketMemoRequest
     * @return AddTicketMemoResponse
     */
    async addTicketMemo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddTicketMemoHeaders({});
        return await this.addTicketMemoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AssignTicketRequest
     * @param headers AssignTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AssignTicketResponse
     */
    async assignTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionIds)) {
            body["processorUnionIds"] = request.processorUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AssignTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/assign`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AssignTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AssignTicketRequest
     * @return AssignTicketResponse
     */
    async assignTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AssignTicketHeaders({});
        return await this.assignTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary ID
     *
     * @param request BatchBindingGroupBizIdsRequest
     * @param headers BatchBindingGroupBizIdsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchBindingGroupBizIdsResponse
     */
    async batchBindingGroupBizIdsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bindingGroupBizIds)) {
            body["bindingGroupBizIds"] = request.bindingGroupBizIds;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchBindingGroupBizIds",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/bind`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchBindingGroupBizIdsResponse({}));
    }
    /**
     * @summary ID
     *
     * @param request BatchBindingGroupBizIdsRequest
     * @return BatchBindingGroupBizIdsResponse
     */
    async batchBindingGroupBizIds(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchBindingGroupBizIdsHeaders({});
        return await this.batchBindingGroupBizIdsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchGetGroupSetConfigRequest
     * @param headers BatchGetGroupSetConfigHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchGetGroupSetConfigResponse
     */
    async batchGetGroupSetConfigWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.configKeys)) {
            body["configKeys"] = request.configKeys;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetGroupSetConfig",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groupSetConfigs/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchGetGroupSetConfigResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchGetGroupSetConfigRequest
     * @return BatchGetGroupSetConfigResponse
     */
    async batchGetGroupSetConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchGetGroupSetConfigHeaders({});
        return await this.batchGetGroupSetConfigWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchQueryCustomerSendTaskRequest
     * @param headers BatchQueryCustomerSendTaskHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchQueryCustomerSendTaskResponse
     */
    async batchQueryCustomerSendTaskWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.gmtCreateEnd)) {
            body["gmtCreateEnd"] = request.gmtCreateEnd;
        }
        if (!tea_util_1.default.isUnset(request.gmtCreateStart)) {
            body["gmtCreateStart"] = request.gmtCreateStart;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.needRichStatistics)) {
            body["needRichStatistics"] = request.needRichStatistics;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openBatchTaskIds)) {
            body["openBatchTaskIds"] = request.openBatchTaskIds;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryCustomerSendTask",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/tasks/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryCustomerSendTaskResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchQueryCustomerSendTaskRequest
     * @return BatchQueryCustomerSendTaskResponse
     */
    async batchQueryCustomerSendTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryCustomerSendTaskHeaders({});
        return await this.batchQueryCustomerSendTaskWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchQueryGroupMemberRequest
     * @param headers BatchQueryGroupMemberHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchQueryGroupMemberResponse
     */
    async batchQueryGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryGroupMember",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/members/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryGroupMemberResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchQueryGroupMemberRequest
     * @return BatchQueryGroupMemberResponse
     */
    async batchQueryGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryGroupMemberHeaders({});
        return await this.batchQueryGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchQuerySendMessageTaskRequest
     * @param headers BatchQuerySendMessageTaskHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchQuerySendMessageTaskResponse
     */
    async batchQuerySendMessageTaskWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.getReadCount)) {
            body["getReadCount"] = request.getReadCount;
        }
        if (!tea_util_1.default.isUnset(request.gmtCreateEnd)) {
            body["gmtCreateEnd"] = request.gmtCreateEnd;
        }
        if (!tea_util_1.default.isUnset(request.gmtCreateStart)) {
            body["gmtCreateStart"] = request.gmtCreateStart;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQuerySendMessageTask",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tasks/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQuerySendMessageTaskResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchQuerySendMessageTaskRequest
     * @return BatchQuerySendMessageTaskResponse
     */
    async batchQuerySendMessageTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQuerySendMessageTaskHeaders({});
        return await this.batchQuerySendMessageTaskWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BoundTemplateToTeamRequest
     * @param headers BoundTemplateToTeamHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BoundTemplateToTeamResponse
     */
    async boundTemplateToTeamWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.robotConfig)) {
            body["robotConfig"] = request.robotConfig;
        }
        if (!tea_util_1.default.isUnset(request.templateDesc)) {
            body["templateDesc"] = request.templateDesc;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.templateName)) {
            body["templateName"] = request.templateName;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            body["templateType"] = request.templateType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BoundTemplateToTeam",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/teams/templates/bound`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BoundTemplateToTeamResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BoundTemplateToTeamRequest
     * @return BoundTemplateToTeamResponse
     */
    async boundTemplateToTeam(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BoundTemplateToTeamHeaders({});
        return await this.boundTemplateToTeamWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CancelTicketRequest
     * @param headers CancelTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CancelTicketResponse
     */
    async cancelTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CancelTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CancelTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CancelTicketRequest
     * @return CancelTicketResponse
     */
    async cancelTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CancelTicketHeaders({});
        return await this.cancelTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CategoryStatisticsRequest
     * @param headers CategoryStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CategoryStatisticsResponse
     */
    async categoryStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CategoryStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/dashboards/categories/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CategoryStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CategoryStatisticsRequest
     * @return CategoryStatisticsResponse
     */
    async categoryStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CategoryStatisticsHeaders({});
        return await this.categoryStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CloseConversationRequest
     * @param headers CloseConversationHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CloseConversationResponse
     */
    async closeConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serverTips)) {
            body["serverTips"] = request.serverTips;
        }
        if (!tea_util_1.default.isUnset(request.serviceToken)) {
            body["serviceToken"] = request.serviceToken;
        }
        if (!tea_util_1.default.isUnset(request.targetChannel)) {
            body["targetChannel"] = request.targetChannel;
        }
        if (!tea_util_1.default.isUnset(request.visitorToken)) {
            body["visitorToken"] = request.visitorToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CloseConversation",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/conversions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseConversationResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CloseConversationRequest
     * @return CloseConversationResponse
     */
    async closeConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseConversationHeaders({});
        return await this.closeConversationWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CloseHumanSessionRequest
     * @param headers CloseHumanSessionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CloseHumanSessionResponse
     */
    async closeHumanSessionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CloseHumanSession",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/humanSessions/close`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseHumanSessionResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CloseHumanSessionRequest
     * @return CloseHumanSessionResponse
     */
    async closeHumanSession(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseHumanSessionHeaders({});
        return await this.closeHumanSessionWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ConversationCreatedNotifyRequest
     * @param headers ConversationCreatedNotifyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ConversationCreatedNotifyResponse
     */
    async conversationCreatedNotifyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.alipayUserId)) {
            body["alipayUserId"] = request.alipayUserId;
        }
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.nickName)) {
            body["nickName"] = request.nickName;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serverName)) {
            body["serverName"] = request.serverName;
        }
        if (!tea_util_1.default.isUnset(request.serverTips)) {
            body["serverTips"] = request.serverTips;
        }
        if (!tea_util_1.default.isUnset(request.serviceToken)) {
            body["serviceToken"] = request.serviceToken;
        }
        if (!tea_util_1.default.isUnset(request.timeoutRemindTips)) {
            body["timeoutRemindTips"] = request.timeoutRemindTips;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.visitorToken)) {
            body["visitorToken"] = request.visitorToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ConversationCreatedNotify",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ConversationCreatedNotifyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ConversationCreatedNotifyRequest
     * @return ConversationCreatedNotifyResponse
     */
    async conversationCreatedNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConversationCreatedNotifyHeaders({});
        return await this.conversationCreatedNotifyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ConversationTransferBeginNotifyRequest
     * @param headers ConversationTransferBeginNotifyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ConversationTransferBeginNotifyResponse
     */
    async conversationTransferBeginNotifyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.memo)) {
            body["memo"] = request.memo;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serviceToken)) {
            body["serviceToken"] = request.serviceToken;
        }
        if (!tea_util_1.default.isUnset(request.sourceSkillGroupId)) {
            body["sourceSkillGroupId"] = request.sourceSkillGroupId;
        }
        if (!tea_util_1.default.isUnset(request.targetSkillGroupId)) {
            body["targetSkillGroupId"] = request.targetSkillGroupId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ConversationTransferBeginNotify",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/transfers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ConversationTransferBeginNotifyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ConversationTransferBeginNotifyRequest
     * @return ConversationTransferBeginNotifyResponse
     */
    async conversationTransferBeginNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConversationTransferBeginNotifyHeaders({});
        return await this.conversationTransferBeginNotifyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ConversationTransferCompleteNotifyRequest
     * @param headers ConversationTransferCompleteNotifyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ConversationTransferCompleteNotifyResponse
     */
    async conversationTransferCompleteNotifyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.alipayUserId)) {
            body["alipayUserId"] = request.alipayUserId;
        }
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.nickName)) {
            body["nickName"] = request.nickName;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serviceToken)) {
            body["serviceToken"] = request.serviceToken;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.visitorToken)) {
            body["visitorToken"] = request.visitorToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ConversationTransferCompleteNotify",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/completes`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ConversationTransferCompleteNotifyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ConversationTransferCompleteNotifyRequest
     * @return ConversationTransferCompleteNotifyResponse
     */
    async conversationTransferCompleteNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConversationTransferCompleteNotifyHeaders({});
        return await this.conversationTransferCompleteNotifyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateGroupRequest
     * @param headers CreateGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateGroupResponse
     */
    async createGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupBizId)) {
            body["groupBizId"] = request.groupBizId;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupTagNames)) {
            body["groupTagNames"] = request.groupTagNames;
        }
        if (!tea_util_1.default.isUnset(request.memberStaffIds)) {
            body["memberStaffIds"] = request.memberStaffIds;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.ownerStaffId)) {
            body["ownerStaffId"] = request.ownerStaffId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateGroupRequest
     * @return CreateGroupResponse
     */
    async createGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupHeaders({});
        return await this.createGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateGroupConversationRequest
     * @param headers CreateGroupConversationHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateGroupConversationResponse
     */
    async createGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.dingGroupId)) {
            body["dingGroupId"] = request.dingGroupId;
        }
        if (!tea_util_1.default.isUnset(request.dingSuiteKey)) {
            body["dingSuiteKey"] = request.dingSuiteKey;
        }
        if (!tea_util_1.default.isUnset(request.dingTokenGrantType)) {
            body["dingTokenGrantType"] = request.dingTokenGrantType;
        }
        if (!tea_util_1.default.isUnset(request.dingUserId)) {
            body["dingUserId"] = request.dingUserId;
        }
        if (!tea_util_1.default.isUnset(request.dingUserName)) {
            body["dingUserName"] = request.dingUserName;
        }
        if (!tea_util_1.default.isUnset(request.extValues)) {
            body["extValues"] = request.extValues;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serverGroupId)) {
            body["serverGroupId"] = request.serverGroupId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroupConversation",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/create/conversations`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupConversationResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateGroupConversationRequest
     * @return CreateGroupConversationResponse
     */
    async createGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupConversationHeaders({});
        return await this.createGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateGroupSetRequest
     * @param headers CreateGroupSetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateGroupSetResponse
     */
    async createGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupSetName)) {
            body["groupSetName"] = request.groupSetName;
        }
        if (!tea_util_1.default.isUnset(request.groupTemplateId)) {
            body["groupTemplateId"] = request.groupTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroupSet",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groupSets`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupSetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateGroupSetRequest
     * @return CreateGroupSetResponse
     */
    async createGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupSetHeaders({});
        return await this.createGroupSetWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateInstanceRequest
     * @param headers CreateInstanceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateInstanceResponse
     */
    async createInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.externalBizId)) {
            body["externalBizId"] = request.externalBizId;
        }
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.formDataList)) {
            body["formDataList"] = request.formDataList;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ownerUnionId)) {
            body["ownerUnionId"] = request.ownerUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateInstance",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customForms/instances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateInstanceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateInstanceRequest
     * @return CreateInstanceResponse
     */
    async createInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateInstanceHeaders({});
        return await this.createInstanceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateTeamRequest
     * @param headers CreateTeamHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateTeamResponse
     */
    async createTeamWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorDingUnionId)) {
            body["creatorDingUnionId"] = request.creatorDingUnionId;
        }
        if (!tea_util_1.default.isUnset(request.teamName)) {
            body["teamName"] = request.teamName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTeam",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/teams`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateTeamResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateTeamRequest
     * @return CreateTeamResponse
     */
    async createTeam(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTeamHeaders({});
        return await this.createTeamWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateTicketRequest
     * @param headers CreateTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateTicketResponse
     */
    async createTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.customFields)) {
            body["customFields"] = request.customFields;
        }
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTemplateBizId)) {
            body["openTemplateBizId"] = request.openTemplateBizId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionIds)) {
            body["processorUnionIds"] = request.processorUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.scene)) {
            body["scene"] = request.scene;
        }
        if (!tea_util_1.default.isUnset(request.sceneContext)) {
            body["sceneContext"] = request.sceneContext;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateTicketRequest
     * @return CreateTicketResponse
     */
    async createTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTicketHeaders({});
        return await this.createTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CustomerSendMsgTaskRequest
     * @param headers CustomerSendMsgTaskHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CustomerSendMsgTaskResponse
     */
    async customerSendMsgTaskWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            body["messageContent"] = request.messageContent;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.queryCustomer)) {
            body["queryCustomer"] = request.queryCustomer;
        }
        if (!tea_util_1.default.isUnset(request.sendConfig)) {
            body["sendConfig"] = request.sendConfig;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CustomerSendMsgTask",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/tasks/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CustomerSendMsgTaskResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CustomerSendMsgTaskRequest
     * @return CustomerSendMsgTaskResponse
     */
    async customerSendMsgTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CustomerSendMsgTaskHeaders({});
        return await this.customerSendMsgTaskWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteGroupMembersFromGroupRequest
     * @param headers DeleteGroupMembersFromGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteGroupMembersFromGroupResponse
     */
    async deleteGroupMembersFromGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deleteGroupType)) {
            body["deleteGroupType"] = request.deleteGroupType;
        }
        if (!tea_util_1.default.isUnset(request.memberUnionId)) {
            body["memberUnionId"] = request.memberUnionId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteGroupMembersFromGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/members/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteGroupMembersFromGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteGroupMembersFromGroupRequest
     * @return DeleteGroupMembersFromGroupResponse
     */
    async deleteGroupMembersFromGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteGroupMembersFromGroupHeaders({});
        return await this.deleteGroupMembersFromGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteInstanceRequest
     * @param headers DeleteInstanceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteInstanceResponse
     */
    async deleteInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.openDataInstanceId)) {
            body["openDataInstanceId"] = request.openDataInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteInstance",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customForms/instances/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteInstanceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteInstanceRequest
     * @return DeleteInstanceResponse
     */
    async deleteInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteInstanceHeaders({});
        return await this.deleteInstanceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteKnowledgeRequest
     * @param headers DeleteKnowledgeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteKnowledgeResponse
     */
    async deleteKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.libraryKey)) {
            body["libraryKey"] = request.libraryKey;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.sourcePrimaryKey)) {
            body["sourcePrimaryKey"] = request.sourcePrimaryKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteKnowledge",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/knowledges/batchDelete`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteKnowledgeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteKnowledgeRequest
     * @return DeleteKnowledgeResponse
     */
    async deleteKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteKnowledgeHeaders({});
        return await this.deleteKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request EmotionStatisticsRequest
     * @param headers EmotionStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return EmotionStatisticsResponse
     */
    async emotionStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.maxEmotion)) {
            query["maxEmotion"] = request.maxEmotion;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.minEmotion)) {
            query["minEmotion"] = request.minEmotion;
        }
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            query["openConversationIds"] = request.openConversationIds;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            query["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EmotionStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/emotions/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new EmotionStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request EmotionStatisticsRequest
     * @return EmotionStatisticsResponse
     */
    async emotionStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new EmotionStatisticsHeaders({});
        return await this.emotionStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request FinishTicketRequest
     * @param headers FinishTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return FinishTicketResponse
     */
    async finishTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionId)) {
            body["processorUnionId"] = request.processorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "FinishTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/finish`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new FinishTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request FinishTicketRequest
     * @return FinishTicketResponse
     */
    async finishTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FinishTicketHeaders({});
        return await this.finishTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary Token
     *
     * @param request GetAuthTokenRequest
     * @param headers GetAuthTokenHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetAuthTokenResponse
     */
    async getAuthTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.effectiveTime)) {
            body["effectiveTime"] = request.effectiveTime;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.serverId)) {
            body["serverId"] = request.serverId;
        }
        if (!tea_util_1.default.isUnset(request.serverName)) {
            body["serverName"] = request.serverName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetAuthToken",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/get/tokens`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAuthTokenResponse({}));
    }
    /**
     * @summary Token
     *
     * @param request GetAuthTokenRequest
     * @return GetAuthTokenResponse
     */
    async getAuthToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAuthTokenHeaders({});
        return await this.getAuthTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary ID
     *
     * @param request GetInstancesByIdsRequest
     * @param headers GetInstancesByIdsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetInstancesByIdsResponse
     */
    async getInstancesByIdsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.openDataInstanceIdList)) {
            body["openDataInstanceIdList"] = request.openDataInstanceIdList;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetInstancesByIds",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customForms/instances/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetInstancesByIdsResponse({}));
    }
    /**
     * @summary ID
     *
     * @param request GetInstancesByIdsRequest
     * @return GetInstancesByIdsResponse
     */
    async getInstancesByIds(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetInstancesByIdsHeaders({});
        return await this.getInstancesByIdsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetNegativeWordCloudRequest
     * @param headers GetNegativeWordCloudHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetNegativeWordCloudResponse
     */
    async getNegativeWordCloudWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetNegativeWordCloud",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/negatives/wordClouds`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetNegativeWordCloudResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetNegativeWordCloudRequest
     * @return GetNegativeWordCloudResponse
     */
    async getNegativeWordCloud(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetNegativeWordCloudHeaders({});
        return await this.getNegativeWordCloudWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetOssTempUrlRequest
     * @param headers GetOssTempUrlHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetOssTempUrlResponse
     */
    async getOssTempUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.fetchMode)) {
            query["fetchMode"] = request.fetchMode;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.key)) {
            query["key"] = request.key;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOssTempUrl",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/ossServices/tempUrls`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOssTempUrlResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetOssTempUrlRequest
     * @return GetOssTempUrlResponse
     */
    async getOssTempUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOssTempUrlHeaders({});
        return await this.getOssTempUrlWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetStoragePolicyRequest
     * @param headers GetStoragePolicyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetStoragePolicyResponse
     */
    async getStoragePolicyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSize)) {
            body["fileSize"] = request.fileSize;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetStoragePolicy",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/ossServices/policies`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetStoragePolicyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetStoragePolicyRequest
     * @return GetStoragePolicyResponse
     */
    async getStoragePolicy(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetStoragePolicyHeaders({});
        return await this.getStoragePolicyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetTicketRequest
     * @param headers GetTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetTicketResponse
     */
    async getTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            query["openTicketId"] = request.openTicketId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetTicketRequest
     * @return GetTicketResponse
     */
    async getTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTicketHeaders({});
        return await this.getTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetWordCloudRequest
     * @param headers GetWordCloudHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWordCloudResponse
     */
    async getWordCloudWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetWordCloud",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/wordClouds`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWordCloudResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetWordCloudRequest
     * @return GetWordCloudResponse
     */
    async getWordCloud(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWordCloudHeaders({});
        return await this.getWordCloudWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GroupStatisticsRequest
     * @param headers GroupStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GroupStatisticsResponse
     */
    async groupStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GroupStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/dashboards/groups/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GroupStatisticsRequest
     * @return GroupStatisticsResponse
     */
    async groupStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupStatisticsHeaders({});
        return await this.groupStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary &
     *
     * @param request IntentionCategoryStatisticsRequest
     * @param headers IntentionCategoryStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return IntentionCategoryStatisticsResponse
     */
    async intentionCategoryStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "IntentionCategoryStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/dashboards/intentionCategories/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new IntentionCategoryStatisticsResponse({}));
    }
    /**
     * @summary &
     *
     * @param request IntentionCategoryStatisticsRequest
     * @return IntentionCategoryStatisticsResponse
     */
    async intentionCategoryStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new IntentionCategoryStatisticsHeaders({});
        return await this.intentionCategoryStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request IntentionStatisticsRequest
     * @param headers IntentionStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return IntentionStatisticsResponse
     */
    async intentionStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "IntentionStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/dashboards/intentions/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new IntentionStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request IntentionStatisticsRequest
     * @return IntentionStatisticsResponse
     */
    async intentionStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new IntentionStatisticsHeaders({});
        return await this.intentionStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListTicketOperateRecordRequest
     * @param headers ListTicketOperateRecordHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListTicketOperateRecordResponse
     */
    async listTicketOperateRecordWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            query["openTicketId"] = request.openTicketId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTicketOperateRecord",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/operateRecords`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListTicketOperateRecordResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListTicketOperateRecordRequest
     * @return ListTicketOperateRecordResponse
     */
    async listTicketOperateRecord(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTicketOperateRecordHeaders({});
        return await this.listTicketOperateRecordWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers ListUserTeamsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListUserTeamsResponse
     */
    async listUserTeamsWithOptions(userId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ListUserTeams",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/users/${userId}/teams`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListUserTeamsResponse({}));
    }
    /**
     * @summary 
     *
     * @return ListUserTeamsResponse
     */
    async listUserTeams(userId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListUserTeamsHeaders({});
        return await this.listUserTeamsWithOptions(userId, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryActiveUsersRequest
     * @param headers QueryActiveUsersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryActiveUsersResponse
     */
    async queryActiveUsersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.topN)) {
            query["topN"] = request.topN;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryActiveUsers",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/queryActiveUsers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryActiveUsersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryActiveUsersRequest
     * @return QueryActiveUsersResponse
     */
    async queryActiveUsers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryActiveUsersHeaders({});
        return await this.queryActiveUsersWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCrmGroupContactRequest
     * @param headers QueryCrmGroupContactHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCrmGroupContactResponse
     */
    async queryCrmGroupContactWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.minResult)) {
            body["minResult"] = request.minResult;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.searchFields)) {
            body["searchFields"] = request.searchFields;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryCrmGroupContact",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/contacts/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCrmGroupContactResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCrmGroupContactRequest
     * @return QueryCrmGroupContactResponse
     */
    async queryCrmGroupContact(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCrmGroupContactHeaders({});
        return await this.queryCrmGroupContactWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCustomerCardRequest
     * @param headers QueryCustomerCardHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCustomerCardResponse
     */
    async queryCustomerCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.jsonParams)) {
            body["jsonParams"] = request.jsonParams;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryCustomerCard",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/userDetials`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCustomerCardResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCustomerCardRequest
     * @return QueryCustomerCardResponse
     */
    async queryCustomerCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCustomerCardHeaders({});
        return await this.queryCustomerCardWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCustomerTaskUserDetailRequest
     * @param headers QueryCustomerTaskUserDetailHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCustomerTaskUserDetailResponse
     */
    async queryCustomerTaskUserDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openBatchTaskId)) {
            body["openBatchTaskId"] = request.openBatchTaskId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUnionIds)) {
            body["receiverUnionIds"] = request.receiverUnionIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryCustomerTaskUserDetail",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/tasks/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCustomerTaskUserDetailResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCustomerTaskUserDetailRequest
     * @return QueryCustomerTaskUserDetailResponse
     */
    async queryCustomerTaskUserDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCustomerTaskUserDetailHeaders({});
        return await this.queryCustomerTaskUserDetailWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryGroupRequest
     * @param headers QueryGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryGroupResponse
     */
    async queryGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryGroupRequest
     * @return QueryGroupResponse
     */
    async queryGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupHeaders({});
        return await this.queryGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryGroupMemberRequest
     * @param headers QueryGroupMemberHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryGroupMemberResponse
     */
    async queryGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.targetCorpId)) {
            body["targetCorpId"] = request.targetCorpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupMember",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/members/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupMemberResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryGroupMemberRequest
     * @return QueryGroupMemberResponse
     */
    async queryGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupMemberHeaders({});
        return await this.queryGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryGroupSetRequest
     * @param headers QueryGroupSetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryGroupSetResponse
     */
    async queryGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupSet",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groupSets`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupSetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryGroupSetRequest
     * @return QueryGroupSetResponse
     */
    async queryGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupSetHeaders({});
        return await this.queryGroupSetWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryInstancesByMultiConditionsRequest
     * @param headers QueryInstancesByMultiConditionsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryInstancesByMultiConditionsResponse
     */
    async queryInstancesByMultiConditionsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.searchFields)) {
            body["searchFields"] = request.searchFields;
        }
        if (!tea_util_1.default.isUnset(request.sortFields)) {
            body["sortFields"] = request.sortFields;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryInstancesByMultiConditions",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customForms/instances/multiConditions/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryInstancesByMultiConditionsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryInstancesByMultiConditionsRequest
     * @return QueryInstancesByMultiConditionsResponse
     */
    async queryInstancesByMultiConditions(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryInstancesByMultiConditionsHeaders({});
        return await this.queryInstancesByMultiConditionsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QuerySendMsgTaskStatisticsRequest
     * @param headers QuerySendMsgTaskStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QuerySendMsgTaskStatisticsResponse
     */
    async querySendMsgTaskStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openBatchTaskId)) {
            body["openBatchTaskId"] = request.openBatchTaskId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySendMsgTaskStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tasks/statistics/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QuerySendMsgTaskStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QuerySendMsgTaskStatisticsRequest
     * @return QuerySendMsgTaskStatisticsResponse
     */
    async querySendMsgTaskStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySendMsgTaskStatisticsHeaders({});
        return await this.querySendMsgTaskStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QuerySendMsgTaskStatisticsDetailRequest
     * @param headers QuerySendMsgTaskStatisticsDetailHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QuerySendMsgTaskStatisticsDetailResponse
     */
    async querySendMsgTaskStatisticsDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openBatchTaskId)) {
            body["openBatchTaskId"] = request.openBatchTaskId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySendMsgTaskStatisticsDetail",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tasks/statistics/details/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QuerySendMsgTaskStatisticsDetailResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QuerySendMsgTaskStatisticsDetailRequest
     * @return QuerySendMsgTaskStatisticsDetailResponse
     */
    async querySendMsgTaskStatisticsDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySendMsgTaskStatisticsDetailHeaders({});
        return await this.querySendMsgTaskStatisticsDetailWithOptions(request, headers, runtime);
    }
    /**
     * @summary /
     *
     * @param request QueryServiceGroupMessageReadStatusRequest
     * @param headers QueryServiceGroupMessageReadStatusHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryServiceGroupMessageReadStatusResponse
     */
    async queryServiceGroupMessageReadStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openMsgTaskId)) {
            body["openMsgTaskId"] = request.openMsgTaskId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryServiceGroupMessageReadStatus",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/messages/readStatus/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryServiceGroupMessageReadStatusResponse({}));
    }
    /**
     * @summary /
     *
     * @param request QueryServiceGroupMessageReadStatusRequest
     * @return QueryServiceGroupMessageReadStatusResponse
     */
    async queryServiceGroupMessageReadStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryServiceGroupMessageReadStatusHeaders({});
        return await this.queryServiceGroupMessageReadStatusWithOptions(request, headers, runtime);
    }
    /**
     * @summary DT
     *
     * @param request QueueNotifyRequest
     * @param headers QueueNotifyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueueNotifyResponse
     */
    async queueNotifyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.estimateWaitMin)) {
            body["estimateWaitMin"] = request.estimateWaitMin;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.queuePlace)) {
            body["queuePlace"] = request.queuePlace;
        }
        if (!tea_util_1.default.isUnset(request.serviceToken)) {
            body["serviceToken"] = request.serviceToken;
        }
        if (!tea_util_1.default.isUnset(request.targetChannel)) {
            body["targetChannel"] = request.targetChannel;
        }
        if (!tea_util_1.default.isUnset(request.tips)) {
            body["tips"] = request.tips;
        }
        if (!tea_util_1.default.isUnset(request.visitorToken)) {
            body["visitorToken"] = request.visitorToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueueNotify",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/dts`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueueNotifyResponse({}));
    }
    /**
     * @summary DT
     *
     * @param request QueueNotifyRequest
     * @return QueueNotifyResponse
     */
    async queueNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueueNotifyHeaders({});
        return await this.queueNotifyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RemoveContactFromOrgRequest
     * @param headers RemoveContactFromOrgHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RemoveContactFromOrgResponse
     */
    async removeContactFromOrgWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.contactUnionId)) {
            body["contactUnionId"] = request.contactUnionId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RemoveContactFromOrg",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/organizations/contacts/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RemoveContactFromOrgResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RemoveContactFromOrgRequest
     * @return RemoveContactFromOrgResponse
     */
    async removeContactFromOrg(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveContactFromOrgHeaders({});
        return await this.removeContactFromOrgWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ReportCustomerDetailRequest
     * @param headers ReportCustomerDetailHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ReportCustomerDetailResponse
     */
    async reportCustomerDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.hasLogin)) {
            body["hasLogin"] = request.hasLogin;
        }
        if (!tea_util_1.default.isUnset(request.hasOpenConv)) {
            body["hasOpenConv"] = request.hasOpenConv;
        }
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            body["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            body["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            body["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReportCustomerDetail",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/activities/details/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReportCustomerDetailResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ReportCustomerDetailRequest
     * @return ReportCustomerDetailResponse
     */
    async reportCustomerDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReportCustomerDetailHeaders({});
        return await this.reportCustomerDetailWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ReportCustomerStatisticsRequest
     * @param headers ReportCustomerStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ReportCustomerStatisticsResponse
     */
    async reportCustomerStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupOwnerUserIds)) {
            body["groupOwnerUserIds"] = request.groupOwnerUserIds;
        }
        if (!tea_util_1.default.isUnset(request.groupTags)) {
            body["groupTags"] = request.groupTags;
        }
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            body["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            body["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            body["openConversationIds"] = request.openConversationIds;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            body["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReportCustomerStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/activities/statistics/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReportCustomerStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ReportCustomerStatisticsRequest
     * @return ReportCustomerStatisticsResponse
     */
    async reportCustomerStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReportCustomerStatisticsHeaders({});
        return await this.reportCustomerStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ResubmitTicketRequest
     * @param headers ResubmitTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ResubmitTicketResponse
     */
    async resubmitTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.customFields)) {
            body["customFields"] = request.customFields;
        }
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTemplateBizId)) {
            body["openTemplateBizId"] = request.openTemplateBizId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionIds)) {
            body["processorUnionIds"] = request.processorUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.scene)) {
            body["scene"] = request.scene;
        }
        if (!tea_util_1.default.isUnset(request.sceneContext)) {
            body["sceneContext"] = request.sceneContext;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ResubmitTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/resubmit`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ResubmitTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ResubmitTicketRequest
     * @return ResubmitTicketResponse
     */
    async resubmitTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ResubmitTicketHeaders({});
        return await this.resubmitTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RetractTicketRequest
     * @param headers RetractTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RetractTicketResponse
     */
    async retractTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RetractTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/retract`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetractTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RetractTicketRequest
     * @return RetractTicketResponse
     */
    async retractTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetractTicketHeaders({});
        return await this.retractTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RobotMessageRecallRequest
     * @param headers RobotMessageRecallHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RobotMessageRecallResponse
     */
    async robotMessageRecallWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openMsgId)) {
            body["openMsgId"] = request.openMsgId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RobotMessageRecall",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/robots/messages/recall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RobotMessageRecallResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RobotMessageRecallRequest
     * @return RobotMessageRecallResponse
     */
    async robotMessageRecall(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RobotMessageRecallHeaders({});
        return await this.robotMessageRecallWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SaveFormInstanceRequest
     * @param headers SaveFormInstanceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SaveFormInstanceResponse
     */
    async saveFormInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.formDataList)) {
            body["formDataList"] = request.formDataList;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ownerUnionId)) {
            body["ownerUnionId"] = request.ownerUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SaveFormInstance",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/forms/instances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SaveFormInstanceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SaveFormInstanceRequest
     * @return SaveFormInstanceResponse
     */
    async saveFormInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SaveFormInstanceHeaders({});
        return await this.saveFormInstanceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SearchGroupRequest
     * @param headers SearchGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SearchGroupResponse
     */
    async searchGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.searchType)) {
            body["searchType"] = request.searchType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SearchGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SearchGroupRequest
     * @return SearchGroupResponse
     */
    async searchGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchGroupHeaders({});
        return await this.searchGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendMsgByTaskRequest
     * @param headers SendMsgByTaskHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendMsgByTaskResponse
     */
    async sendMsgByTaskWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            body["messageContent"] = request.messageContent;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.queryGroup)) {
            body["queryGroup"] = request.queryGroup;
        }
        if (!tea_util_1.default.isUnset(request.sendConfig)) {
            body["sendConfig"] = request.sendConfig;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendMsgByTask",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/messages/tasks/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendMsgByTaskResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendMsgByTaskRequest
     * @return SendMsgByTaskResponse
     */
    async sendMsgByTask(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendMsgByTaskHeaders({});
        return await this.sendMsgByTaskWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendMsgByTaskSupportInviteJoinOrgRequest
     * @param headers SendMsgByTaskSupportInviteJoinOrgHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendMsgByTaskSupportInviteJoinOrgResponse
     */
    async sendMsgByTaskSupportInviteJoinOrgWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageContent)) {
            body["messageContent"] = request.messageContent;
        }
        if (!tea_util_1.default.isUnset(request.mobilePhones)) {
            body["mobilePhones"] = request.mobilePhones;
        }
        if (!tea_util_1.default.isUnset(request.needUrlTrack)) {
            body["needUrlTrack"] = request.needUrlTrack;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.sendChannel)) {
            body["sendChannel"] = request.sendChannel;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendMsgByTaskSupportInviteJoinOrg",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customers/tasks/groupSend`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendMsgByTaskSupportInviteJoinOrgResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendMsgByTaskSupportInviteJoinOrgRequest
     * @return SendMsgByTaskSupportInviteJoinOrgResponse
     */
    async sendMsgByTaskSupportInviteJoinOrg(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendMsgByTaskSupportInviteJoinOrgHeaders({});
        return await this.sendMsgByTaskSupportInviteJoinOrgWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendServiceGroupMessageRequest
     * @param headers SendServiceGroupMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendServiceGroupMessageResponse
     */
    async sendServiceGroupMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.atDingtalkIds)) {
            body["atDingtalkIds"] = request.atDingtalkIds;
        }
        if (!tea_util_1.default.isUnset(request.atMobiles)) {
            body["atMobiles"] = request.atMobiles;
        }
        if (!tea_util_1.default.isUnset(request.atUnionIds)) {
            body["atUnionIds"] = request.atUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.btnOrientation)) {
            body["btnOrientation"] = request.btnOrientation;
        }
        if (!tea_util_1.default.isUnset(request.btns)) {
            body["btns"] = request.btns;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.hasContentLinks)) {
            body["hasContentLinks"] = request.hasContentLinks;
        }
        if (!tea_util_1.default.isUnset(request.isAtAll)) {
            body["isAtAll"] = request.isAtAll;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.receiverDingtalkIds)) {
            body["receiverDingtalkIds"] = request.receiverDingtalkIds;
        }
        if (!tea_util_1.default.isUnset(request.receiverMobiles)) {
            body["receiverMobiles"] = request.receiverMobiles;
        }
        if (!tea_util_1.default.isUnset(request.receiverUnionIds)) {
            body["receiverUnionIds"] = request.receiverUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.targetOpenConversationId)) {
            body["targetOpenConversationId"] = request.targetOpenConversationId;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendServiceGroupMessage",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/messages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendServiceGroupMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendServiceGroupMessageRequest
     * @return SendServiceGroupMessageResponse
     */
    async sendServiceGroupMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendServiceGroupMessageHeaders({});
        return await this.sendServiceGroupMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetRobotConfigRequest
     * @param headers SetRobotConfigHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetRobotConfigResponse
     */
    async setRobotConfigWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dingIsvOrgId)) {
            body["dingIsvOrgId"] = request.dingIsvOrgId;
        }
        if (!tea_util_1.default.isUnset(request.dingOrgId)) {
            body["dingOrgId"] = request.dingOrgId;
        }
        if (!tea_util_1.default.isUnset(request.dingSuiteKey)) {
            body["dingSuiteKey"] = request.dingSuiteKey;
        }
        if (!tea_util_1.default.isUnset(request.dingTokenGrantType)) {
            body["dingTokenGrantType"] = request.dingTokenGrantType;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetRobotConfig",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/configs/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetRobotConfigResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetRobotConfigRequest
     * @return SetRobotConfigResponse
     */
    async setRobotConfig(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetRobotConfigHeaders({});
        return await this.setRobotConfigWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request TakeTicketRequest
     * @param headers TakeTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return TakeTicketResponse
     */
    async takeTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.takerUnionId)) {
            body["takerUnionId"] = request.takerUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TakeTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/apply`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TakeTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request TakeTicketRequest
     * @return TakeTicketResponse
     */
    async takeTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TakeTicketHeaders({});
        return await this.takeTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request TopicStatisticsRequest
     * @param headers TopicStatisticsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return TopicStatisticsResponse
     */
    async topicStatisticsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxDt)) {
            query["maxDt"] = request.maxDt;
        }
        if (!tea_util_1.default.isUnset(request.minDt)) {
            query["minDt"] = request.minDt;
        }
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            query["openConversationIds"] = request.openConversationIds;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            query["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.searchContent)) {
            query["searchContent"] = request.searchContent;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "TopicStatistics",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/voices/topics/statistics`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TopicStatisticsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request TopicStatisticsRequest
     * @return TopicStatisticsResponse
     */
    async topicStatistics(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TopicStatisticsHeaders({});
        return await this.topicStatisticsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request TransferTicketRequest
     * @param headers TransferTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return TransferTicketResponse
     */
    async transferTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionId)) {
            body["processorUnionId"] = request.processorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionIds)) {
            body["processorUnionIds"] = request.processorUnionIds;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TransferTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/transfer`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TransferTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request TransferTicketRequest
     * @return TransferTicketResponse
     */
    async transferTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TransferTicketHeaders({});
        return await this.transferTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateGroupSetRequest
     * @param headers UpdateGroupSetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateGroupSetResponse
     */
    async updateGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupSet",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/groups/configurations`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupSetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateGroupSetRequest
     * @return UpdateGroupSetResponse
     */
    async updateGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupSetHeaders({});
        return await this.updateGroupSetWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateGroupTagRequest
     * @param headers UpdateGroupTagHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateGroupTagResponse
     */
    async updateGroupTagWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            body["openConversationIds"] = request.openConversationIds;
        }
        if (!tea_util_1.default.isUnset(request.tagNames)) {
            body["tagNames"] = request.tagNames;
        }
        if (!tea_util_1.default.isUnset(request.updateType)) {
            body["updateType"] = request.updateType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupTag",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tags`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupTagResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateGroupTagRequest
     * @return UpdateGroupTagResponse
     */
    async updateGroupTag(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupTagHeaders({});
        return await this.updateGroupTagWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateInstanceRequest
     * @param headers UpdateInstanceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateInstanceResponse
     */
    async updateInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.externalBizId)) {
            body["externalBizId"] = request.externalBizId;
        }
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.formDataList)) {
            body["formDataList"] = request.formDataList;
        }
        if (!tea_util_1.default.isUnset(request.openDataInstanceId)) {
            body["openDataInstanceId"] = request.openDataInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ownerUnionId)) {
            body["ownerUnionId"] = request.ownerUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateInstance",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/customForms/instances`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateInstanceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateInstanceRequest
     * @return UpdateInstanceResponse
     */
    async updateInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInstanceHeaders({});
        return await this.updateInstanceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateTicketRequest
     * @param headers UpdateTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateTicketResponse
     */
    async updateTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.customFields)) {
            body["customFields"] = request.customFields;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.processorUnionId)) {
            body["processorUnionId"] = request.processorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateTicketRequest
     * @return UpdateTicketResponse
     */
    async updateTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTicketHeaders({});
        return await this.updateTicketWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpgradeCloudGroupRequest
     * @param headers UpgradeCloudGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpgradeCloudGroupResponse
     */
    async upgradeCloudGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.ccsInstanceId)) {
            body["ccsInstanceId"] = request.ccsInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeCloudGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/cloudGroups/upgrade`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpgradeCloudGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpgradeCloudGroupRequest
     * @return UpgradeCloudGroupResponse
     */
    async upgradeCloudGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpgradeCloudGroupHeaders({});
        return await this.upgradeCloudGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpgradeNormalGroupRequest
     * @param headers UpgradeNormalGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpgradeNormalGroupResponse
     */
    async upgradeNormalGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeNormalGroup",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/normalGroups/upgrade`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpgradeNormalGroupResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpgradeNormalGroupRequest
     * @return UpgradeNormalGroupResponse
     */
    async upgradeNormalGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpgradeNormalGroupHeaders({});
        return await this.upgradeNormalGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UrgeTicketRequest
     * @param headers UrgeTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UrgeTicketResponse
     */
    async urgeTicketWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openTeamId)) {
            body["openTeamId"] = request.openTeamId;
        }
        if (!tea_util_1.default.isUnset(request.openTicketId)) {
            body["openTicketId"] = request.openTicketId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.ticketMemo)) {
            body["ticketMemo"] = request.ticketMemo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UrgeTicket",
            version: "serviceGroup_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/serviceGroup/tickets/urge`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UrgeTicketResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UrgeTicketRequest
     * @return UrgeTicketResponse
     */
    async urgeTicket(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UrgeTicketHeaders({});
        return await this.urgeTicketWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map