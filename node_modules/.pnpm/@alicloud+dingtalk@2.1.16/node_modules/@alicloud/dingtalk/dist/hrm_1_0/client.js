"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HrmProcessUpdateTerminationInfoRequest = exports.HrmProcessUpdateTerminationInfoHeaders = exports.HrmProcessTransferResponse = exports.HrmProcessTransferResponseBody = exports.HrmProcessTransferRequest = exports.HrmProcessTransferHeaders = exports.HrmProcessRegularResponse = exports.HrmProcessRegularResponseBody = exports.HrmProcessRegularRequest = exports.HrmProcessRegularHeaders = exports.HrmMokaOapiResponse = exports.HrmMokaOapiResponseBody = exports.HrmMokaOapiRequest = exports.HrmMokaOapiHeaders = exports.HrmMokaEventResponse = exports.HrmMokaEventResponseBody = exports.HrmMokaEventRequest = exports.HrmMokaEventHeaders = exports.HrmMailSendResponse = exports.HrmMailSendResponseBody = exports.HrmMailSendRequest = exports.HrmMailSendHeaders = exports.HrmBenefitQueryResponse = exports.HrmBenefitQueryResponseBody = exports.HrmBenefitQueryRequest = exports.HrmBenefitQueryHeaders = exports.GetEmployeeRosterByFieldResponse = exports.GetEmployeeRosterByFieldResponseBody = exports.GetEmployeeRosterByFieldRequest = exports.GetEmployeeRosterByFieldHeaders = exports.EsignRollbackResponse = exports.EsignRollbackResponseBody = exports.EsignRollbackRequest = exports.EsignRollbackHeaders = exports.EmployeeAttachmentUpdateResponse = exports.EmployeeAttachmentUpdateResponseBody = exports.EmployeeAttachmentUpdateRequest = exports.EmployeeAttachmentUpdateHeaders = exports.ECertQueryResponse = exports.ECertQueryResponseBody = exports.ECertQueryRequest = exports.ECertQueryHeaders = exports.DeviceMarketOrderManagerResponse = exports.DeviceMarketOrderManagerResponseBody = exports.DeviceMarketManagerResponse = exports.DeviceMarketManagerResponseBody = exports.AddHrmPreentryResponse = exports.AddHrmPreentryResponseBody = exports.AddHrmPreentryRequest = exports.AddHrmPreentryHeaders = void 0;
exports.QueryPositionsResponseBody = exports.QueryPositionsRequest = exports.QueryPositionsHeaders = exports.QueryJobsResponse = exports.QueryJobsResponseBody = exports.QueryJobsRequest = exports.QueryJobsHeaders = exports.QueryJobRanksResponse = exports.QueryJobRanksResponseBody = exports.QueryJobRanksRequest = exports.QueryJobRanksHeaders = exports.QueryHrmEmployeeDismissionInfoResponse = exports.QueryHrmEmployeeDismissionInfoResponseBody = exports.QueryHrmEmployeeDismissionInfoShrinkRequest = exports.QueryHrmEmployeeDismissionInfoRequest = exports.QueryHrmEmployeeDismissionInfoHeaders = exports.QueryDismissionStaffIdListResponse = exports.QueryDismissionStaffIdListResponseBody = exports.QueryDismissionStaffIdListRequest = exports.QueryDismissionStaffIdListHeaders = exports.QueryCustomEntryProcessesResponse = exports.QueryCustomEntryProcessesResponseBody = exports.QueryCustomEntryProcessesRequest = exports.QueryCustomEntryProcessesHeaders = exports.MasterDatasQueryResponse = exports.MasterDatasQueryResponseBody = exports.MasterDatasQueryRequest = exports.MasterDatasQueryHeaders = exports.MasterDataTenantQueyResponse = exports.MasterDataTenantQueyResponseBody = exports.MasterDataTenantQueyRequest = exports.MasterDataTenantQueyHeaders = exports.MasterDataSaveResponse = exports.MasterDataSaveResponseBody = exports.MasterDataSaveRequest = exports.MasterDataSaveHeaders = exports.MasterDataQueryResponse = exports.MasterDataQueryResponseBody = exports.MasterDataQueryRequest = exports.MasterDataQueryHeaders = exports.MasterDataDeleteResponse = exports.MasterDataDeleteResponseBody = exports.MasterDataDeleteRequest = exports.MasterDataDeleteHeaders = exports.HrmPtsServiceResponse = exports.HrmPtsServiceResponseBody = exports.HrmPtsServiceRequest = exports.HrmPtsServiceHeaders = exports.HrmProcessUpdateTerminationInfoResponse = exports.HrmProcessUpdateTerminationInfoResponseBody = void 0;
exports.MasterDataQueryResponseBodyResultViewEntityFieldVOList = exports.MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO = exports.MasterDataQueryRequestQueryParams = exports.MasterDataQueryRequestQueryParamsConditionList = exports.MasterDataDeleteResponseBodyFailResult = exports.MasterDataDeleteRequestBody = exports.MasterDataDeleteRequestBodyScope = exports.MasterDataDeleteRequestBodyFieldList = exports.HrmMailSendRequestOperator = exports.HrmMailSendRequestMail = exports.HrmMailSendRequestMailMeeting = exports.HrmMailSendRequestMailMeetingOrganizer = exports.HrmMailSendRequestMailMeetingAttendees = exports.HrmMailSendRequestMailMeetingAlarm = exports.HrmMailSendRequestMailAttachments = exports.GetEmployeeRosterByFieldResponseBodyResult = exports.GetEmployeeRosterByFieldResponseBodyResultFieldDataList = exports.GetEmployeeRosterByFieldResponseBodyResultFieldDataListFieldValueList = exports.AddHrmPreentryRequestGroups = exports.AddHrmPreentryRequestGroupsSections = exports.AddHrmPreentryRequestGroupsSectionsEmpFieldVOList = exports.UpdateIsvCardMessageResponse = exports.UpdateIsvCardMessageResponseBody = exports.UpdateIsvCardMessageRequest = exports.UpdateIsvCardMessageHeaders = exports.SyncTaskTemplateResponse = exports.SyncTaskTemplateResponseBody = exports.SyncTaskTemplateRequest = exports.SyncTaskTemplateHeaders = exports.SolutionTaskSaveResponse = exports.SolutionTaskSaveResponseBody = exports.SolutionTaskSaveRequest = exports.SolutionTaskSaveHeaders = exports.SolutionTaskInitResponse = exports.SolutionTaskInitResponseBody = exports.SolutionTaskInitRequest = exports.SolutionTaskInitHeaders = exports.SendIsvCardMessageResponse = exports.SendIsvCardMessageResponseBody = exports.SendIsvCardMessageRequest = exports.SendIsvCardMessageHeaders = exports.RosterMetaFieldOptionsUpdateResponse = exports.RosterMetaFieldOptionsUpdateResponseBody = exports.RosterMetaFieldOptionsUpdateRequest = exports.RosterMetaFieldOptionsUpdateHeaders = exports.RosterMetaAvailableFieldListResponse = exports.RosterMetaAvailableFieldListResponseBody = exports.RosterMetaAvailableFieldListRequest = exports.RosterMetaAvailableFieldListHeaders = exports.QueryPositionsResponse = void 0;
exports.SyncTaskTemplateRequestTaskScopeVO = exports.SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult = exports.RosterMetaAvailableFieldListResponseBodyResult = exports.QueryPositionsResponseBodyList = exports.QueryJobsResponseBodyList = exports.QueryJobRanksResponseBodyList = exports.QueryHrmEmployeeDismissionInfoResponseBodyResult = exports.QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList = exports.QueryCustomEntryProcessesResponseBodyList = exports.MasterDatasQueryResponseBodyResult = exports.MasterDatasQueryResponseBodyResultViewEntityFieldVOList = exports.MasterDatasQueryResponseBodyResultViewEntityFieldVOListFieldDataVO = exports.MasterDatasQueryRequestQueryParams = exports.MasterDatasQueryRequestQueryParamsConditionList = exports.MasterDataTenantQueyResponseBodyResult = exports.MasterDataSaveResponseBodyFailResult = exports.MasterDataSaveRequestBody = exports.MasterDataSaveRequestBodyScope = exports.MasterDataSaveRequestBodyFieldList = exports.MasterDataQueryResponseBodyResult = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddHrmPreentryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryHeaders = AddHrmPreentryHeaders;
class AddHrmPreentryRequest extends $tea.Model {
    static names() {
        return {
            agentId: 'agentId',
            groups: 'groups',
            mobile: 'mobile',
            name: 'name',
            needSendPreEntryMsg: 'needSendPreEntryMsg',
            preEntryTime: 'preEntryTime',
        };
    }
    static types() {
        return {
            agentId: 'number',
            groups: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroups },
            mobile: 'string',
            name: 'string',
            needSendPreEntryMsg: 'boolean',
            preEntryTime: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryRequest = AddHrmPreentryRequest;
class AddHrmPreentryResponseBody extends $tea.Model {
    static names() {
        return {
            tmpUserId: 'tmpUserId',
        };
    }
    static types() {
        return {
            tmpUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryResponseBody = AddHrmPreentryResponseBody;
class AddHrmPreentryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddHrmPreentryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryResponse = AddHrmPreentryResponse;
class DeviceMarketManagerResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeviceMarketManagerResponseBody = DeviceMarketManagerResponseBody;
class DeviceMarketManagerResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeviceMarketManagerResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeviceMarketManagerResponse = DeviceMarketManagerResponse;
class DeviceMarketOrderManagerResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeviceMarketOrderManagerResponseBody = DeviceMarketOrderManagerResponseBody;
class DeviceMarketOrderManagerResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeviceMarketOrderManagerResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeviceMarketOrderManagerResponse = DeviceMarketOrderManagerResponse;
class ECertQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ECertQueryHeaders = ECertQueryHeaders;
class ECertQueryRequest extends $tea.Model {
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ECertQueryRequest = ECertQueryRequest;
class ECertQueryResponseBody extends $tea.Model {
    static names() {
        return {
            certNO: 'certNO',
            employJobId: 'employJobId',
            employJobIdLabel: 'employJobIdLabel',
            employPositionId: 'employPositionId',
            employPositionIdLabel: 'employPositionIdLabel',
            employPositionRankId: 'employPositionRankId',
            employPositionRankIdLabel: 'employPositionRankIdLabel',
            hiredDate: 'hiredDate',
            lastWorkDay: 'lastWorkDay',
            mainDeptId: 'mainDeptId',
            mainDeptName: 'mainDeptName',
            name: 'name',
            realName: 'realName',
            terminationReasonPassive: 'terminationReasonPassive',
            terminationReasonVoluntary: 'terminationReasonVoluntary',
        };
    }
    static types() {
        return {
            certNO: 'string',
            employJobId: 'string',
            employJobIdLabel: 'string',
            employPositionId: 'string',
            employPositionIdLabel: 'string',
            employPositionRankId: 'string',
            employPositionRankIdLabel: 'string',
            hiredDate: 'string',
            lastWorkDay: 'string',
            mainDeptId: 'number',
            mainDeptName: 'string',
            name: 'string',
            realName: 'string',
            terminationReasonPassive: { 'type': 'array', 'itemType': 'string' },
            terminationReasonVoluntary: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ECertQueryResponseBody = ECertQueryResponseBody;
class ECertQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ECertQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ECertQueryResponse = ECertQueryResponse;
class EmployeeAttachmentUpdateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmployeeAttachmentUpdateHeaders = EmployeeAttachmentUpdateHeaders;
class EmployeeAttachmentUpdateRequest extends $tea.Model {
    static names() {
        return {
            appAgentId: 'appAgentId',
            fieldCode: 'fieldCode',
            fileSuffix: 'fileSuffix',
            mediaId: 'mediaId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
            fieldCode: 'string',
            fileSuffix: 'string',
            mediaId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmployeeAttachmentUpdateRequest = EmployeeAttachmentUpdateRequest;
class EmployeeAttachmentUpdateResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmployeeAttachmentUpdateResponseBody = EmployeeAttachmentUpdateResponseBody;
class EmployeeAttachmentUpdateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EmployeeAttachmentUpdateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EmployeeAttachmentUpdateResponse = EmployeeAttachmentUpdateResponse;
class EsignRollbackHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EsignRollbackHeaders = EsignRollbackHeaders;
class EsignRollbackRequest extends $tea.Model {
    static names() {
        return {
            optUserId: 'optUserId',
        };
    }
    static types() {
        return {
            optUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EsignRollbackRequest = EsignRollbackRequest;
class EsignRollbackResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EsignRollbackResponseBody = EsignRollbackResponseBody;
class EsignRollbackResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EsignRollbackResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.EsignRollbackResponse = EsignRollbackResponse;
class GetEmployeeRosterByFieldHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldHeaders = GetEmployeeRosterByFieldHeaders;
class GetEmployeeRosterByFieldRequest extends $tea.Model {
    static names() {
        return {
            appAgentId: 'appAgentId',
            fieldFilterList: 'fieldFilterList',
            text2SelectConvert: 'text2SelectConvert',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
            fieldFilterList: { 'type': 'array', 'itemType': 'string' },
            text2SelectConvert: 'boolean',
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldRequest = GetEmployeeRosterByFieldRequest;
class GetEmployeeRosterByFieldResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetEmployeeRosterByFieldResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldResponseBody = GetEmployeeRosterByFieldResponseBody;
class GetEmployeeRosterByFieldResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetEmployeeRosterByFieldResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldResponse = GetEmployeeRosterByFieldResponse;
class HrmBenefitQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmBenefitQueryHeaders = HrmBenefitQueryHeaders;
class HrmBenefitQueryRequest extends $tea.Model {
    static names() {
        return {
            benefitCodes: 'benefitCodes',
        };
    }
    static types() {
        return {
            benefitCodes: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmBenefitQueryRequest = HrmBenefitQueryRequest;
class HrmBenefitQueryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'any',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmBenefitQueryResponseBody = HrmBenefitQueryResponseBody;
class HrmBenefitQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmBenefitQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmBenefitQueryResponse = HrmBenefitQueryResponse;
class HrmMailSendHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendHeaders = HrmMailSendHeaders;
class HrmMailSendRequest extends $tea.Model {
    static names() {
        return {
            mail: 'mail',
            operator: 'operator',
        };
    }
    static types() {
        return {
            mail: HrmMailSendRequestMail,
            operator: HrmMailSendRequestOperator,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequest = HrmMailSendRequest;
class HrmMailSendResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendResponseBody = HrmMailSendResponseBody;
class HrmMailSendResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmMailSendResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendResponse = HrmMailSendResponse;
class HrmMokaEventHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaEventHeaders = HrmMokaEventHeaders;
class HrmMokaEventRequest extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            content: 'content',
        };
    }
    static types() {
        return {
            bizId: 'string',
            content: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaEventRequest = HrmMokaEventRequest;
class HrmMokaEventResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaEventResponseBody = HrmMokaEventResponseBody;
class HrmMokaEventResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmMokaEventResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaEventResponse = HrmMokaEventResponse;
class HrmMokaOapiHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaOapiHeaders = HrmMokaOapiHeaders;
class HrmMokaOapiRequest extends $tea.Model {
    static names() {
        return {
            apiCode: 'apiCode',
            params: 'params',
        };
    }
    static types() {
        return {
            apiCode: 'string',
            params: 'any',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaOapiRequest = HrmMokaOapiRequest;
class HrmMokaOapiResponseBody extends $tea.Model {
    static names() {
        return {
            bizSuccess: 'bizSuccess',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            result: 'result',
        };
    }
    static types() {
        return {
            bizSuccess: 'boolean',
            errorCode: 'string',
            errorMsg: 'string',
            result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaOapiResponseBody = HrmMokaOapiResponseBody;
class HrmMokaOapiResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmMokaOapiResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMokaOapiResponse = HrmMokaOapiResponse;
class HrmProcessRegularHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessRegularHeaders = HrmProcessRegularHeaders;
class HrmProcessRegularRequest extends $tea.Model {
    static names() {
        return {
            operationId: 'operationId',
            regularDate: 'regularDate',
            remark: 'remark',
            userId: 'userId',
        };
    }
    static types() {
        return {
            operationId: 'string',
            regularDate: 'number',
            remark: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessRegularRequest = HrmProcessRegularRequest;
class HrmProcessRegularResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessRegularResponseBody = HrmProcessRegularResponseBody;
class HrmProcessRegularResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessRegularResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessRegularResponse = HrmProcessRegularResponse;
class HrmProcessTransferHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessTransferHeaders = HrmProcessTransferHeaders;
class HrmProcessTransferRequest extends $tea.Model {
    static names() {
        return {
            deptIdsAfterTransfer: 'deptIdsAfterTransfer',
            jobIdAfterTransfer: 'jobIdAfterTransfer',
            mainDeptIdAfterTransfer: 'mainDeptIdAfterTransfer',
            operateUserId: 'operateUserId',
            positionIdAfterTransfer: 'positionIdAfterTransfer',
            positionLevelAfterTransfer: 'positionLevelAfterTransfer',
            positionNameAfterTransfer: 'positionNameAfterTransfer',
            rankIdAfterTransfer: 'rankIdAfterTransfer',
            userId: 'userId',
        };
    }
    static types() {
        return {
            deptIdsAfterTransfer: { 'type': 'array', 'itemType': 'number' },
            jobIdAfterTransfer: 'string',
            mainDeptIdAfterTransfer: 'number',
            operateUserId: 'string',
            positionIdAfterTransfer: 'string',
            positionLevelAfterTransfer: 'string',
            positionNameAfterTransfer: 'string',
            rankIdAfterTransfer: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessTransferRequest = HrmProcessTransferRequest;
class HrmProcessTransferResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessTransferResponseBody = HrmProcessTransferResponseBody;
class HrmProcessTransferResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessTransferResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessTransferResponse = HrmProcessTransferResponse;
class HrmProcessUpdateTerminationInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessUpdateTerminationInfoHeaders = HrmProcessUpdateTerminationInfoHeaders;
class HrmProcessUpdateTerminationInfoRequest extends $tea.Model {
    static names() {
        return {
            dismissionMemo: 'dismissionMemo',
            lastWorkDate: 'lastWorkDate',
            userId: 'userId',
        };
    }
    static types() {
        return {
            dismissionMemo: 'string',
            lastWorkDate: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessUpdateTerminationInfoRequest = HrmProcessUpdateTerminationInfoRequest;
class HrmProcessUpdateTerminationInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessUpdateTerminationInfoResponseBody = HrmProcessUpdateTerminationInfoResponseBody;
class HrmProcessUpdateTerminationInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessUpdateTerminationInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmProcessUpdateTerminationInfoResponse = HrmProcessUpdateTerminationInfoResponse;
class HrmPtsServiceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmPtsServiceHeaders = HrmPtsServiceHeaders;
class HrmPtsServiceRequest extends $tea.Model {
    static names() {
        return {
            env: 'env',
            method: 'method',
            outerId: 'outerId',
            params: 'params',
            path: 'path',
        };
    }
    static types() {
        return {
            env: 'string',
            method: 'string',
            outerId: 'string',
            params: 'any',
            path: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmPtsServiceRequest = HrmPtsServiceRequest;
class HrmPtsServiceResponseBody extends $tea.Model {
    static names() {
        return {
            bizSuccess: 'bizSuccess',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            result: 'result',
        };
    }
    static types() {
        return {
            bizSuccess: 'boolean',
            errorCode: 'string',
            errorMsg: 'string',
            result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmPtsServiceResponseBody = HrmPtsServiceResponseBody;
class HrmPtsServiceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmPtsServiceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmPtsServiceResponse = HrmPtsServiceResponse;
class MasterDataDeleteHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteHeaders = MasterDataDeleteHeaders;
class MasterDataDeleteRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            tenantId: 'tenantId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': MasterDataDeleteRequestBody },
            tenantId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteRequest = MasterDataDeleteRequest;
class MasterDataDeleteResponseBody extends $tea.Model {
    static names() {
        return {
            allSuccess: 'allSuccess',
            failResult: 'failResult',
        };
    }
    static types() {
        return {
            allSuccess: 'boolean',
            failResult: { 'type': 'array', 'itemType': MasterDataDeleteResponseBodyFailResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteResponseBody = MasterDataDeleteResponseBody;
class MasterDataDeleteResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataDeleteResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteResponse = MasterDataDeleteResponse;
class MasterDataQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryHeaders = MasterDataQueryHeaders;
class MasterDataQueryRequest extends $tea.Model {
    static names() {
        return {
            bizUK: 'bizUK',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            optUserId: 'optUserId',
            queryParams: 'queryParams',
            relationIds: 'relationIds',
            scopeCode: 'scopeCode',
            tenantId: 'tenantId',
            viewEntityCode: 'viewEntityCode',
        };
    }
    static types() {
        return {
            bizUK: 'string',
            maxResults: 'number',
            nextToken: 'number',
            optUserId: 'string',
            queryParams: { 'type': 'array', 'itemType': MasterDataQueryRequestQueryParams },
            relationIds: { 'type': 'array', 'itemType': 'string' },
            scopeCode: 'string',
            tenantId: 'number',
            viewEntityCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryRequest = MasterDataQueryRequest;
class MasterDataQueryResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            result: 'result',
            success: 'success',
            total: 'total',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'number',
            result: { 'type': 'array', 'itemType': MasterDataQueryResponseBodyResult },
            success: 'boolean',
            total: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryResponseBody = MasterDataQueryResponseBody;
class MasterDataQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryResponse = MasterDataQueryResponse;
class MasterDataSaveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveHeaders = MasterDataSaveHeaders;
class MasterDataSaveRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            tenantId: 'tenantId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': MasterDataSaveRequestBody },
            tenantId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveRequest = MasterDataSaveRequest;
class MasterDataSaveResponseBody extends $tea.Model {
    static names() {
        return {
            allSuccess: 'allSuccess',
            failResult: 'failResult',
        };
    }
    static types() {
        return {
            allSuccess: 'boolean',
            failResult: { 'type': 'array', 'itemType': MasterDataSaveResponseBodyFailResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveResponseBody = MasterDataSaveResponseBody;
class MasterDataSaveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataSaveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveResponse = MasterDataSaveResponse;
class MasterDataTenantQueyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataTenantQueyHeaders = MasterDataTenantQueyHeaders;
class MasterDataTenantQueyRequest extends $tea.Model {
    static names() {
        return {
            entityCode: 'entityCode',
            scopeCode: 'scopeCode',
        };
    }
    static types() {
        return {
            entityCode: 'string',
            scopeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataTenantQueyRequest = MasterDataTenantQueyRequest;
class MasterDataTenantQueyResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': MasterDataTenantQueyResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataTenantQueyResponseBody = MasterDataTenantQueyResponseBody;
class MasterDataTenantQueyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataTenantQueyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataTenantQueyResponse = MasterDataTenantQueyResponse;
class MasterDatasQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryHeaders = MasterDatasQueryHeaders;
class MasterDatasQueryRequest extends $tea.Model {
    static names() {
        return {
            bizUK: 'bizUK',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            queryParams: 'queryParams',
            relationIds: 'relationIds',
            scopeCode: 'scopeCode',
            tenantId: 'tenantId',
            viewEntityCode: 'viewEntityCode',
        };
    }
    static types() {
        return {
            bizUK: 'string',
            maxResults: 'number',
            nextToken: 'number',
            queryParams: { 'type': 'array', 'itemType': MasterDatasQueryRequestQueryParams },
            relationIds: { 'type': 'array', 'itemType': 'string' },
            scopeCode: 'string',
            tenantId: 'number',
            viewEntityCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryRequest = MasterDatasQueryRequest;
class MasterDatasQueryResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            result: 'result',
            success: 'success',
            total: 'total',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'number',
            result: { 'type': 'array', 'itemType': MasterDatasQueryResponseBodyResult },
            success: 'boolean',
            total: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryResponseBody = MasterDatasQueryResponseBody;
class MasterDatasQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDatasQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryResponse = MasterDatasQueryResponse;
class QueryCustomEntryProcessesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomEntryProcessesHeaders = QueryCustomEntryProcessesHeaders;
class QueryCustomEntryProcessesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operateUserId: 'operateUserId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            operateUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomEntryProcessesRequest = QueryCustomEntryProcessesRequest;
class QueryCustomEntryProcessesResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryCustomEntryProcessesResponseBodyList },
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomEntryProcessesResponseBody = QueryCustomEntryProcessesResponseBody;
class QueryCustomEntryProcessesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCustomEntryProcessesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomEntryProcessesResponse = QueryCustomEntryProcessesResponse;
class QueryDismissionStaffIdListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryDismissionStaffIdListHeaders = QueryDismissionStaffIdListHeaders;
class QueryDismissionStaffIdListRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryDismissionStaffIdListRequest = QueryDismissionStaffIdListRequest;
class QueryDismissionStaffIdListResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'number',
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryDismissionStaffIdListResponseBody = QueryDismissionStaffIdListResponseBody;
class QueryDismissionStaffIdListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDismissionStaffIdListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryDismissionStaffIdListResponse = QueryDismissionStaffIdListResponse;
class QueryHrmEmployeeDismissionInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoHeaders = QueryHrmEmployeeDismissionInfoHeaders;
class QueryHrmEmployeeDismissionInfoRequest extends $tea.Model {
    static names() {
        return {
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoRequest = QueryHrmEmployeeDismissionInfoRequest;
class QueryHrmEmployeeDismissionInfoShrinkRequest extends $tea.Model {
    static names() {
        return {
            userIdListShrink: 'userIdList',
        };
    }
    static types() {
        return {
            userIdListShrink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoShrinkRequest = QueryHrmEmployeeDismissionInfoShrinkRequest;
class QueryHrmEmployeeDismissionInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': QueryHrmEmployeeDismissionInfoResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBody = QueryHrmEmployeeDismissionInfoResponseBody;
class QueryHrmEmployeeDismissionInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryHrmEmployeeDismissionInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoResponse = QueryHrmEmployeeDismissionInfoResponse;
class QueryJobRanksHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobRanksHeaders = QueryJobRanksHeaders;
class QueryJobRanksRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            rankCategoryId: 'rankCategoryId',
            rankCode: 'rankCode',
            rankName: 'rankName',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            rankCategoryId: 'string',
            rankCode: 'string',
            rankName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobRanksRequest = QueryJobRanksRequest;
class QueryJobRanksResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryJobRanksResponseBodyList },
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobRanksResponseBody = QueryJobRanksResponseBody;
class QueryJobRanksResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobRanksResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobRanksResponse = QueryJobRanksResponse;
class QueryJobsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobsHeaders = QueryJobsHeaders;
class QueryJobsRequest extends $tea.Model {
    static names() {
        return {
            jobName: 'jobName',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            jobName: 'string',
            maxResults: 'number',
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobsRequest = QueryJobsRequest;
class QueryJobsResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryJobsResponseBodyList },
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobsResponseBody = QueryJobsResponseBody;
class QueryJobsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobsResponse = QueryJobsResponse;
class QueryPositionsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPositionsHeaders = QueryPositionsHeaders;
class QueryPositionsRequest extends $tea.Model {
    static names() {
        return {
            deptId: 'deptId',
            inCategoryIds: 'inCategoryIds',
            inPositionIds: 'inPositionIds',
            positionName: 'positionName',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            deptId: 'number',
            inCategoryIds: { 'type': 'array', 'itemType': 'string' },
            inPositionIds: { 'type': 'array', 'itemType': 'string' },
            positionName: 'string',
            maxResults: 'number',
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPositionsRequest = QueryPositionsRequest;
class QueryPositionsResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryPositionsResponseBodyList },
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPositionsResponseBody = QueryPositionsResponseBody;
class QueryPositionsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPositionsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPositionsResponse = QueryPositionsResponse;
class RosterMetaAvailableFieldListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaAvailableFieldListHeaders = RosterMetaAvailableFieldListHeaders;
class RosterMetaAvailableFieldListRequest extends $tea.Model {
    static names() {
        return {
            appAgentId: 'appAgentId',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaAvailableFieldListRequest = RosterMetaAvailableFieldListRequest;
class RosterMetaAvailableFieldListResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': RosterMetaAvailableFieldListResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaAvailableFieldListResponseBody = RosterMetaAvailableFieldListResponseBody;
class RosterMetaAvailableFieldListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RosterMetaAvailableFieldListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaAvailableFieldListResponse = RosterMetaAvailableFieldListResponse;
class RosterMetaFieldOptionsUpdateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaFieldOptionsUpdateHeaders = RosterMetaFieldOptionsUpdateHeaders;
class RosterMetaFieldOptionsUpdateRequest extends $tea.Model {
    static names() {
        return {
            appAgentId: 'appAgentId',
            fieldCode: 'fieldCode',
            groupId: 'groupId',
            labels: 'labels',
            modifyType: 'modifyType',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
            fieldCode: 'string',
            groupId: 'string',
            labels: { 'type': 'array', 'itemType': 'string' },
            modifyType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaFieldOptionsUpdateRequest = RosterMetaFieldOptionsUpdateRequest;
class RosterMetaFieldOptionsUpdateResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaFieldOptionsUpdateResponseBody = RosterMetaFieldOptionsUpdateResponseBody;
class RosterMetaFieldOptionsUpdateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RosterMetaFieldOptionsUpdateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaFieldOptionsUpdateResponse = RosterMetaFieldOptionsUpdateResponse;
class SendIsvCardMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendIsvCardMessageHeaders = SendIsvCardMessageHeaders;
class SendIsvCardMessageRequest extends $tea.Model {
    static names() {
        return {
            agentId: 'agentId',
            bizId: 'bizId',
            messageType: 'messageType',
            receiverUserIds: 'receiverUserIds',
            sceneType: 'sceneType',
            scope: 'scope',
            senderUserId: 'senderUserId',
            valueMap: 'valueMap',
        };
    }
    static types() {
        return {
            agentId: 'number',
            bizId: 'string',
            messageType: 'string',
            receiverUserIds: { 'type': 'array', 'itemType': 'string' },
            sceneType: 'string',
            scope: 'string',
            senderUserId: 'string',
            valueMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendIsvCardMessageRequest = SendIsvCardMessageRequest;
class SendIsvCardMessageResponseBody extends $tea.Model {
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            hrmInteractiveCardSendResult: 'hrmInteractiveCardSendResult',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            hrmInteractiveCardSendResult: SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult,
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendIsvCardMessageResponseBody = SendIsvCardMessageResponseBody;
class SendIsvCardMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendIsvCardMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendIsvCardMessageResponse = SendIsvCardMessageResponse;
class SolutionTaskInitHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskInitHeaders = SolutionTaskInitHeaders;
class SolutionTaskInitRequest extends $tea.Model {
    static names() {
        return {
            category: 'category',
            claimTime: 'claimTime',
            description: 'description',
            finishTime: 'finishTime',
            outerId: 'outerId',
            status: 'status',
            title: 'title',
            userId: 'userId',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            category: 'string',
            claimTime: 'number',
            description: 'string',
            finishTime: 'number',
            outerId: 'string',
            status: 'string',
            title: 'string',
            userId: 'string',
            solutionType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskInitRequest = SolutionTaskInitRequest;
class SolutionTaskInitResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskInitResponseBody = SolutionTaskInitResponseBody;
class SolutionTaskInitResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SolutionTaskInitResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskInitResponse = SolutionTaskInitResponse;
class SolutionTaskSaveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskSaveHeaders = SolutionTaskSaveHeaders;
class SolutionTaskSaveRequest extends $tea.Model {
    static names() {
        return {
            claimTime: 'claimTime',
            description: 'description',
            finishTime: 'finishTime',
            outerId: 'outerId',
            solutionInstanceId: 'solutionInstanceId',
            startTime: 'startTime',
            status: 'status',
            taskType: 'taskType',
            templateOuterId: 'templateOuterId',
            title: 'title',
            userId: 'userId',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            claimTime: 'number',
            description: 'string',
            finishTime: 'number',
            outerId: 'string',
            solutionInstanceId: 'string',
            startTime: 'number',
            status: 'string',
            taskType: 'string',
            templateOuterId: 'string',
            title: 'string',
            userId: 'string',
            solutionType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskSaveRequest = SolutionTaskSaveRequest;
class SolutionTaskSaveResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskSaveResponseBody = SolutionTaskSaveResponseBody;
class SolutionTaskSaveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SolutionTaskSaveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SolutionTaskSaveResponse = SolutionTaskSaveResponse;
class SyncTaskTemplateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncTaskTemplateHeaders = SyncTaskTemplateHeaders;
class SyncTaskTemplateRequest extends $tea.Model {
    static names() {
        return {
            delete: 'delete',
            des: 'des',
            ext: 'ext',
            name: 'name',
            optUserId: 'optUserId',
            outerId: 'outerId',
            taskScopeVO: 'taskScopeVO',
            taskType: 'taskType',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            delete: 'boolean',
            des: 'string',
            ext: 'string',
            name: 'string',
            optUserId: 'string',
            outerId: 'string',
            taskScopeVO: SyncTaskTemplateRequestTaskScopeVO,
            taskType: 'string',
            solutionType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncTaskTemplateRequest = SyncTaskTemplateRequest;
class SyncTaskTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncTaskTemplateResponseBody = SyncTaskTemplateResponseBody;
class SyncTaskTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncTaskTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncTaskTemplateResponse = SyncTaskTemplateResponse;
class UpdateIsvCardMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateIsvCardMessageHeaders = UpdateIsvCardMessageHeaders;
class UpdateIsvCardMessageRequest extends $tea.Model {
    static names() {
        return {
            agentId: 'agentId',
            bizId: 'bizId',
            messageType: 'messageType',
            sceneType: 'sceneType',
            scope: 'scope',
            valueMap: 'valueMap',
        };
    }
    static types() {
        return {
            agentId: 'number',
            bizId: 'string',
            messageType: 'string',
            sceneType: 'string',
            scope: 'string',
            valueMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateIsvCardMessageRequest = UpdateIsvCardMessageRequest;
class UpdateIsvCardMessageResponseBody extends $tea.Model {
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateIsvCardMessageResponseBody = UpdateIsvCardMessageResponseBody;
class UpdateIsvCardMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateIsvCardMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateIsvCardMessageResponse = UpdateIsvCardMessageResponse;
class AddHrmPreentryRequestGroupsSectionsEmpFieldVOList extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            value: 'value',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryRequestGroupsSectionsEmpFieldVOList = AddHrmPreentryRequestGroupsSectionsEmpFieldVOList;
class AddHrmPreentryRequestGroupsSections extends $tea.Model {
    static names() {
        return {
            empFieldVOList: 'empFieldVOList',
            oldIndex: 'oldIndex',
        };
    }
    static types() {
        return {
            empFieldVOList: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroupsSectionsEmpFieldVOList },
            oldIndex: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryRequestGroupsSections = AddHrmPreentryRequestGroupsSections;
class AddHrmPreentryRequestGroups extends $tea.Model {
    static names() {
        return {
            groupId: 'groupId',
            sections: 'sections',
        };
    }
    static types() {
        return {
            groupId: 'string',
            sections: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroupsSections },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddHrmPreentryRequestGroups = AddHrmPreentryRequestGroups;
class GetEmployeeRosterByFieldResponseBodyResultFieldDataListFieldValueList extends $tea.Model {
    static names() {
        return {
            itemIndex: 'itemIndex',
            label: 'label',
            value: 'value',
        };
    }
    static types() {
        return {
            itemIndex: 'number',
            label: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldResponseBodyResultFieldDataListFieldValueList = GetEmployeeRosterByFieldResponseBodyResultFieldDataListFieldValueList;
class GetEmployeeRosterByFieldResponseBodyResultFieldDataList extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldName: 'fieldName',
            fieldValueList: 'fieldValueList',
            groupId: 'groupId',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldName: 'string',
            fieldValueList: { 'type': 'array', 'itemType': GetEmployeeRosterByFieldResponseBodyResultFieldDataListFieldValueList },
            groupId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldResponseBodyResultFieldDataList = GetEmployeeRosterByFieldResponseBodyResultFieldDataList;
class GetEmployeeRosterByFieldResponseBodyResult extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            fieldDataList: 'fieldDataList',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            fieldDataList: { 'type': 'array', 'itemType': GetEmployeeRosterByFieldResponseBodyResultFieldDataList },
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetEmployeeRosterByFieldResponseBodyResult = GetEmployeeRosterByFieldResponseBodyResult;
class HrmMailSendRequestMailAttachments extends $tea.Model {
    static names() {
        return {
            name: 'name',
            path: 'path',
            type: 'type',
        };
    }
    static types() {
        return {
            name: 'string',
            path: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMailAttachments = HrmMailSendRequestMailAttachments;
class HrmMailSendRequestMailMeetingAlarm extends $tea.Model {
    static names() {
        return {
            alarmDesc: 'alarmDesc',
            alarmMinutes: 'alarmMinutes',
            alarmSummary: 'alarmSummary',
        };
    }
    static types() {
        return {
            alarmDesc: 'string',
            alarmMinutes: 'number',
            alarmSummary: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMailMeetingAlarm = HrmMailSendRequestMailMeetingAlarm;
class HrmMailSendRequestMailMeetingAttendees extends $tea.Model {
    static names() {
        return {
            address: 'address',
            name: 'name',
        };
    }
    static types() {
        return {
            address: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMailMeetingAttendees = HrmMailSendRequestMailMeetingAttendees;
class HrmMailSendRequestMailMeetingOrganizer extends $tea.Model {
    static names() {
        return {
            address: 'address',
            name: 'name',
        };
    }
    static types() {
        return {
            address: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMailMeetingOrganizer = HrmMailSendRequestMailMeetingOrganizer;
class HrmMailSendRequestMailMeeting extends $tea.Model {
    static names() {
        return {
            alarm: 'alarm',
            attendees: 'attendees',
            description: 'description',
            endTime: 'endTime',
            location: 'location',
            method: 'method',
            organizer: 'organizer',
            sequence: 'sequence',
            startTime: 'startTime',
            summary: 'summary',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            alarm: HrmMailSendRequestMailMeetingAlarm,
            attendees: { 'type': 'array', 'itemType': HrmMailSendRequestMailMeetingAttendees },
            description: 'string',
            endTime: 'number',
            location: 'string',
            method: 'string',
            organizer: HrmMailSendRequestMailMeetingOrganizer,
            sequence: 'number',
            startTime: 'number',
            summary: 'string',
            uuid: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMailMeeting = HrmMailSendRequestMailMeeting;
class HrmMailSendRequestMail extends $tea.Model {
    static names() {
        return {
            attachments: 'attachments',
            bccAddress: 'bccAddress',
            ccAddress: 'ccAddress',
            content: 'content',
            meeting: 'meeting',
            receiverAddress: 'receiverAddress',
            senderAlias: 'senderAlias',
            subject: 'subject',
        };
    }
    static types() {
        return {
            attachments: { 'type': 'array', 'itemType': HrmMailSendRequestMailAttachments },
            bccAddress: 'string',
            ccAddress: 'string',
            content: 'string',
            meeting: HrmMailSendRequestMailMeeting,
            receiverAddress: 'string',
            senderAlias: 'string',
            subject: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestMail = HrmMailSendRequestMail;
class HrmMailSendRequestOperator extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            mailAccountType: 'mailAccountType',
            token: 'token',
        };
    }
    static types() {
        return {
            bizId: 'string',
            mailAccountType: 'string',
            token: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrmMailSendRequestOperator = HrmMailSendRequestOperator;
class MasterDataDeleteRequestBodyFieldList extends $tea.Model {
    static names() {
        return {
            name: 'name',
            valueStr: 'valueStr',
        };
    }
    static types() {
        return {
            name: 'string',
            valueStr: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteRequestBodyFieldList = MasterDataDeleteRequestBodyFieldList;
class MasterDataDeleteRequestBodyScope extends $tea.Model {
    static names() {
        return {
            scopeCode: 'scopeCode',
            version: 'version',
        };
    }
    static types() {
        return {
            scopeCode: 'string',
            version: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteRequestBodyScope = MasterDataDeleteRequestBodyScope;
class MasterDataDeleteRequestBody extends $tea.Model {
    static names() {
        return {
            bizTime: 'bizTime',
            bizUk: 'bizUk',
            entityCode: 'entityCode',
            fieldList: 'fieldList',
            scope: 'scope',
        };
    }
    static types() {
        return {
            bizTime: 'number',
            bizUk: 'string',
            entityCode: 'string',
            fieldList: { 'type': 'array', 'itemType': MasterDataDeleteRequestBodyFieldList },
            scope: MasterDataDeleteRequestBodyScope,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteRequestBody = MasterDataDeleteRequestBody;
class MasterDataDeleteResponseBodyFailResult extends $tea.Model {
    static names() {
        return {
            bizUK: 'bizUK',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            bizUK: 'string',
            errorCode: 'string',
            errorMsg: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataDeleteResponseBodyFailResult = MasterDataDeleteResponseBodyFailResult;
class MasterDataQueryRequestQueryParamsConditionList extends $tea.Model {
    static names() {
        return {
            operate: 'operate',
            value: 'value',
        };
    }
    static types() {
        return {
            operate: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryRequestQueryParamsConditionList = MasterDataQueryRequestQueryParamsConditionList;
class MasterDataQueryRequestQueryParams extends $tea.Model {
    static names() {
        return {
            conditionList: 'conditionList',
            fieldCode: 'fieldCode',
            joinType: 'joinType',
        };
    }
    static types() {
        return {
            conditionList: { 'type': 'array', 'itemType': MasterDataQueryRequestQueryParamsConditionList },
            fieldCode: 'string',
            joinType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryRequestQueryParams = MasterDataQueryRequestQueryParams;
class MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO extends $tea.Model {
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO = MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO;
class MasterDataQueryResponseBodyResultViewEntityFieldVOList extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldDataVO: 'fieldDataVO',
            fieldName: 'fieldName',
            fieldType: 'fieldType',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldDataVO: MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO,
            fieldName: 'string',
            fieldType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryResponseBodyResultViewEntityFieldVOList = MasterDataQueryResponseBodyResultViewEntityFieldVOList;
class MasterDataQueryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            outerId: 'outerId',
            relationId: 'relationId',
            scopeCode: 'scopeCode',
            viewEntityCode: 'viewEntityCode',
            viewEntityFieldVOList: 'viewEntityFieldVOList',
        };
    }
    static types() {
        return {
            outerId: 'string',
            relationId: 'string',
            scopeCode: 'string',
            viewEntityCode: 'string',
            viewEntityFieldVOList: { 'type': 'array', 'itemType': MasterDataQueryResponseBodyResultViewEntityFieldVOList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataQueryResponseBodyResult = MasterDataQueryResponseBodyResult;
class MasterDataSaveRequestBodyFieldList extends $tea.Model {
    static names() {
        return {
            name: 'name',
            valueStr: 'valueStr',
        };
    }
    static types() {
        return {
            name: 'string',
            valueStr: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveRequestBodyFieldList = MasterDataSaveRequestBodyFieldList;
class MasterDataSaveRequestBodyScope extends $tea.Model {
    static names() {
        return {
            scopeCode: 'scopeCode',
            version: 'version',
        };
    }
    static types() {
        return {
            scopeCode: 'string',
            version: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveRequestBodyScope = MasterDataSaveRequestBodyScope;
class MasterDataSaveRequestBody extends $tea.Model {
    static names() {
        return {
            bizTime: 'bizTime',
            bizUk: 'bizUk',
            entityCode: 'entityCode',
            fieldList: 'fieldList',
            scope: 'scope',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizTime: 'number',
            bizUk: 'string',
            entityCode: 'string',
            fieldList: { 'type': 'array', 'itemType': MasterDataSaveRequestBodyFieldList },
            scope: MasterDataSaveRequestBodyScope,
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveRequestBody = MasterDataSaveRequestBody;
class MasterDataSaveResponseBodyFailResult extends $tea.Model {
    static names() {
        return {
            bizUk: 'bizUk',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            bizUk: 'string',
            errorCode: 'string',
            errorMsg: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataSaveResponseBodyFailResult = MasterDataSaveResponseBodyFailResult;
class MasterDataTenantQueyResponseBodyResult extends $tea.Model {
    static names() {
        return {
            hasData: 'hasData',
            integrateDataAuth: 'integrateDataAuth',
            name: 'name',
            readAuth: 'readAuth',
            tenantId: 'tenantId',
            type: 'type',
        };
    }
    static types() {
        return {
            hasData: 'boolean',
            integrateDataAuth: 'boolean',
            name: 'string',
            readAuth: 'boolean',
            tenantId: 'number',
            type: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDataTenantQueyResponseBodyResult = MasterDataTenantQueyResponseBodyResult;
class MasterDatasQueryRequestQueryParamsConditionList extends $tea.Model {
    static names() {
        return {
            operate: 'operate',
            value: 'value',
        };
    }
    static types() {
        return {
            operate: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryRequestQueryParamsConditionList = MasterDatasQueryRequestQueryParamsConditionList;
class MasterDatasQueryRequestQueryParams extends $tea.Model {
    static names() {
        return {
            conditionList: 'conditionList',
            fieldCode: 'fieldCode',
            joinType: 'joinType',
        };
    }
    static types() {
        return {
            conditionList: { 'type': 'array', 'itemType': MasterDatasQueryRequestQueryParamsConditionList },
            fieldCode: 'string',
            joinType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryRequestQueryParams = MasterDatasQueryRequestQueryParams;
class MasterDatasQueryResponseBodyResultViewEntityFieldVOListFieldDataVO extends $tea.Model {
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryResponseBodyResultViewEntityFieldVOListFieldDataVO = MasterDatasQueryResponseBodyResultViewEntityFieldVOListFieldDataVO;
class MasterDatasQueryResponseBodyResultViewEntityFieldVOList extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldDataVO: 'fieldDataVO',
            fieldName: 'fieldName',
            fieldType: 'fieldType',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldDataVO: MasterDatasQueryResponseBodyResultViewEntityFieldVOListFieldDataVO,
            fieldName: 'string',
            fieldType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryResponseBodyResultViewEntityFieldVOList = MasterDatasQueryResponseBodyResultViewEntityFieldVOList;
class MasterDatasQueryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            objId: 'objId',
            relationId: 'relationId',
            scopeCode: 'scopeCode',
            viewEntityCode: 'viewEntityCode',
            viewEntityFieldVOList: 'viewEntityFieldVOList',
        };
    }
    static types() {
        return {
            objId: 'string',
            relationId: 'string',
            scopeCode: 'string',
            viewEntityCode: 'string',
            viewEntityFieldVOList: { 'type': 'array', 'itemType': MasterDatasQueryResponseBodyResultViewEntityFieldVOList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MasterDatasQueryResponseBodyResult = MasterDatasQueryResponseBodyResult;
class QueryCustomEntryProcessesResponseBodyList extends $tea.Model {
    static names() {
        return {
            formDesc: 'formDesc',
            formId: 'formId',
            formName: 'formName',
            shortUrl: 'shortUrl',
        };
    }
    static types() {
        return {
            formDesc: 'string',
            formId: 'string',
            formName: 'string',
            shortUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCustomEntryProcessesResponseBodyList = QueryCustomEntryProcessesResponseBodyList;
class QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList extends $tea.Model {
    static names() {
        return {
            deptId: 'dept_id',
            deptPath: 'dept_path',
        };
    }
    static types() {
        return {
            deptId: 'number',
            deptPath: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList = QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList;
class QueryHrmEmployeeDismissionInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            deptList: 'deptList',
            handoverUserId: 'handoverUserId',
            lastWorkDay: 'lastWorkDay',
            mainDeptId: 'mainDeptId',
            mainDeptName: 'mainDeptName',
            name: 'name',
            passiveReason: 'passiveReason',
            preStatus: 'preStatus',
            reasonMemo: 'reasonMemo',
            status: 'status',
            userId: 'userId',
            voluntaryReason: 'voluntaryReason',
        };
    }
    static types() {
        return {
            deptList: { 'type': 'array', 'itemType': QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList },
            handoverUserId: 'string',
            lastWorkDay: 'number',
            mainDeptId: 'number',
            mainDeptName: 'string',
            name: 'string',
            passiveReason: { 'type': 'array', 'itemType': 'string' },
            preStatus: 'number',
            reasonMemo: 'string',
            status: 'number',
            userId: 'string',
            voluntaryReason: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBodyResult = QueryHrmEmployeeDismissionInfoResponseBodyResult;
class QueryJobRanksResponseBodyList extends $tea.Model {
    static names() {
        return {
            maxJobGrade: 'maxJobGrade',
            minJobGrade: 'minJobGrade',
            rankCategoryId: 'rankCategoryId',
            rankCode: 'rankCode',
            rankDescription: 'rankDescription',
            rankId: 'rankId',
            rankName: 'rankName',
        };
    }
    static types() {
        return {
            maxJobGrade: 'number',
            minJobGrade: 'number',
            rankCategoryId: 'string',
            rankCode: 'string',
            rankDescription: 'string',
            rankId: 'string',
            rankName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobRanksResponseBodyList = QueryJobRanksResponseBodyList;
class QueryJobsResponseBodyList extends $tea.Model {
    static names() {
        return {
            jobDescription: 'jobDescription',
            jobId: 'jobId',
            jobName: 'jobName',
        };
    }
    static types() {
        return {
            jobDescription: 'string',
            jobId: 'string',
            jobName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryJobsResponseBodyList = QueryJobsResponseBodyList;
class QueryPositionsResponseBodyList extends $tea.Model {
    static names() {
        return {
            jobId: 'jobId',
            positionCategoryId: 'positionCategoryId',
            positionDes: 'positionDes',
            positionId: 'positionId',
            positionName: 'positionName',
            rankIdList: 'rankIdList',
            status: 'status',
        };
    }
    static types() {
        return {
            jobId: 'string',
            positionCategoryId: 'string',
            positionDes: 'string',
            positionId: 'string',
            positionName: 'string',
            rankIdList: { 'type': 'array', 'itemType': 'string' },
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPositionsResponseBodyList = QueryPositionsResponseBodyList;
class RosterMetaAvailableFieldListResponseBodyResult extends $tea.Model {
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldName: 'fieldName',
            fieldType: 'fieldType',
            optionText: 'optionText',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldName: 'string',
            fieldType: 'string',
            optionText: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RosterMetaAvailableFieldListResponseBodyResult = RosterMetaAvailableFieldListResponseBodyResult;
class SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult extends $tea.Model {
    static names() {
        return {
            bizId: 'bizId',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
        };
    }
    static types() {
        return {
            bizId: 'string',
            errorCode: 'string',
            errorMsg: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult = SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult;
class SyncTaskTemplateRequestTaskScopeVO extends $tea.Model {
    static names() {
        return {
            deptIds: 'deptIds',
            positionIds: 'positionIds',
            roleIds: 'roleIds',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            deptIds: { 'type': 'array', 'itemType': 'number' },
            positionIds: { 'type': 'array', 'itemType': 'string' },
            roleIds: { 'type': 'array', 'itemType': 'string' },
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncTaskTemplateRequestTaskScopeVO = SyncTaskTemplateRequestTaskScopeVO;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._signatureAlgorithm = "v2";
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary ()
     *
     * @param request AddHrmPreentryRequest
     * @param headers AddHrmPreentryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddHrmPreentryResponse
     */
    async addHrmPreentryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            body["agentId"] = request.agentId;
        }
        if (!tea_util_1.default.isUnset(request.groups)) {
            body["groups"] = request.groups;
        }
        if (!tea_util_1.default.isUnset(request.mobile)) {
            body["mobile"] = request.mobile;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.needSendPreEntryMsg)) {
            body["needSendPreEntryMsg"] = request.needSendPreEntryMsg;
        }
        if (!tea_util_1.default.isUnset(request.preEntryTime)) {
            body["preEntryTime"] = request.preEntryTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddHrmPreentry",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/preentries`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddHrmPreentryResponse({}));
    }
    /**
     * @summary ()
     *
     * @param request AddHrmPreentryRequest
     * @return AddHrmPreentryResponse
     */
    async addHrmPreentry(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddHrmPreentryHeaders({});
        return await this.addHrmPreentryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeviceMarketManagerResponse
     */
    async deviceMarketManagerWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeviceMarketManager",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/device/market/manager`,
            method: "GET",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeviceMarketManagerResponse({}));
    }
    /**
     * @summary 
     *
     * @return DeviceMarketManagerResponse
     */
    async deviceMarketManager() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deviceMarketManagerWithOptions(headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeviceMarketOrderManagerResponse
     */
    async deviceMarketOrderManagerWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeviceMarketOrderManager",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/device/market/order/manager`,
            method: "GET",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeviceMarketOrderManagerResponse({}));
    }
    /**
     * @summary 
     *
     * @return DeviceMarketOrderManagerResponse
     */
    async deviceMarketOrderManager() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deviceMarketOrderManagerWithOptions(headers, runtime);
    }
    /**
     * @summary e
     *
     * @param request ECertQueryRequest
     * @param headers ECertQueryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ECertQueryResponse
     */
    async eCertQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ECertQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/eCerts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ECertQueryResponse({}));
    }
    /**
     * @summary e
     *
     * @param request ECertQueryRequest
     * @return ECertQueryResponse
     */
    async eCertQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ECertQueryHeaders({});
        return await this.eCertQueryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request EmployeeAttachmentUpdateRequest
     * @param headers EmployeeAttachmentUpdateHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return EmployeeAttachmentUpdateResponse
     */
    async employeeAttachmentUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            query["appAgentId"] = request.appAgentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldCode)) {
            body["fieldCode"] = request.fieldCode;
        }
        if (!tea_util_1.default.isUnset(request.fileSuffix)) {
            body["fileSuffix"] = request.fileSuffix;
        }
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            body["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "EmployeeAttachmentUpdate",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/employees/attachments`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new EmployeeAttachmentUpdateResponse({}));
    }
    /**
     * @summary 
     *
     * @param request EmployeeAttachmentUpdateRequest
     * @return EmployeeAttachmentUpdateResponse
     */
    async employeeAttachmentUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new EmployeeAttachmentUpdateHeaders({});
        return await this.employeeAttachmentUpdateWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request EsignRollbackRequest
     * @param headers EsignRollbackHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return EsignRollbackResponse
     */
    async esignRollbackWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            query["optUserId"] = request.optUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EsignRollback",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/contracts/esign/rollback`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new EsignRollbackResponse({}));
    }
    /**
     * @summary 
     *
     * @param request EsignRollbackRequest
     * @return EsignRollbackResponse
     */
    async esignRollback(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new EsignRollbackHeaders({});
        return await this.esignRollbackWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetEmployeeRosterByFieldRequest
     * @param headers GetEmployeeRosterByFieldHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetEmployeeRosterByFieldResponse
     */
    async getEmployeeRosterByFieldWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            body["appAgentId"] = request.appAgentId;
        }
        if (!tea_util_1.default.isUnset(request.fieldFilterList)) {
            body["fieldFilterList"] = request.fieldFilterList;
        }
        if (!tea_util_1.default.isUnset(request.text2SelectConvert)) {
            body["text2SelectConvert"] = request.text2SelectConvert;
        }
        if (!tea_util_1.default.isUnset(request.userIdList)) {
            body["userIdList"] = request.userIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetEmployeeRosterByField",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/rosters/lists/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetEmployeeRosterByFieldResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetEmployeeRosterByFieldRequest
     * @return GetEmployeeRosterByFieldResponse
     */
    async getEmployeeRosterByField(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetEmployeeRosterByFieldHeaders({});
        return await this.getEmployeeRosterByFieldWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrmBenefitQueryRequest
     * @param headers HrmBenefitQueryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmBenefitQueryResponse
     */
    async hrmBenefitQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.benefitCodes)) {
            body["benefitCodes"] = request.benefitCodes;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmBenefitQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/benefits/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmBenefitQueryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrmBenefitQueryRequest
     * @return HrmBenefitQueryResponse
     */
    async hrmBenefitQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmBenefitQueryHeaders({});
        return await this.hrmBenefitQueryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrmMailSendRequest
     * @param headers HrmMailSendHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmMailSendResponse
     */
    async hrmMailSendWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mail)) {
            body["mail"] = request.mail;
        }
        if (!tea_util_1.default.isUnset(request.operator)) {
            body["operator"] = request.operator;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmMailSend",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/mails/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmMailSendResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrmMailSendRequest
     * @return HrmMailSendResponse
     */
    async hrmMailSend(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmMailSendHeaders({});
        return await this.hrmMailSendWithOptions(request, headers, runtime);
    }
    /**
     * @summary 2.0Moka
     *
     * @param request HrmMokaEventRequest
     * @param headers HrmMokaEventHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmMokaEventResponse
     */
    async hrmMokaEventWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmMokaEvent",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/moka/events/forward`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmMokaEventResponse({}));
    }
    /**
     * @summary 2.0Moka
     *
     * @param request HrmMokaEventRequest
     * @return HrmMokaEventResponse
     */
    async hrmMokaEvent(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmMokaEventHeaders({});
        return await this.hrmMokaEventWithOptions(request, headers, runtime);
    }
    /**
     * @summary 2.0Moka
     *
     * @param request HrmMokaOapiRequest
     * @param headers HrmMokaOapiHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmMokaOapiResponse
     */
    async hrmMokaOapiWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiCode)) {
            body["apiCode"] = request.apiCode;
        }
        if (!tea_util_1.default.isUnset(request.params)) {
            body["params"] = request.params;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmMokaOapi",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/moka/forward`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmMokaOapiResponse({}));
    }
    /**
     * @summary 2.0Moka
     *
     * @param request HrmMokaOapiRequest
     * @return HrmMokaOapiResponse
     */
    async hrmMokaOapi(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmMokaOapiHeaders({});
        return await this.hrmMokaOapiWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrmProcessRegularRequest
     * @param headers HrmProcessRegularHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmProcessRegularResponse
     */
    async hrmProcessRegularWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operationId)) {
            body["operationId"] = request.operationId;
        }
        if (!tea_util_1.default.isUnset(request.regularDate)) {
            body["regularDate"] = request.regularDate;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessRegular",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/regulars/become`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessRegularResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrmProcessRegularRequest
     * @return HrmProcessRegularResponse
     */
    async hrmProcessRegular(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessRegularHeaders({});
        return await this.hrmProcessRegularWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrmProcessTransferRequest
     * @param headers HrmProcessTransferHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmProcessTransferResponse
     */
    async hrmProcessTransferWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptIdsAfterTransfer)) {
            body["deptIdsAfterTransfer"] = request.deptIdsAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.jobIdAfterTransfer)) {
            body["jobIdAfterTransfer"] = request.jobIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.mainDeptIdAfterTransfer)) {
            body["mainDeptIdAfterTransfer"] = request.mainDeptIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.operateUserId)) {
            body["operateUserId"] = request.operateUserId;
        }
        if (!tea_util_1.default.isUnset(request.positionIdAfterTransfer)) {
            body["positionIdAfterTransfer"] = request.positionIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.positionLevelAfterTransfer)) {
            body["positionLevelAfterTransfer"] = request.positionLevelAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.positionNameAfterTransfer)) {
            body["positionNameAfterTransfer"] = request.positionNameAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.rankIdAfterTransfer)) {
            body["rankIdAfterTransfer"] = request.rankIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessTransfer",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/transfer`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessTransferResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrmProcessTransferRequest
     * @return HrmProcessTransferResponse
     */
    async hrmProcessTransfer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessTransferHeaders({});
        return await this.hrmProcessTransferWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrmProcessUpdateTerminationInfoRequest
     * @param headers HrmProcessUpdateTerminationInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmProcessUpdateTerminationInfoResponse
     */
    async hrmProcessUpdateTerminationInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dismissionMemo)) {
            body["dismissionMemo"] = request.dismissionMemo;
        }
        if (!tea_util_1.default.isUnset(request.lastWorkDate)) {
            body["lastWorkDate"] = request.lastWorkDate;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessUpdateTerminationInfo",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/employees/terminations`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessUpdateTerminationInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrmProcessUpdateTerminationInfoRequest
     * @return HrmProcessUpdateTerminationInfoResponse
     */
    async hrmProcessUpdateTerminationInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessUpdateTerminationInfoHeaders({});
        return await this.hrmProcessUpdateTerminationInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary pts
     *
     * @param request HrmPtsServiceRequest
     * @param headers HrmPtsServiceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrmPtsServiceResponse
     */
    async hrmPtsServiceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.env)) {
            body["env"] = request.env;
        }
        if (!tea_util_1.default.isUnset(request.method)) {
            body["method"] = request.method;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.params)) {
            body["params"] = request.params;
        }
        if (!tea_util_1.default.isUnset(request.path)) {
            body["path"] = request.path;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmPtsService",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/pts/request`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmPtsServiceResponse({}));
    }
    /**
     * @summary pts
     *
     * @param request HrmPtsServiceRequest
     * @return HrmPtsServiceResponse
     */
    async hrmPtsService(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmPtsServiceHeaders({});
        return await this.hrmPtsServiceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MasterDataDeleteRequest
     * @param headers MasterDataDeleteHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MasterDataDeleteResponse
     */
    async masterDataDeleteWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            query["tenantId"] = request.tenantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataDelete",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/datas/batchRemove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataDeleteResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MasterDataDeleteRequest
     * @return MasterDataDeleteResponse
     */
    async masterDataDelete(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataDeleteHeaders({});
        return await this.masterDataDeleteWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MasterDataQueryRequest
     * @param headers MasterDataQueryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MasterDataQueryResponse
     */
    async masterDataQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizUK)) {
            body["bizUK"] = request.bizUK;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.queryParams)) {
            body["queryParams"] = request.queryParams;
        }
        if (!tea_util_1.default.isUnset(request.relationIds)) {
            body["relationIds"] = request.relationIds;
        }
        if (!tea_util_1.default.isUnset(request.scopeCode)) {
            body["scopeCode"] = request.scopeCode;
        }
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            body["tenantId"] = request.tenantId;
        }
        if (!tea_util_1.default.isUnset(request.viewEntityCode)) {
            body["viewEntityCode"] = request.viewEntityCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/datas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataQueryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MasterDataQueryRequest
     * @return MasterDataQueryResponse
     */
    async masterDataQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataQueryHeaders({});
        return await this.masterDataQueryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MasterDataSaveRequest
     * @param headers MasterDataSaveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MasterDataSaveResponse
     */
    async masterDataSaveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            query["tenantId"] = request.tenantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataSave",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/datas/save`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataSaveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MasterDataSaveRequest
     * @return MasterDataSaveResponse
     */
    async masterDataSave(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataSaveHeaders({});
        return await this.masterDataSaveWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MasterDataTenantQueyRequest
     * @param headers MasterDataTenantQueyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MasterDataTenantQueyResponse
     */
    async masterDataTenantQueyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.entityCode)) {
            query["entityCode"] = request.entityCode;
        }
        if (!tea_util_1.default.isUnset(request.scopeCode)) {
            query["scopeCode"] = request.scopeCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataTenantQuey",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/tenants`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataTenantQueyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MasterDataTenantQueyRequest
     * @return MasterDataTenantQueyResponse
     */
    async masterDataTenantQuey(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataTenantQueyHeaders({});
        return await this.masterDataTenantQueyWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MasterDatasQueryRequest
     * @param headers MasterDatasQueryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MasterDatasQueryResponse
     */
    async masterDatasQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizUK)) {
            body["bizUK"] = request.bizUK;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.queryParams)) {
            body["queryParams"] = request.queryParams;
        }
        if (!tea_util_1.default.isUnset(request.relationIds)) {
            body["relationIds"] = request.relationIds;
        }
        if (!tea_util_1.default.isUnset(request.scopeCode)) {
            body["scopeCode"] = request.scopeCode;
        }
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            body["tenantId"] = request.tenantId;
        }
        if (!tea_util_1.default.isUnset(request.viewEntityCode)) {
            body["viewEntityCode"] = request.viewEntityCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDatasQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masterDatas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDatasQueryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MasterDatasQueryRequest
     * @return MasterDatasQueryResponse
     */
    async masterDatasQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDatasQueryHeaders({});
        return await this.masterDatasQueryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCustomEntryProcessesRequest
     * @param headers QueryCustomEntryProcessesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCustomEntryProcessesResponse
     */
    async queryCustomEntryProcessesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operateUserId)) {
            query["operateUserId"] = request.operateUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCustomEntryProcesses",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/customEntryProcesses`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCustomEntryProcessesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCustomEntryProcessesRequest
     * @return QueryCustomEntryProcessesResponse
     */
    async queryCustomEntryProcesses(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCustomEntryProcessesHeaders({});
        return await this.queryCustomEntryProcessesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryDismissionStaffIdListRequest
     * @param headers QueryDismissionStaffIdListHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryDismissionStaffIdListResponse
     */
    async queryDismissionStaffIdListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDismissionStaffIdList",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/employees/dismissions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryDismissionStaffIdListResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryDismissionStaffIdListRequest
     * @return QueryDismissionStaffIdListResponse
     */
    async queryDismissionStaffIdList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryDismissionStaffIdListHeaders({});
        return await this.queryDismissionStaffIdListWithOptions(request, headers, runtime);
    }
    /**
     * @summary staffId
     *
     * @param tmpReq QueryHrmEmployeeDismissionInfoRequest
     * @param headers QueryHrmEmployeeDismissionInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryHrmEmployeeDismissionInfoResponse
     */
    async queryHrmEmployeeDismissionInfoWithOptions(tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new QueryHrmEmployeeDismissionInfoShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.userIdList)) {
            request.userIdListShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "userIdList", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.userIdListShrink)) {
            query["userIdList"] = request.userIdListShrink;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryHrmEmployeeDismissionInfo",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/employees/dimissionInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryHrmEmployeeDismissionInfoResponse({}));
    }
    /**
     * @summary staffId
     *
     * @param request QueryHrmEmployeeDismissionInfoRequest
     * @return QueryHrmEmployeeDismissionInfoResponse
     */
    async queryHrmEmployeeDismissionInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryHrmEmployeeDismissionInfoHeaders({});
        return await this.queryHrmEmployeeDismissionInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryJobRanksRequest
     * @param headers QueryJobRanksHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryJobRanksResponse
     */
    async queryJobRanksWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.rankCategoryId)) {
            query["rankCategoryId"] = request.rankCategoryId;
        }
        if (!tea_util_1.default.isUnset(request.rankCode)) {
            query["rankCode"] = request.rankCode;
        }
        if (!tea_util_1.default.isUnset(request.rankName)) {
            query["rankName"] = request.rankName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJobRanks",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/jobRanks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryJobRanksResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryJobRanksRequest
     * @return QueryJobRanksResponse
     */
    async queryJobRanks(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryJobRanksHeaders({});
        return await this.queryJobRanksWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryJobsRequest
     * @param headers QueryJobsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryJobsResponse
     */
    async queryJobsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobName)) {
            query["jobName"] = request.jobName;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJobs",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/jobs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryJobsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryJobsRequest
     * @return QueryJobsResponse
     */
    async queryJobs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryJobsHeaders({});
        return await this.queryJobsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryPositionsRequest
     * @param headers QueryPositionsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryPositionsResponse
     */
    async queryPositionsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptId)) {
            body["deptId"] = request.deptId;
        }
        if (!tea_util_1.default.isUnset(request.inCategoryIds)) {
            body["inCategoryIds"] = request.inCategoryIds;
        }
        if (!tea_util_1.default.isUnset(request.inPositionIds)) {
            body["inPositionIds"] = request.inPositionIds;
        }
        if (!tea_util_1.default.isUnset(request.positionName)) {
            body["positionName"] = request.positionName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryPositions",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/positions/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryPositionsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryPositionsRequest
     * @return QueryPositionsResponse
     */
    async queryPositions(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPositionsHeaders({});
        return await this.queryPositionsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RosterMetaAvailableFieldListRequest
     * @param headers RosterMetaAvailableFieldListHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RosterMetaAvailableFieldListResponse
     */
    async rosterMetaAvailableFieldListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            query["appAgentId"] = request.appAgentId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RosterMetaAvailableFieldList",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/rosters/meta/authorities/fields`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RosterMetaAvailableFieldListResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RosterMetaAvailableFieldListRequest
     * @return RosterMetaAvailableFieldListResponse
     */
    async rosterMetaAvailableFieldList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RosterMetaAvailableFieldListHeaders({});
        return await this.rosterMetaAvailableFieldListWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RosterMetaFieldOptionsUpdateRequest
     * @param headers RosterMetaFieldOptionsUpdateHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RosterMetaFieldOptionsUpdateResponse
     */
    async rosterMetaFieldOptionsUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            query["appAgentId"] = request.appAgentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldCode)) {
            body["fieldCode"] = request.fieldCode;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            body["groupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.labels)) {
            body["labels"] = request.labels;
        }
        if (!tea_util_1.default.isUnset(request.modifyType)) {
            body["modifyType"] = request.modifyType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RosterMetaFieldOptionsUpdate",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/rosters/meta/fields/options`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RosterMetaFieldOptionsUpdateResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RosterMetaFieldOptionsUpdateRequest
     * @return RosterMetaFieldOptionsUpdateResponse
     */
    async rosterMetaFieldOptionsUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RosterMetaFieldOptionsUpdateHeaders({});
        return await this.rosterMetaFieldOptionsUpdateWithOptions(request, headers, runtime);
    }
    /**
     * @summary ISV
     *
     * @param request SendIsvCardMessageRequest
     * @param headers SendIsvCardMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendIsvCardMessageResponse
     */
    async sendIsvCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            query["agentId"] = request.agentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIds)) {
            body["receiverUserIds"] = request.receiverUserIds;
        }
        if (!tea_util_1.default.isUnset(request.sceneType)) {
            body["sceneType"] = request.sceneType;
        }
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        if (!tea_util_1.default.isUnset(request.valueMap)) {
            body["valueMap"] = request.valueMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendIsvCardMessage",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/cardMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendIsvCardMessageResponse({}));
    }
    /**
     * @summary ISV
     *
     * @param request SendIsvCardMessageRequest
     * @return SendIsvCardMessageResponse
     */
    async sendIsvCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendIsvCardMessageHeaders({});
        return await this.sendIsvCardMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SolutionTaskInitRequest
     * @param headers SolutionTaskInitHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SolutionTaskInitResponse
     */
    async solutionTaskInitWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            body["category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.claimTime)) {
            body["claimTime"] = request.claimTime;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.finishTime)) {
            body["finishTime"] = request.finishTime;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SolutionTaskInit",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/init`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SolutionTaskInitResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SolutionTaskInitRequest
     * @return SolutionTaskInitResponse
     */
    async solutionTaskInit(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SolutionTaskInitHeaders({});
        return await this.solutionTaskInitWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SolutionTaskSaveRequest
     * @param headers SolutionTaskSaveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SolutionTaskSaveResponse
     */
    async solutionTaskSaveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.claimTime)) {
            body["claimTime"] = request.claimTime;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.finishTime)) {
            body["finishTime"] = request.finishTime;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.solutionInstanceId)) {
            body["solutionInstanceId"] = request.solutionInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            body["taskType"] = request.taskType;
        }
        if (!tea_util_1.default.isUnset(request.templateOuterId)) {
            body["templateOuterId"] = request.templateOuterId;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SolutionTaskSave",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/save`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SolutionTaskSaveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SolutionTaskSaveRequest
     * @return SolutionTaskSaveResponse
     */
    async solutionTaskSave(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SolutionTaskSaveHeaders({});
        return await this.solutionTaskSaveWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SyncTaskTemplateRequest
     * @param headers SyncTaskTemplateHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SyncTaskTemplateResponse
     */
    async syncTaskTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.delete)) {
            body["delete"] = request.delete;
        }
        if (!tea_util_1.default.isUnset(request.des)) {
            body["des"] = request.des;
        }
        if (!tea_util_1.default.isUnset(request.ext)) {
            body["ext"] = request.ext;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.taskScopeVO)) {
            body["taskScopeVO"] = request.taskScopeVO;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            body["taskType"] = request.taskType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncTaskTemplate",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/templates/sync`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncTaskTemplateResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SyncTaskTemplateRequest
     * @return SyncTaskTemplateResponse
     */
    async syncTaskTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncTaskTemplateHeaders({});
        return await this.syncTaskTemplateWithOptions(request, headers, runtime);
    }
    /**
     * @summary ISV
     *
     * @param request UpdateIsvCardMessageRequest
     * @param headers UpdateIsvCardMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateIsvCardMessageResponse
     */
    async updateIsvCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            query["agentId"] = request.agentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.sceneType)) {
            body["sceneType"] = request.sceneType;
        }
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.valueMap)) {
            body["valueMap"] = request.valueMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateIsvCardMessage",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/cardMessages`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateIsvCardMessageResponse({}));
    }
    /**
     * @summary ISV
     *
     * @param request UpdateIsvCardMessageRequest
     * @return UpdateIsvCardMessageResponse
     */
    async updateIsvCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateIsvCardMessageHeaders({});
        return await this.updateIsvCardMessageWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map