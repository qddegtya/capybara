"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPersonalAuthRuleResponseBodyResult = exports.GetAuthInfoResponseBodyAuthUserInfo = exports.GetAuthInfoResponseBodyAuthCorpInfo = exports.GetAuthInfoResponseBodyAuthAppInfo = exports.GetAuthInfoResponseBodyAuthAppInfoAgentList = exports.GetUserTokenResponse = exports.GetUserTokenResponseBody = exports.GetUserTokenRequest = exports.GetTokenResponse = exports.GetTokenResponseBody = exports.GetTokenRequest = exports.GetSuiteAccessTokenResponse = exports.GetSuiteAccessTokenResponseBody = exports.GetSuiteAccessTokenRequest = exports.GetSsoUserInfoResponse = exports.GetSsoUserInfoResponseBody = exports.GetSsoUserInfoRequest = exports.GetSsoUserInfoHeaders = exports.GetSsoAccessTokenResponse = exports.GetSsoAccessTokenResponseBody = exports.GetSsoAccessTokenRequest = exports.GetPersonalAuthRuleResponse = exports.GetPersonalAuthRuleResponseBody = exports.GetPersonalAuthRuleHeaders = exports.GetCorpAccessTokenResponse = exports.GetCorpAccessTokenResponseBody = exports.GetCorpAccessTokenRequest = exports.GetAuthInfoResponse = exports.GetAuthInfoResponseBody = exports.GetAuthInfoRequest = exports.GetAuthInfoHeaders = exports.GetAccessTokenResponse = exports.GetAccessTokenResponseBody = exports.GetAccessTokenRequest = exports.CreateJsapiTicketResponse = exports.CreateJsapiTicketResponseBody = exports.CreateJsapiTicketHeaders = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CreateJsapiTicketHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateJsapiTicketHeaders = CreateJsapiTicketHeaders;
class CreateJsapiTicketResponseBody extends $tea.Model {
    static names() {
        return {
            expireIn: 'expireIn',
            jsapiTicket: 'jsapiTicket',
        };
    }
    static types() {
        return {
            expireIn: 'number',
            jsapiTicket: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateJsapiTicketResponseBody = CreateJsapiTicketResponseBody;
class CreateJsapiTicketResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateJsapiTicketResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateJsapiTicketResponse = CreateJsapiTicketResponse;
class GetAccessTokenRequest extends $tea.Model {
    static names() {
        return {
            appKey: 'appKey',
            appSecret: 'appSecret',
        };
    }
    static types() {
        return {
            appKey: 'string',
            appSecret: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAccessTokenRequest = GetAccessTokenRequest;
class GetAccessTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'accessToken',
            expireIn: 'expireIn',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            expireIn: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAccessTokenResponseBody = GetAccessTokenResponseBody;
class GetAccessTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAccessTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAccessTokenResponse = GetAccessTokenResponse;
class GetAuthInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoHeaders = GetAuthInfoHeaders;
class GetAuthInfoRequest extends $tea.Model {
    static names() {
        return {
            authCorpId: 'authCorpId',
        };
    }
    static types() {
        return {
            authCorpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoRequest = GetAuthInfoRequest;
class GetAuthInfoResponseBody extends $tea.Model {
    static names() {
        return {
            authAppInfo: 'authAppInfo',
            authCorpInfo: 'authCorpInfo',
            authUserInfo: 'authUserInfo',
        };
    }
    static types() {
        return {
            authAppInfo: GetAuthInfoResponseBodyAuthAppInfo,
            authCorpInfo: GetAuthInfoResponseBodyAuthCorpInfo,
            authUserInfo: GetAuthInfoResponseBodyAuthUserInfo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponseBody = GetAuthInfoResponseBody;
class GetAuthInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAuthInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponse = GetAuthInfoResponse;
class GetCorpAccessTokenRequest extends $tea.Model {
    static names() {
        return {
            authCorpId: 'authCorpId',
            suiteKey: 'suiteKey',
            suiteSecret: 'suiteSecret',
            suiteTicket: 'suiteTicket',
        };
    }
    static types() {
        return {
            authCorpId: 'string',
            suiteKey: 'string',
            suiteSecret: 'string',
            suiteTicket: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCorpAccessTokenRequest = GetCorpAccessTokenRequest;
class GetCorpAccessTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'accessToken',
            expireIn: 'expireIn',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            expireIn: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCorpAccessTokenResponseBody = GetCorpAccessTokenResponseBody;
class GetCorpAccessTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCorpAccessTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetCorpAccessTokenResponse = GetCorpAccessTokenResponse;
class GetPersonalAuthRuleHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPersonalAuthRuleHeaders = GetPersonalAuthRuleHeaders;
class GetPersonalAuthRuleResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetPersonalAuthRuleResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPersonalAuthRuleResponseBody = GetPersonalAuthRuleResponseBody;
class GetPersonalAuthRuleResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPersonalAuthRuleResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPersonalAuthRuleResponse = GetPersonalAuthRuleResponse;
class GetSsoAccessTokenRequest extends $tea.Model {
    static names() {
        return {
            corpid: 'corpid',
            ssoSecret: 'ssoSecret',
        };
    }
    static types() {
        return {
            corpid: 'string',
            ssoSecret: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoAccessTokenRequest = GetSsoAccessTokenRequest;
class GetSsoAccessTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'accessToken',
            expireIn: 'expireIn',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            expireIn: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoAccessTokenResponseBody = GetSsoAccessTokenResponseBody;
class GetSsoAccessTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSsoAccessTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoAccessTokenResponse = GetSsoAccessTokenResponse;
class GetSsoUserInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoUserInfoHeaders = GetSsoUserInfoHeaders;
class GetSsoUserInfoRequest extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoUserInfoRequest = GetSsoUserInfoRequest;
class GetSsoUserInfoResponseBody extends $tea.Model {
    static names() {
        return {
            avatar: 'avatar',
            corpId: 'corpId',
            corpName: 'corpName',
            email: 'email',
            isAdmin: 'isAdmin',
            userId: 'userId',
            userName: 'userName',
        };
    }
    static types() {
        return {
            avatar: 'string',
            corpId: 'string',
            corpName: 'string',
            email: 'string',
            isAdmin: 'boolean',
            userId: 'string',
            userName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoUserInfoResponseBody = GetSsoUserInfoResponseBody;
class GetSsoUserInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSsoUserInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSsoUserInfoResponse = GetSsoUserInfoResponse;
class GetSuiteAccessTokenRequest extends $tea.Model {
    static names() {
        return {
            suiteKey: 'suiteKey',
            suiteSecret: 'suiteSecret',
            suiteTicket: 'suiteTicket',
        };
    }
    static types() {
        return {
            suiteKey: 'string',
            suiteSecret: 'string',
            suiteTicket: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSuiteAccessTokenRequest = GetSuiteAccessTokenRequest;
class GetSuiteAccessTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'accessToken',
            expireIn: 'expireIn',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            expireIn: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSuiteAccessTokenResponseBody = GetSuiteAccessTokenResponseBody;
class GetSuiteAccessTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSuiteAccessTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSuiteAccessTokenResponse = GetSuiteAccessTokenResponse;
class GetTokenRequest extends $tea.Model {
    static names() {
        return {
            clientId: 'client_id',
            clientSecret: 'client_secret',
            grantType: 'grant_type',
        };
    }
    static types() {
        return {
            clientId: 'string',
            clientSecret: 'string',
            grantType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTokenRequest = GetTokenRequest;
class GetTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'access_token',
            expiresIn: 'expires_in',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            expiresIn: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTokenResponseBody = GetTokenResponseBody;
class GetTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTokenResponse = GetTokenResponse;
class GetUserTokenRequest extends $tea.Model {
    static names() {
        return {
            clientId: 'clientId',
            clientSecret: 'clientSecret',
            code: 'code',
            grantType: 'grantType',
            refreshToken: 'refreshToken',
        };
    }
    static types() {
        return {
            clientId: 'string',
            clientSecret: 'string',
            code: 'string',
            grantType: 'string',
            refreshToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserTokenRequest = GetUserTokenRequest;
class GetUserTokenResponseBody extends $tea.Model {
    static names() {
        return {
            accessToken: 'accessToken',
            corpId: 'corpId',
            expireIn: 'expireIn',
            refreshToken: 'refreshToken',
        };
    }
    static types() {
        return {
            accessToken: 'string',
            corpId: 'string',
            expireIn: 'number',
            refreshToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserTokenResponseBody = GetUserTokenResponseBody;
class GetUserTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserTokenResponse = GetUserTokenResponse;
class GetAuthInfoResponseBodyAuthAppInfoAgentList extends $tea.Model {
    static names() {
        return {
            adminList: 'adminList',
            agentId: 'agentId',
            agentName: 'agentName',
            appId: 'appId',
        };
    }
    static types() {
        return {
            adminList: { 'type': 'array', 'itemType': 'string' },
            agentId: 'number',
            agentName: 'string',
            appId: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponseBodyAuthAppInfoAgentList = GetAuthInfoResponseBodyAuthAppInfoAgentList;
class GetAuthInfoResponseBodyAuthAppInfo extends $tea.Model {
    static names() {
        return {
            agentList: 'agentList',
        };
    }
    static types() {
        return {
            agentList: { 'type': 'array', 'itemType': GetAuthInfoResponseBodyAuthAppInfoAgentList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponseBodyAuthAppInfo = GetAuthInfoResponseBodyAuthAppInfo;
class GetAuthInfoResponseBodyAuthCorpInfo extends $tea.Model {
    static names() {
        return {
            authChannel: 'authChannel',
            authChannelType: 'authChannelType',
            authLevel: 'authLevel',
            corpLogoUrl: 'corpLogoUrl',
            corpName: 'corpName',
            industry: 'industry',
            inviteCode: 'inviteCode',
            inviteUrl: 'inviteUrl',
            licenseCode: 'licenseCode',
        };
    }
    static types() {
        return {
            authChannel: 'string',
            authChannelType: 'string',
            authLevel: 'number',
            corpLogoUrl: 'string',
            corpName: 'string',
            industry: 'string',
            inviteCode: 'string',
            inviteUrl: 'string',
            licenseCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponseBodyAuthCorpInfo = GetAuthInfoResponseBodyAuthCorpInfo;
class GetAuthInfoResponseBodyAuthUserInfo extends $tea.Model {
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAuthInfoResponseBodyAuthUserInfo = GetAuthInfoResponseBodyAuthUserInfo;
class GetPersonalAuthRuleResponseBodyResult extends $tea.Model {
    static names() {
        return {
            authItems: 'authItems',
            resource: 'resource',
        };
    }
    static types() {
        return {
            authItems: { 'type': 'array', 'itemType': 'string' },
            resource: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPersonalAuthRuleResponseBodyResult = GetPersonalAuthRuleResponseBodyResult;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._signatureAlgorithm = "v2";
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 生成jsapi ticket
     *
     * @param headers CreateJsapiTicketHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateJsapiTicketResponse
     */
    async createJsapiTicketWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "CreateJsapiTicket",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/jsapiTickets`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateJsapiTicketResponse({}));
    }
    /**
     * @summary 生成jsapi ticket
     *
     * @return CreateJsapiTicketResponse
     */
    async createJsapiTicket() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateJsapiTicketHeaders({});
        return await this.createJsapiTicketWithOptions(headers, runtime);
    }
    /**
     * @summary 获取企业accessToken(企业内部应用)
     *
     * @param request GetAccessTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetAccessTokenResponse
     */
    async getAccessTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appKey)) {
            body["appKey"] = request.appKey;
        }
        if (!tea_util_1.default.isUnset(request.appSecret)) {
            body["appSecret"] = request.appSecret;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetAccessToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/accessToken`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAccessTokenResponse({}));
    }
    /**
     * @summary 获取企业accessToken(企业内部应用)
     *
     * @param request GetAccessTokenRequest
     * @return GetAccessTokenResponse
     */
    async getAccessToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getAccessTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取企业开通应用后的授权信息
     *
     * @param request GetAuthInfoRequest
     * @param headers GetAuthInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetAuthInfoResponse
     */
    async getAuthInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.authCorpId)) {
            query["authCorpId"] = request.authCorpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAuthInfo",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/apps/authInfo`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAuthInfoResponse({}));
    }
    /**
     * @summary 获取企业开通应用后的授权信息
     *
     * @param request GetAuthInfoRequest
     * @return GetAuthInfoResponse
     */
    async getAuthInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAuthInfoHeaders({});
        return await this.getAuthInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取企业accessToken(应用商店应用)
     *
     * @param request GetCorpAccessTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetCorpAccessTokenResponse
     */
    async getCorpAccessTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.authCorpId)) {
            body["authCorpId"] = request.authCorpId;
        }
        if (!tea_util_1.default.isUnset(request.suiteKey)) {
            body["suiteKey"] = request.suiteKey;
        }
        if (!tea_util_1.default.isUnset(request.suiteSecret)) {
            body["suiteSecret"] = request.suiteSecret;
        }
        if (!tea_util_1.default.isUnset(request.suiteTicket)) {
            body["suiteTicket"] = request.suiteTicket;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetCorpAccessToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/corpAccessToken`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCorpAccessTokenResponse({}));
    }
    /**
     * @summary 获取企业accessToken(应用商店应用)
     *
     * @param request GetCorpAccessTokenRequest
     * @return GetCorpAccessTokenResponse
     */
    async getCorpAccessToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getCorpAccessTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary 查询个人授权记录
     *
     * @param headers GetPersonalAuthRuleHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetPersonalAuthRuleResponse
     */
    async getPersonalAuthRuleWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetPersonalAuthRule",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/authRules/user`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetPersonalAuthRuleResponse({}));
    }
    /**
     * @summary 查询个人授权记录
     *
     * @return GetPersonalAuthRuleResponse
     */
    async getPersonalAuthRule() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPersonalAuthRuleHeaders({});
        return await this.getPersonalAuthRuleWithOptions(headers, runtime);
    }
    /**
     * @summary 生成微应用管理后台accessToken
     *
     * @param request GetSsoAccessTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetSsoAccessTokenResponse
     */
    async getSsoAccessTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.corpid)) {
            body["corpid"] = request.corpid;
        }
        if (!tea_util_1.default.isUnset(request.ssoSecret)) {
            body["ssoSecret"] = request.ssoSecret;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSsoAccessToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/ssoAccessToken`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSsoAccessTokenResponse({}));
    }
    /**
     * @summary 生成微应用管理后台accessToken
     *
     * @param request GetSsoAccessTokenRequest
     * @return GetSsoAccessTokenResponse
     */
    async getSsoAccessToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getSsoAccessTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary 查询微应用后台免登的用户信息
     *
     * @param request GetSsoUserInfoRequest
     * @param headers GetSsoUserInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetSsoUserInfoResponse
     */
    async getSsoUserInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.code)) {
            query["code"] = request.code;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSsoUserInfo",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/ssoUserInfo`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSsoUserInfoResponse({}));
    }
    /**
     * @summary 查询微应用后台免登的用户信息
     *
     * @param request GetSsoUserInfoRequest
     * @return GetSsoUserInfoResponse
     */
    async getSsoUserInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSsoUserInfoHeaders({});
        return await this.getSsoUserInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取isvAccessToken（三方企业应用）
     *
     * @param request GetSuiteAccessTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetSuiteAccessTokenResponse
     */
    async getSuiteAccessTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.suiteKey)) {
            body["suiteKey"] = request.suiteKey;
        }
        if (!tea_util_1.default.isUnset(request.suiteSecret)) {
            body["suiteSecret"] = request.suiteSecret;
        }
        if (!tea_util_1.default.isUnset(request.suiteTicket)) {
            body["suiteTicket"] = request.suiteTicket;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSuiteAccessToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/suiteAccessToken`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSuiteAccessTokenResponse({}));
    }
    /**
     * @summary 获取isvAccessToken（三方企业应用）
     *
     * @param request GetSuiteAccessTokenRequest
     * @return GetSuiteAccessTokenResponse
     */
    async getSuiteAccessToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getSuiteAccessTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取Access Token
     *
     * @param request GetTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetTokenResponse
     */
    async getTokenWithOptions(corpId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.clientId)) {
            body["client_id"] = request.clientId;
        }
        if (!tea_util_1.default.isUnset(request.clientSecret)) {
            body["client_secret"] = request.clientSecret;
        }
        if (!tea_util_1.default.isUnset(request.grantType)) {
            body["grant_type"] = request.grantType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/${corpId}/token`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTokenResponse({}));
    }
    /**
     * @summary 获取Access Token
     *
     * @param request GetTokenRequest
     * @return GetTokenResponse
     */
    async getToken(corpId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getTokenWithOptions(corpId, request, headers, runtime);
    }
    /**
     * @summary 获取用户token
     *
     * @param request GetUserTokenRequest
     * @param headers map
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetUserTokenResponse
     */
    async getUserTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.clientId)) {
            body["clientId"] = request.clientId;
        }
        if (!tea_util_1.default.isUnset(request.clientSecret)) {
            body["clientSecret"] = request.clientSecret;
        }
        if (!tea_util_1.default.isUnset(request.code)) {
            body["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.grantType)) {
            body["grantType"] = request.grantType;
        }
        if (!tea_util_1.default.isUnset(request.refreshToken)) {
            body["refreshToken"] = request.refreshToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetUserToken",
            version: "oauth2_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/oauth2/userAccessToken`,
            method: "POST",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserTokenResponse({}));
    }
    /**
     * @summary 获取用户token
     *
     * @param request GetUserTokenRequest
     * @return GetUserTokenResponse
     */
    async getUserToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getUserTokenWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map