"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateOfficialAccountRobotInfoRequest = exports.UpdateOfficialAccountRobotInfoHeaders = exports.ReplyRobotResponse = exports.ReplyRobotResponseBody = exports.ReplyRobotRequest = exports.ReplyRobotHeaders = exports.PushRobotMessageResponse = exports.PushRobotMessageResponseBody = exports.PushRobotMessageRequest = exports.PushRobotMessageHeaders = exports.PushOfficialAccountMessageResponse = exports.PushOfficialAccountMessageResponseBody = exports.PushOfficialAccountMessageRequest = exports.PushOfficialAccountMessageHeaders = exports.PushIntelligentRobotMessageResponse = exports.PushIntelligentRobotMessageResponseBody = exports.PushIntelligentRobotMessageRequest = exports.PushIntelligentRobotMessageHeaders = exports.PushIntelligentRobotGroupMessageResponse = exports.PushIntelligentRobotGroupMessageResponseBody = exports.PushIntelligentRobotGroupMessageRequest = exports.PushIntelligentRobotGroupMessageHeaders = exports.PushCustomerGroupMessageResponse = exports.PushCustomerGroupMessageResponseBody = exports.PushCustomerGroupMessageRequest = exports.PushCustomerGroupMessageHeaders = exports.GetWebChannelUserTokenResponse = exports.GetWebChannelUserTokenResponseBody = exports.GetWebChannelUserTokenRequest = exports.GetWebChannelUserTokenHeaders = exports.GetOfficialAccountRobotInfoResponse = exports.GetOfficialAccountRobotInfoResponseBody = exports.GetOfficialAccountRobotInfoRequest = exports.GetOfficialAccountRobotInfoHeaders = exports.GetIntelligentRobotInfoResponse = exports.GetIntelligentRobotInfoResponseBody = exports.GetIntelligentRobotInfoRequest = exports.GetIntelligentRobotInfoHeaders = exports.GetDingMeBaseDataResponse = exports.GetDingMeBaseDataResponseBody = exports.GetDingMeBaseDataRequest = exports.GetDingMeBaseDataHeaders = exports.AskRobotResponse = exports.AskRobotResponseBody = exports.AskRobotRequest = exports.AskRobotHeaders = exports.AddRobotInstanceToGroupResponse = exports.AddRobotInstanceToGroupResponseBody = exports.AddRobotInstanceToGroupRequest = exports.AddRobotInstanceToGroupHeaders = void 0;
exports.UpdateOfficialAccountRobotInfoResponse = exports.UpdateOfficialAccountRobotInfoResponseBody = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddRobotInstanceToGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotInstanceToGroupHeaders = AddRobotInstanceToGroupHeaders;
class AddRobotInstanceToGroupRequest extends $tea.Model {
    static names() {
        return {
            chatbotId: 'chatbotId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotInstanceToGroupRequest = AddRobotInstanceToGroupRequest;
class AddRobotInstanceToGroupResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotInstanceToGroupResponseBody = AddRobotInstanceToGroupResponseBody;
class AddRobotInstanceToGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddRobotInstanceToGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotInstanceToGroupResponse = AddRobotInstanceToGroupResponse;
class AskRobotHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AskRobotHeaders = AskRobotHeaders;
class AskRobotRequest extends $tea.Model {
    static names() {
        return {
            dingUserId: 'dingUserId',
            question: 'question',
            robotAppKey: 'robotAppKey',
            sessionUuid: 'sessionUuid',
        };
    }
    static types() {
        return {
            dingUserId: 'string',
            question: 'string',
            robotAppKey: 'string',
            sessionUuid: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AskRobotRequest = AskRobotRequest;
class AskRobotResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AskRobotResponseBody = AskRobotResponseBody;
class AskRobotResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AskRobotResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AskRobotResponse = AskRobotResponse;
class GetDingMeBaseDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDingMeBaseDataHeaders = GetDingMeBaseDataHeaders;
class GetDingMeBaseDataRequest extends $tea.Model {
    static names() {
        return {
            appKey: 'appKey',
            byDay: 'byDay',
            endDay: 'endDay',
            startDay: 'startDay',
        };
    }
    static types() {
        return {
            appKey: 'string',
            byDay: 'boolean',
            endDay: 'string',
            startDay: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDingMeBaseDataRequest = GetDingMeBaseDataRequest;
class GetDingMeBaseDataResponseBody extends $tea.Model {
    static names() {
        return {
            fromCache: 'fromCache',
            rawset: 'rawset',
            runtime: 'runtime',
            tips: 'tips',
        };
    }
    static types() {
        return {
            fromCache: 'boolean',
            rawset: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
            runtime: 'number',
            tips: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDingMeBaseDataResponseBody = GetDingMeBaseDataResponseBody;
class GetDingMeBaseDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDingMeBaseDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDingMeBaseDataResponse = GetDingMeBaseDataResponse;
class GetIntelligentRobotInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIntelligentRobotInfoHeaders = GetIntelligentRobotInfoHeaders;
class GetIntelligentRobotInfoRequest extends $tea.Model {
    static names() {
        return {
            robotAppKey: 'robotAppKey',
        };
    }
    static types() {
        return {
            robotAppKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIntelligentRobotInfoRequest = GetIntelligentRobotInfoRequest;
class GetIntelligentRobotInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIntelligentRobotInfoResponseBody = GetIntelligentRobotInfoResponseBody;
class GetIntelligentRobotInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetIntelligentRobotInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIntelligentRobotInfoResponse = GetIntelligentRobotInfoResponse;
class GetOfficialAccountRobotInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOfficialAccountRobotInfoHeaders = GetOfficialAccountRobotInfoHeaders;
class GetOfficialAccountRobotInfoRequest extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOfficialAccountRobotInfoRequest = GetOfficialAccountRobotInfoRequest;
class GetOfficialAccountRobotInfoResponseBody extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            brief: 'brief',
            description: 'description',
            icon: 'icon',
            name: 'name',
            previewMediaUrl: 'previewMediaUrl',
        };
    }
    static types() {
        return {
            appId: 'number',
            brief: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
            previewMediaUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOfficialAccountRobotInfoResponseBody = GetOfficialAccountRobotInfoResponseBody;
class GetOfficialAccountRobotInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOfficialAccountRobotInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetOfficialAccountRobotInfoResponse = GetOfficialAccountRobotInfoResponse;
class GetWebChannelUserTokenHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWebChannelUserTokenHeaders = GetWebChannelUserTokenHeaders;
class GetWebChannelUserTokenRequest extends $tea.Model {
    static names() {
        return {
            foreignId: 'foreignId',
            nick: 'nick',
            source: 'source',
        };
    }
    static types() {
        return {
            foreignId: 'string',
            nick: 'string',
            source: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWebChannelUserTokenRequest = GetWebChannelUserTokenRequest;
class GetWebChannelUserTokenResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWebChannelUserTokenResponseBody = GetWebChannelUserTokenResponseBody;
class GetWebChannelUserTokenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWebChannelUserTokenResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWebChannelUserTokenResponse = GetWebChannelUserTokenResponse;
class PushCustomerGroupMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushCustomerGroupMessageHeaders = PushCustomerGroupMessageHeaders;
class PushCustomerGroupMessageRequest extends $tea.Model {
    static names() {
        return {
            conversationId: 'conversationId',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            msgKey: 'string',
            msgParam: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushCustomerGroupMessageRequest = PushCustomerGroupMessageRequest;
class PushCustomerGroupMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushCustomerGroupMessageResponseBody = PushCustomerGroupMessageResponseBody;
class PushCustomerGroupMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushCustomerGroupMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushCustomerGroupMessageResponse = PushCustomerGroupMessageResponse;
class PushIntelligentRobotGroupMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotGroupMessageHeaders = PushIntelligentRobotGroupMessageHeaders;
class PushIntelligentRobotGroupMessageRequest extends $tea.Model {
    static names() {
        return {
            chatbotId: 'chatbotId',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            msgKey: 'string',
            msgParam: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotGroupMessageRequest = PushIntelligentRobotGroupMessageRequest;
class PushIntelligentRobotGroupMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotGroupMessageResponseBody = PushIntelligentRobotGroupMessageResponseBody;
class PushIntelligentRobotGroupMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushIntelligentRobotGroupMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotGroupMessageResponse = PushIntelligentRobotGroupMessageResponse;
class PushIntelligentRobotMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotMessageHeaders = PushIntelligentRobotMessageHeaders;
class PushIntelligentRobotMessageRequest extends $tea.Model {
    static names() {
        return {
            chatbotId: 'chatbotId',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            userId: 'userId',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            msgKey: 'string',
            msgParam: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotMessageRequest = PushIntelligentRobotMessageRequest;
class PushIntelligentRobotMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotMessageResponseBody = PushIntelligentRobotMessageResponseBody;
class PushIntelligentRobotMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushIntelligentRobotMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushIntelligentRobotMessageResponse = PushIntelligentRobotMessageResponse;
class PushOfficialAccountMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushOfficialAccountMessageHeaders = PushOfficialAccountMessageHeaders;
class PushOfficialAccountMessageRequest extends $tea.Model {
    static names() {
        return {
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            userId: 'userId',
        };
    }
    static types() {
        return {
            msgKey: 'string',
            msgParam: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushOfficialAccountMessageRequest = PushOfficialAccountMessageRequest;
class PushOfficialAccountMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushOfficialAccountMessageResponseBody = PushOfficialAccountMessageResponseBody;
class PushOfficialAccountMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushOfficialAccountMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushOfficialAccountMessageResponse = PushOfficialAccountMessageResponse;
class PushRobotMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushRobotMessageHeaders = PushRobotMessageHeaders;
class PushRobotMessageRequest extends $tea.Model {
    static names() {
        return {
            chatbotId: 'chatbotId',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            userId: 'userId',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            msgKey: 'string',
            msgParam: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushRobotMessageRequest = PushRobotMessageRequest;
class PushRobotMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushRobotMessageResponseBody = PushRobotMessageResponseBody;
class PushRobotMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PushRobotMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PushRobotMessageResponse = PushRobotMessageResponse;
class ReplyRobotHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReplyRobotHeaders = ReplyRobotHeaders;
class ReplyRobotRequest extends $tea.Model {
    static names() {
        return {
            proxyMessageStr: 'proxyMessageStr',
        };
    }
    static types() {
        return {
            proxyMessageStr: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReplyRobotRequest = ReplyRobotRequest;
class ReplyRobotResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReplyRobotResponseBody = ReplyRobotResponseBody;
class ReplyRobotResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReplyRobotResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReplyRobotResponse = ReplyRobotResponse;
class UpdateOfficialAccountRobotInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateOfficialAccountRobotInfoHeaders = UpdateOfficialAccountRobotInfoHeaders;
class UpdateOfficialAccountRobotInfoRequest extends $tea.Model {
    static names() {
        return {
            avatar: 'avatar',
            brief: 'brief',
            description: 'description',
            name: 'name',
            previewMediaUrl: 'previewMediaUrl',
            type: 'type',
        };
    }
    static types() {
        return {
            avatar: 'string',
            brief: 'string',
            description: 'string',
            name: 'string',
            previewMediaUrl: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateOfficialAccountRobotInfoRequest = UpdateOfficialAccountRobotInfoRequest;
class UpdateOfficialAccountRobotInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateOfficialAccountRobotInfoResponseBody = UpdateOfficialAccountRobotInfoResponseBody;
class UpdateOfficialAccountRobotInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateOfficialAccountRobotInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateOfficialAccountRobotInfoResponse = UpdateOfficialAccountRobotInfoResponse;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 添加智能客服机器人到钉钉群
     *
     * @param request AddRobotInstanceToGroupRequest
     * @param headers AddRobotInstanceToGroupHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddRobotInstanceToGroupResponse
     */
    async addRobotInstanceToGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddRobotInstanceToGroup",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/intelligentRobots/groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddRobotInstanceToGroupResponse({}));
    }
    /**
     * @summary 添加智能客服机器人到钉钉群
     *
     * @param request AddRobotInstanceToGroupRequest
     * @return AddRobotInstanceToGroupResponse
     */
    async addRobotInstanceToGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddRobotInstanceToGroupHeaders({});
        return await this.addRobotInstanceToGroupWithOptions(request, headers, runtime);
    }
    /**
     * @summary 调用小蜜机器人的问答能力
     *
     * @param request AskRobotRequest
     * @param headers AskRobotHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AskRobotResponse
     */
    async askRobotWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dingUserId)) {
            body["dingUserId"] = request.dingUserId;
        }
        if (!tea_util_1.default.isUnset(request.question)) {
            body["question"] = request.question;
        }
        if (!tea_util_1.default.isUnset(request.robotAppKey)) {
            body["robotAppKey"] = request.robotAppKey;
        }
        if (!tea_util_1.default.isUnset(request.sessionUuid)) {
            body["sessionUuid"] = request.sessionUuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AskRobot",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/robots/ask`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AskRobotResponse({}));
    }
    /**
     * @summary 调用小蜜机器人的问答能力
     *
     * @param request AskRobotRequest
     * @return AskRobotResponse
     */
    async askRobot(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AskRobotHeaders({});
        return await this.askRobotWithOptions(request, headers, runtime);
    }
    /**
     * @summary 小蜜机器人数据统计指标
     *
     * @param request GetDingMeBaseDataRequest
     * @param headers GetDingMeBaseDataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetDingMeBaseDataResponse
     */
    async getDingMeBaseDataWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appKey)) {
            query["appKey"] = request.appKey;
        }
        if (!tea_util_1.default.isUnset(request.byDay)) {
            query["byDay"] = request.byDay;
        }
        if (!tea_util_1.default.isUnset(request.endDay)) {
            query["endDay"] = request.endDay;
        }
        if (!tea_util_1.default.isUnset(request.startDay)) {
            query["startDay"] = request.startDay;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDingMeBaseData",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/robots/data`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDingMeBaseDataResponse({}));
    }
    /**
     * @summary 小蜜机器人数据统计指标
     *
     * @param request GetDingMeBaseDataRequest
     * @return GetDingMeBaseDataResponse
     */
    async getDingMeBaseData(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDingMeBaseDataHeaders({});
        return await this.getDingMeBaseDataWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取智能客服机器人信息
     *
     * @param request GetIntelligentRobotInfoRequest
     * @param headers GetIntelligentRobotInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetIntelligentRobotInfoResponse
     */
    async getIntelligentRobotInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.robotAppKey)) {
            query["robotAppKey"] = request.robotAppKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetIntelligentRobotInfo",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/intelligentRobots/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetIntelligentRobotInfoResponse({}));
    }
    /**
     * @summary 获取智能客服机器人信息
     *
     * @param request GetIntelligentRobotInfoRequest
     * @return GetIntelligentRobotInfoResponse
     */
    async getIntelligentRobotInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetIntelligentRobotInfoHeaders({});
        return await this.getIntelligentRobotInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 获取服务窗机器人信息
     *
     * @param request GetOfficialAccountRobotInfoRequest
     * @param headers GetOfficialAccountRobotInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetOfficialAccountRobotInfoResponse
     */
    async getOfficialAccountRobotInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOfficialAccountRobotInfo",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/officialAccounts/robots`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOfficialAccountRobotInfoResponse({}));
    }
    /**
     * @summary 获取服务窗机器人信息
     *
     * @param request GetOfficialAccountRobotInfoRequest
     * @return GetOfficialAccountRobotInfoResponse
     */
    async getOfficialAccountRobotInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOfficialAccountRobotInfoHeaders({});
        return await this.getOfficialAccountRobotInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 小蜜客服网页渠道获取三方用户token
     *
     * @param request GetWebChannelUserTokenRequest
     * @param headers GetWebChannelUserTokenHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWebChannelUserTokenResponse
     */
    async getWebChannelUserTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.foreignId)) {
            body["foreignId"] = request.foreignId;
        }
        if (!tea_util_1.default.isUnset(request.nick)) {
            body["nick"] = request.nick;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetWebChannelUserToken",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/webChannels/userTokens`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWebChannelUserTokenResponse({}));
    }
    /**
     * @summary 小蜜客服网页渠道获取三方用户token
     *
     * @param request GetWebChannelUserTokenRequest
     * @return GetWebChannelUserTokenResponse
     */
    async getWebChannelUserToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWebChannelUserTokenHeaders({});
        return await this.getWebChannelUserTokenWithOptions(request, headers, runtime);
    }
    /**
     * @summary 通过小蜜机器人在客户群内推送消息
     *
     * @param request PushCustomerGroupMessageRequest
     * @param headers PushCustomerGroupMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return PushCustomerGroupMessageResponse
     */
    async pushCustomerGroupMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushCustomerGroupMessage",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/officialAccounts/robots/groupMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PushCustomerGroupMessageResponse({}));
    }
    /**
     * @summary 通过小蜜机器人在客户群内推送消息
     *
     * @param request PushCustomerGroupMessageRequest
     * @return PushCustomerGroupMessageResponse
     */
    async pushCustomerGroupMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PushCustomerGroupMessageHeaders({});
        return await this.pushCustomerGroupMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 推送智能客服机器人钉钉群聊消息
     *
     * @param request PushIntelligentRobotGroupMessageRequest
     * @param headers PushIntelligentRobotGroupMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return PushIntelligentRobotGroupMessageResponse
     */
    async pushIntelligentRobotGroupMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushIntelligentRobotGroupMessage",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/intelligentRobots/groupMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PushIntelligentRobotGroupMessageResponse({}));
    }
    /**
     * @summary 推送智能客服机器人钉钉群聊消息
     *
     * @param request PushIntelligentRobotGroupMessageRequest
     * @return PushIntelligentRobotGroupMessageResponse
     */
    async pushIntelligentRobotGroupMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PushIntelligentRobotGroupMessageHeaders({});
        return await this.pushIntelligentRobotGroupMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 智能客服机器人推送消息
     *
     * @param request PushIntelligentRobotMessageRequest
     * @param headers PushIntelligentRobotMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return PushIntelligentRobotMessageResponse
     */
    async pushIntelligentRobotMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushIntelligentRobotMessage",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/intelligentRobots/oToMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PushIntelligentRobotMessageResponse({}));
    }
    /**
     * @summary 智能客服机器人推送消息
     *
     * @param request PushIntelligentRobotMessageRequest
     * @return PushIntelligentRobotMessageResponse
     */
    async pushIntelligentRobotMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PushIntelligentRobotMessageHeaders({});
        return await this.pushIntelligentRobotMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 通过服务窗机器人推送单聊消息
     *
     * @param request PushOfficialAccountMessageRequest
     * @param headers PushOfficialAccountMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return PushOfficialAccountMessageResponse
     */
    async pushOfficialAccountMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushOfficialAccountMessage",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/officialAccounts/robots/oToMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PushOfficialAccountMessageResponse({}));
    }
    /**
     * @summary 通过服务窗机器人推送单聊消息
     *
     * @param request PushOfficialAccountMessageRequest
     * @return PushOfficialAccountMessageResponse
     */
    async pushOfficialAccountMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PushOfficialAccountMessageHeaders({});
        return await this.pushOfficialAccountMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 通过小蜜客服机器人推送单聊消息
     *
     * @param request PushRobotMessageRequest
     * @param headers PushRobotMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return PushRobotMessageResponse
     */
    async pushRobotMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PushRobotMessage",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/robots/oToMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PushRobotMessageResponse({}));
    }
    /**
     * @summary 通过小蜜客服机器人推送单聊消息
     *
     * @param request PushRobotMessageRequest
     * @return PushRobotMessageResponse
     */
    async pushRobotMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PushRobotMessageHeaders({});
        return await this.pushRobotMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 异步回复机器人消息
     *
     * @param request ReplyRobotRequest
     * @param headers ReplyRobotHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ReplyRobotResponse
     */
    async replyRobotWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.proxyMessageStr)) {
            body["proxyMessageStr"] = request.proxyMessageStr;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReplyRobot",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/robots/reply`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReplyRobotResponse({}));
    }
    /**
     * @summary 异步回复机器人消息
     *
     * @param request ReplyRobotRequest
     * @return ReplyRobotResponse
     */
    async replyRobot(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReplyRobotHeaders({});
        return await this.replyRobotWithOptions(request, headers, runtime);
    }
    /**
     * @summary 更新服务窗机器人信息
     *
     * @param request UpdateOfficialAccountRobotInfoRequest
     * @param headers UpdateOfficialAccountRobotInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateOfficialAccountRobotInfoResponse
     */
    async updateOfficialAccountRobotInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.avatar)) {
            body["avatar"] = request.avatar;
        }
        if (!tea_util_1.default.isUnset(request.brief)) {
            body["brief"] = request.brief;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.previewMediaUrl)) {
            body["previewMediaUrl"] = request.previewMediaUrl;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateOfficialAccountRobotInfo",
            version: "dingmi_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/dingmi/officialAccounts/robots`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateOfficialAccountRobotInfoResponse({}));
    }
    /**
     * @summary 更新服务窗机器人信息
     *
     * @param request UpdateOfficialAccountRobotInfoRequest
     * @return UpdateOfficialAccountRobotInfoResponse
     */
    async updateOfficialAccountRobotInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateOfficialAccountRobotInfoHeaders({});
        return await this.updateOfficialAccountRobotInfoWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map