"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HrbrainImportPunDetailRequest = exports.HrbrainImportPunDetailHeaders = exports.HrbrainImportPromEvalResponse = exports.HrbrainImportPromEvalResponseBody = exports.HrbrainImportPromEvalRequest = exports.HrbrainImportPromEvalHeaders = exports.HrbrainImportPerfEvalResponse = exports.HrbrainImportPerfEvalResponseBody = exports.HrbrainImportPerfEvalRequest = exports.HrbrainImportPerfEvalHeaders = exports.HrbrainImportLabelProfSkillResponse = exports.HrbrainImportLabelProfSkillResponseBody = exports.HrbrainImportLabelProfSkillRequest = exports.HrbrainImportLabelProfSkillHeaders = exports.HrbrainImportLabelInventoryResponse = exports.HrbrainImportLabelInventoryResponseBody = exports.HrbrainImportLabelInventoryRequest = exports.HrbrainImportLabelInventoryHeaders = exports.HrbrainImportLabelIndustryResponse = exports.HrbrainImportLabelIndustryResponseBody = exports.HrbrainImportLabelIndustryRequest = exports.HrbrainImportLabelIndustryHeaders = exports.HrbrainImportLabelCustomResponse = exports.HrbrainImportLabelCustomResponseBody = exports.HrbrainImportLabelCustomRequest = exports.HrbrainImportLabelCustomHeaders = exports.HrbrainImportLabelBaseResponse = exports.HrbrainImportLabelBaseResponseBody = exports.HrbrainImportLabelBaseRequest = exports.HrbrainImportLabelBaseHeaders = exports.HrbrainImportEmpInfoResponse = exports.HrbrainImportEmpInfoResponseBody = exports.HrbrainImportEmpInfoRequest = exports.HrbrainImportEmpInfoHeaders = exports.HrbrainImportEduExpResponse = exports.HrbrainImportEduExpResponseBody = exports.HrbrainImportEduExpRequest = exports.HrbrainImportEduExpHeaders = exports.HrbrainImportDimissionResponse = exports.HrbrainImportDimissionResponseBody = exports.HrbrainImportDimissionRequest = exports.HrbrainImportDimissionHeaders = exports.HrbrainImportDeptInfoResponse = exports.HrbrainImportDeptInfoResponseBody = exports.HrbrainImportDeptInfoRequest = exports.HrbrainImportDeptInfoHeaders = exports.HrbrainImportAwardDetailResponse = exports.HrbrainImportAwardDetailResponseBody = exports.HrbrainImportAwardDetailRequest = exports.HrbrainImportAwardDetailHeaders = void 0;
exports.HrbrainImportWorkExpRequestBody = exports.HrbrainImportTransferEvalRequestBody = exports.HrbrainImportRegistRequestBody = exports.HrbrainImportPunDetailRequestBody = exports.HrbrainImportPromEvalRequestBody = exports.HrbrainImportPerfEvalRequestBody = exports.HrbrainImportLabelProfSkillRequestBody = exports.HrbrainImportLabelInventoryRequestBody = exports.HrbrainImportLabelIndustryRequestBody = exports.HrbrainImportLabelCustomRequestBody = exports.HrbrainImportLabelBaseRequestBody = exports.HrbrainImportEmpInfoRequestBody = exports.HrbrainImportEduExpRequestBody = exports.HrbrainImportDimissionRequestBody = exports.HrbrainImportDeptInfoRequestBody = exports.HrbrainImportAwardDetailRequestBody = exports.SyncDataResponse = exports.SyncDataResponseBody = exports.SyncDataRequest = exports.SyncDataHeaders = exports.HrbrainImportWorkExpResponse = exports.HrbrainImportWorkExpResponseBody = exports.HrbrainImportWorkExpRequest = exports.HrbrainImportWorkExpHeaders = exports.HrbrainImportTransferEvalResponse = exports.HrbrainImportTransferEvalResponseBody = exports.HrbrainImportTransferEvalRequest = exports.HrbrainImportTransferEvalHeaders = exports.HrbrainImportRegistResponse = exports.HrbrainImportRegistResponseBody = exports.HrbrainImportRegistRequest = exports.HrbrainImportRegistHeaders = exports.HrbrainImportPunDetailResponse = exports.HrbrainImportPunDetailResponseBody = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class HrbrainImportAwardDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportAwardDetailHeaders = HrbrainImportAwardDetailHeaders;
class HrbrainImportAwardDetailRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportAwardDetailRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportAwardDetailRequest = HrbrainImportAwardDetailRequest;
class HrbrainImportAwardDetailResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportAwardDetailResponseBody = HrbrainImportAwardDetailResponseBody;
class HrbrainImportAwardDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportAwardDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportAwardDetailResponse = HrbrainImportAwardDetailResponse;
class HrbrainImportDeptInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDeptInfoHeaders = HrbrainImportDeptInfoHeaders;
class HrbrainImportDeptInfoRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportDeptInfoRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDeptInfoRequest = HrbrainImportDeptInfoRequest;
class HrbrainImportDeptInfoResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDeptInfoResponseBody = HrbrainImportDeptInfoResponseBody;
class HrbrainImportDeptInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportDeptInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDeptInfoResponse = HrbrainImportDeptInfoResponse;
class HrbrainImportDimissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDimissionHeaders = HrbrainImportDimissionHeaders;
class HrbrainImportDimissionRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportDimissionRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDimissionRequest = HrbrainImportDimissionRequest;
class HrbrainImportDimissionResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDimissionResponseBody = HrbrainImportDimissionResponseBody;
class HrbrainImportDimissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportDimissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDimissionResponse = HrbrainImportDimissionResponse;
class HrbrainImportEduExpHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEduExpHeaders = HrbrainImportEduExpHeaders;
class HrbrainImportEduExpRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportEduExpRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEduExpRequest = HrbrainImportEduExpRequest;
class HrbrainImportEduExpResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEduExpResponseBody = HrbrainImportEduExpResponseBody;
class HrbrainImportEduExpResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportEduExpResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEduExpResponse = HrbrainImportEduExpResponse;
class HrbrainImportEmpInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEmpInfoHeaders = HrbrainImportEmpInfoHeaders;
class HrbrainImportEmpInfoRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportEmpInfoRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEmpInfoRequest = HrbrainImportEmpInfoRequest;
class HrbrainImportEmpInfoResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEmpInfoResponseBody = HrbrainImportEmpInfoResponseBody;
class HrbrainImportEmpInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportEmpInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEmpInfoResponse = HrbrainImportEmpInfoResponse;
class HrbrainImportLabelBaseHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelBaseHeaders = HrbrainImportLabelBaseHeaders;
class HrbrainImportLabelBaseRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportLabelBaseRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelBaseRequest = HrbrainImportLabelBaseRequest;
class HrbrainImportLabelBaseResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelBaseResponseBody = HrbrainImportLabelBaseResponseBody;
class HrbrainImportLabelBaseResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportLabelBaseResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelBaseResponse = HrbrainImportLabelBaseResponse;
class HrbrainImportLabelCustomHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelCustomHeaders = HrbrainImportLabelCustomHeaders;
class HrbrainImportLabelCustomRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportLabelCustomRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelCustomRequest = HrbrainImportLabelCustomRequest;
class HrbrainImportLabelCustomResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelCustomResponseBody = HrbrainImportLabelCustomResponseBody;
class HrbrainImportLabelCustomResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportLabelCustomResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelCustomResponse = HrbrainImportLabelCustomResponse;
class HrbrainImportLabelIndustryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelIndustryHeaders = HrbrainImportLabelIndustryHeaders;
class HrbrainImportLabelIndustryRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportLabelIndustryRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelIndustryRequest = HrbrainImportLabelIndustryRequest;
class HrbrainImportLabelIndustryResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelIndustryResponseBody = HrbrainImportLabelIndustryResponseBody;
class HrbrainImportLabelIndustryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportLabelIndustryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelIndustryResponse = HrbrainImportLabelIndustryResponse;
class HrbrainImportLabelInventoryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelInventoryHeaders = HrbrainImportLabelInventoryHeaders;
class HrbrainImportLabelInventoryRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportLabelInventoryRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelInventoryRequest = HrbrainImportLabelInventoryRequest;
class HrbrainImportLabelInventoryResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelInventoryResponseBody = HrbrainImportLabelInventoryResponseBody;
class HrbrainImportLabelInventoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportLabelInventoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelInventoryResponse = HrbrainImportLabelInventoryResponse;
class HrbrainImportLabelProfSkillHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelProfSkillHeaders = HrbrainImportLabelProfSkillHeaders;
class HrbrainImportLabelProfSkillRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportLabelProfSkillRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelProfSkillRequest = HrbrainImportLabelProfSkillRequest;
class HrbrainImportLabelProfSkillResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelProfSkillResponseBody = HrbrainImportLabelProfSkillResponseBody;
class HrbrainImportLabelProfSkillResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportLabelProfSkillResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelProfSkillResponse = HrbrainImportLabelProfSkillResponse;
class HrbrainImportPerfEvalHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPerfEvalHeaders = HrbrainImportPerfEvalHeaders;
class HrbrainImportPerfEvalRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportPerfEvalRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPerfEvalRequest = HrbrainImportPerfEvalRequest;
class HrbrainImportPerfEvalResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPerfEvalResponseBody = HrbrainImportPerfEvalResponseBody;
class HrbrainImportPerfEvalResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportPerfEvalResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPerfEvalResponse = HrbrainImportPerfEvalResponse;
class HrbrainImportPromEvalHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPromEvalHeaders = HrbrainImportPromEvalHeaders;
class HrbrainImportPromEvalRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportPromEvalRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPromEvalRequest = HrbrainImportPromEvalRequest;
class HrbrainImportPromEvalResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPromEvalResponseBody = HrbrainImportPromEvalResponseBody;
class HrbrainImportPromEvalResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportPromEvalResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPromEvalResponse = HrbrainImportPromEvalResponse;
class HrbrainImportPunDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPunDetailHeaders = HrbrainImportPunDetailHeaders;
class HrbrainImportPunDetailRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportPunDetailRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPunDetailRequest = HrbrainImportPunDetailRequest;
class HrbrainImportPunDetailResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPunDetailResponseBody = HrbrainImportPunDetailResponseBody;
class HrbrainImportPunDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportPunDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPunDetailResponse = HrbrainImportPunDetailResponse;
class HrbrainImportRegistHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportRegistHeaders = HrbrainImportRegistHeaders;
class HrbrainImportRegistRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportRegistRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportRegistRequest = HrbrainImportRegistRequest;
class HrbrainImportRegistResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportRegistResponseBody = HrbrainImportRegistResponseBody;
class HrbrainImportRegistResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportRegistResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportRegistResponse = HrbrainImportRegistResponse;
class HrbrainImportTransferEvalHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportTransferEvalHeaders = HrbrainImportTransferEvalHeaders;
class HrbrainImportTransferEvalRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportTransferEvalRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportTransferEvalRequest = HrbrainImportTransferEvalRequest;
class HrbrainImportTransferEvalResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportTransferEvalResponseBody = HrbrainImportTransferEvalResponseBody;
class HrbrainImportTransferEvalResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportTransferEvalResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportTransferEvalResponse = HrbrainImportTransferEvalResponse;
class HrbrainImportWorkExpHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportWorkExpHeaders = HrbrainImportWorkExpHeaders;
class HrbrainImportWorkExpRequest extends $tea.Model {
    static names() {
        return {
            body: 'body',
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': HrbrainImportWorkExpRequestBody },
            corpId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportWorkExpRequest = HrbrainImportWorkExpRequest;
class HrbrainImportWorkExpResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportWorkExpResponseBody = HrbrainImportWorkExpResponseBody;
class HrbrainImportWorkExpResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrbrainImportWorkExpResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportWorkExpResponse = HrbrainImportWorkExpResponse;
class SyncDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncDataHeaders = SyncDataHeaders;
class SyncDataRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            dataId: 'dataId',
            etlTime: 'etlTime',
            projectId: 'projectId',
            schemaId: 'schemaId',
        };
    }
    static types() {
        return {
            content: 'string',
            dataId: 'string',
            etlTime: 'string',
            projectId: 'string',
            schemaId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncDataRequest = SyncDataRequest;
class SyncDataResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncDataResponseBody = SyncDataResponseBody;
class SyncDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SyncDataResponse = SyncDataResponse;
class HrbrainImportAwardDetailRequestBody extends $tea.Model {
    static names() {
        return {
            awardDate: 'awardDate',
            awardName: 'awardName',
            awardOrg: 'awardOrg',
            awardType: 'awardType',
            comment: 'comment',
            extendInfo: 'extendInfo',
            name: 'name',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            awardDate: 'string',
            awardName: 'string',
            awardOrg: 'string',
            awardType: 'string',
            comment: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportAwardDetailRequestBody = HrbrainImportAwardDetailRequestBody;
class HrbrainImportDeptInfoRequestBody extends $tea.Model {
    static names() {
        return {
            createDate: 'createDate',
            deptName: 'deptName',
            deptNo: 'deptNo',
            effectiveDate: 'effectiveDate',
            extendInfo: 'extendInfo',
            isEffective: 'isEffective',
            superDeptName: 'superDeptName',
            superDeptNo: 'superDeptNo',
            superEmpId: 'superEmpId',
            superName: 'superName',
        };
    }
    static types() {
        return {
            createDate: 'string',
            deptName: 'string',
            deptNo: 'string',
            effectiveDate: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            isEffective: 'string',
            superDeptName: 'string',
            superDeptNo: 'string',
            superEmpId: 'string',
            superName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDeptInfoRequestBody = HrbrainImportDeptInfoRequestBody;
class HrbrainImportDimissionRequestBody extends $tea.Model {
    static names() {
        return {
            deptName: 'deptName',
            deptNo: 'deptNo',
            dimissionDate: 'dimissionDate',
            dimissionReaasonDesc: 'dimissionReaasonDesc',
            dimissionReason: 'dimissionReason',
            empType: 'empType',
            extendInfo: 'extendInfo',
            jobCodeName: 'jobCodeName',
            jobLevel: 'jobLevel',
            name: 'name',
            postName: 'postName',
            superName: 'superName',
            workLocAddr: 'workLocAddr',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            deptName: 'string',
            deptNo: 'string',
            dimissionDate: 'string',
            dimissionReaasonDesc: 'string',
            dimissionReason: 'string',
            empType: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            jobCodeName: 'string',
            jobLevel: 'string',
            name: 'string',
            postName: 'string',
            superName: 'string',
            workLocAddr: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportDimissionRequestBody = HrbrainImportDimissionRequestBody;
class HrbrainImportEduExpRequestBody extends $tea.Model {
    static names() {
        return {
            eduName: 'eduName',
            endDate: 'endDate',
            extendInfo: 'extendInfo',
            major: 'major',
            name: 'name',
            schoolName: 'schoolName',
            startDate: 'startDate',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            eduName: 'string',
            endDate: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            major: 'string',
            name: 'string',
            schoolName: 'string',
            startDate: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEduExpRequestBody = HrbrainImportEduExpRequestBody;
class HrbrainImportEmpInfoRequestBody extends $tea.Model {
    static names() {
        return {
            birthday: 'birthday',
            deptName: 'deptName',
            deptNo: 'deptNo',
            dimissionDate: 'dimissionDate',
            empSource: 'empSource',
            empStatus: 'empStatus',
            empType: 'empType',
            extendInfo: 'extendInfo',
            gender: 'gender',
            highestDegree: 'highestDegree',
            highestEduName: 'highestEduName',
            isDimission: 'isDimission',
            jobCodeName: 'jobCodeName',
            jobLevel: 'jobLevel',
            lastSchoolName: 'lastSchoolName',
            marriage: 'marriage',
            name: 'name',
            nation: 'nation',
            nationCtry: 'nationCtry',
            politicalStatus: 'politicalStatus',
            postName: 'postName',
            registDate: 'registDate',
            regularDate: 'regularDate',
            superEmpId: 'superEmpId',
            superName: 'superName',
            workEmail: 'workEmail',
            workLocAddr: 'workLocAddr',
            workLocCity: 'workLocCity',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            birthday: 'string',
            deptName: 'string',
            deptNo: 'string',
            dimissionDate: 'string',
            empSource: 'string',
            empStatus: 'string',
            empType: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            gender: 'string',
            highestDegree: 'string',
            highestEduName: 'string',
            isDimission: 'string',
            jobCodeName: 'string',
            jobLevel: 'string',
            lastSchoolName: 'string',
            marriage: 'string',
            name: 'string',
            nation: 'string',
            nationCtry: 'string',
            politicalStatus: 'string',
            postName: 'string',
            registDate: 'string',
            regularDate: 'string',
            superEmpId: 'string',
            superName: 'string',
            workEmail: 'string',
            workLocAddr: 'string',
            workLocCity: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportEmpInfoRequestBody = HrbrainImportEmpInfoRequestBody;
class HrbrainImportLabelBaseRequestBody extends $tea.Model {
    static names() {
        return {
            extendInfo: 'extendInfo',
            name: 'name',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelBaseRequestBody = HrbrainImportLabelBaseRequestBody;
class HrbrainImportLabelCustomRequestBody extends $tea.Model {
    static names() {
        return {
            extendInfo: 'extendInfo',
            name: 'name',
            tag: 'tag',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            tag: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelCustomRequestBody = HrbrainImportLabelCustomRequestBody;
class HrbrainImportLabelIndustryRequestBody extends $tea.Model {
    static names() {
        return {
            extendInfo: 'extendInfo',
            level1: 'level1',
            level2: 'level2',
            level3: 'level3',
            name: 'name',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            level1: 'string',
            level2: 'string',
            level3: 'string',
            name: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelIndustryRequestBody = HrbrainImportLabelIndustryRequestBody;
class HrbrainImportLabelInventoryRequestBody extends $tea.Model {
    static names() {
        return {
            extendInfo: 'extendInfo',
            name: 'name',
            period: 'period',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            period: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelInventoryRequestBody = HrbrainImportLabelInventoryRequestBody;
class HrbrainImportLabelProfSkillRequestBody extends $tea.Model {
    static names() {
        return {
            extendInfo: 'extendInfo',
            level1: 'level1',
            level2: 'level2',
            level3: 'level3',
            name: 'name',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            level1: 'string',
            level2: 'string',
            level3: 'string',
            name: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportLabelProfSkillRequestBody = HrbrainImportLabelProfSkillRequestBody;
class HrbrainImportPerfEvalRequestBody extends $tea.Model {
    static names() {
        return {
            comment: 'comment',
            extendInfo: 'extendInfo',
            name: 'name',
            perfCate: 'perfCate',
            perfPlanName: 'perfPlanName',
            perfScore: 'perfScore',
            period: 'period',
            periodEndDate: 'periodEndDate',
            periodStartDate: 'periodStartDate',
            score: 'score',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            comment: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            perfCate: 'string',
            perfPlanName: 'string',
            perfScore: 'string',
            period: 'string',
            periodEndDate: 'string',
            periodStartDate: 'string',
            score: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPerfEvalRequestBody = HrbrainImportPerfEvalRequestBody;
class HrbrainImportPromEvalRequestBody extends $tea.Model {
    static names() {
        return {
            comment: 'comment',
            effectiveDate: 'effectiveDate',
            extendInfo: 'extendInfo',
            name: 'name',
            newJobLevel: 'newJobLevel',
            period: 'period',
            periodEndDate: 'periodEndDate',
            periodStartDate: 'periodStartDate',
            preJobLevel: 'preJobLevel',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            comment: 'string',
            effectiveDate: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            newJobLevel: 'string',
            period: 'string',
            periodEndDate: 'string',
            periodStartDate: 'string',
            preJobLevel: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPromEvalRequestBody = HrbrainImportPromEvalRequestBody;
class HrbrainImportPunDetailRequestBody extends $tea.Model {
    static names() {
        return {
            comment: 'comment',
            effectiveDate: 'effectiveDate',
            extendInfo: 'extendInfo',
            name: 'name',
            punName: 'punName',
            punOrg: 'punOrg',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            comment: 'string',
            effectiveDate: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            punName: 'string',
            punOrg: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportPunDetailRequestBody = HrbrainImportPunDetailRequestBody;
class HrbrainImportRegistRequestBody extends $tea.Model {
    static names() {
        return {
            deptName: 'deptName',
            deptNo: 'deptNo',
            empSource: 'empSource',
            empType: 'empType',
            extendInfo: 'extendInfo',
            jobCodeName: 'jobCodeName',
            jobLevel: 'jobLevel',
            name: 'name',
            postName: 'postName',
            registDate: 'registDate',
            superName: 'superName',
            workLocAddr: 'workLocAddr',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            deptName: 'string',
            deptNo: 'string',
            empSource: 'string',
            empType: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            jobCodeName: 'string',
            jobLevel: 'string',
            name: 'string',
            postName: 'string',
            registDate: 'string',
            superName: 'string',
            workLocAddr: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportRegistRequestBody = HrbrainImportRegistRequestBody;
class HrbrainImportTransferEvalRequestBody extends $tea.Model {
    static names() {
        return {
            currInfo: 'currInfo',
            extendInfo: 'extendInfo',
            name: 'name',
            preInfo: 'preInfo',
            transferDate: 'transferDate',
            transferReason: 'transferReason',
            transferType: 'transferType',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            currInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            name: 'string',
            preInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            transferDate: 'string',
            transferReason: 'string',
            transferType: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportTransferEvalRequestBody = HrbrainImportTransferEvalRequestBody;
class HrbrainImportWorkExpRequestBody extends $tea.Model {
    static names() {
        return {
            companyName: 'companyName',
            endDate: 'endDate',
            extendInfo: 'extendInfo',
            jobDesc: 'jobDesc',
            name: 'name',
            postName: 'postName',
            startDate: 'startDate',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            companyName: 'string',
            endDate: 'string',
            extendInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            jobDesc: 'string',
            name: 'string',
            postName: 'string',
            startDate: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HrbrainImportWorkExpRequestBody = HrbrainImportWorkExpRequestBody;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportAwardDetailRequest
     * @param headers HrbrainImportAwardDetailHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportAwardDetailResponse
     */
    async hrbrainImportAwardDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportAwardDetail",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/awardDetails/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportAwardDetailResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportAwardDetailRequest
     * @return HrbrainImportAwardDetailResponse
     */
    async hrbrainImportAwardDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportAwardDetailHeaders({});
        return await this.hrbrainImportAwardDetailWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportDeptInfoRequest
     * @param headers HrbrainImportDeptInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportDeptInfoResponse
     */
    async hrbrainImportDeptInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportDeptInfo",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/deptInfos/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportDeptInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportDeptInfoRequest
     * @return HrbrainImportDeptInfoResponse
     */
    async hrbrainImportDeptInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportDeptInfoHeaders({});
        return await this.hrbrainImportDeptInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportDimissionRequest
     * @param headers HrbrainImportDimissionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportDimissionResponse
     */
    async hrbrainImportDimissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportDimission",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/dimissionInfos/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportDimissionResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportDimissionRequest
     * @return HrbrainImportDimissionResponse
     */
    async hrbrainImportDimission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportDimissionHeaders({});
        return await this.hrbrainImportDimissionWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportEduExpRequest
     * @param headers HrbrainImportEduExpHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportEduExpResponse
     */
    async hrbrainImportEduExpWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportEduExp",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/eduExperiences/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportEduExpResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportEduExpRequest
     * @return HrbrainImportEduExpResponse
     */
    async hrbrainImportEduExp(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportEduExpHeaders({});
        return await this.hrbrainImportEduExpWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportEmpInfoRequest
     * @param headers HrbrainImportEmpInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportEmpInfoResponse
     */
    async hrbrainImportEmpInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportEmpInfo",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/empInfos/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportEmpInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportEmpInfoRequest
     * @return HrbrainImportEmpInfoResponse
     */
    async hrbrainImportEmpInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportEmpInfoHeaders({});
        return await this.hrbrainImportEmpInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelBaseRequest
     * @param headers HrbrainImportLabelBaseHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportLabelBaseResponse
     */
    async hrbrainImportLabelBaseWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportLabelBase",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/baseLabels/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportLabelBaseResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelBaseRequest
     * @return HrbrainImportLabelBaseResponse
     */
    async hrbrainImportLabelBase(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportLabelBaseHeaders({});
        return await this.hrbrainImportLabelBaseWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelCustomRequest
     * @param headers HrbrainImportLabelCustomHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportLabelCustomResponse
     */
    async hrbrainImportLabelCustomWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportLabelCustom",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/customLabels/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportLabelCustomResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelCustomRequest
     * @return HrbrainImportLabelCustomResponse
     */
    async hrbrainImportLabelCustom(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportLabelCustomHeaders({});
        return await this.hrbrainImportLabelCustomWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelIndustryRequest
     * @param headers HrbrainImportLabelIndustryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportLabelIndustryResponse
     */
    async hrbrainImportLabelIndustryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportLabelIndustry",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/industries/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportLabelIndustryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelIndustryRequest
     * @return HrbrainImportLabelIndustryResponse
     */
    async hrbrainImportLabelIndustry(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportLabelIndustryHeaders({});
        return await this.hrbrainImportLabelIndustryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelInventoryRequest
     * @param headers HrbrainImportLabelInventoryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportLabelInventoryResponse
     */
    async hrbrainImportLabelInventoryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportLabelInventory",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/inventories/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportLabelInventoryResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelInventoryRequest
     * @return HrbrainImportLabelInventoryResponse
     */
    async hrbrainImportLabelInventory(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportLabelInventoryHeaders({});
        return await this.hrbrainImportLabelInventoryWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelProfSkillRequest
     * @param headers HrbrainImportLabelProfSkillHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportLabelProfSkillResponse
     */
    async hrbrainImportLabelProfSkillWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportLabelProfSkill",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/profSkills/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportLabelProfSkillResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportLabelProfSkillRequest
     * @return HrbrainImportLabelProfSkillResponse
     */
    async hrbrainImportLabelProfSkill(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportLabelProfSkillHeaders({});
        return await this.hrbrainImportLabelProfSkillWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPerfEvalRequest
     * @param headers HrbrainImportPerfEvalHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportPerfEvalResponse
     */
    async hrbrainImportPerfEvalWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportPerfEval",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/perfRecords/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportPerfEvalResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPerfEvalRequest
     * @return HrbrainImportPerfEvalResponse
     */
    async hrbrainImportPerfEval(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportPerfEvalHeaders({});
        return await this.hrbrainImportPerfEvalWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPromEvalRequest
     * @param headers HrbrainImportPromEvalHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportPromEvalResponse
     */
    async hrbrainImportPromEvalWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportPromEval",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/promRecords/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportPromEvalResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPromEvalRequest
     * @return HrbrainImportPromEvalResponse
     */
    async hrbrainImportPromEval(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportPromEvalHeaders({});
        return await this.hrbrainImportPromEvalWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPunDetailRequest
     * @param headers HrbrainImportPunDetailHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportPunDetailResponse
     */
    async hrbrainImportPunDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportPunDetail",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/punDetails/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportPunDetailResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportPunDetailRequest
     * @return HrbrainImportPunDetailResponse
     */
    async hrbrainImportPunDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportPunDetailHeaders({});
        return await this.hrbrainImportPunDetailWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportRegistRequest
     * @param headers HrbrainImportRegistHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportRegistResponse
     */
    async hrbrainImportRegistWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportRegist",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/registerInfos/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportRegistResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportRegistRequest
     * @return HrbrainImportRegistResponse
     */
    async hrbrainImportRegist(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportRegistHeaders({});
        return await this.hrbrainImportRegistWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportTransferEvalRequest
     * @param headers HrbrainImportTransferEvalHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportTransferEvalResponse
     */
    async hrbrainImportTransferEvalWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportTransferEval",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/changeRecords/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportTransferEvalResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportTransferEvalRequest
     * @return HrbrainImportTransferEvalResponse
     */
    async hrbrainImportTransferEval(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportTransferEvalHeaders({});
        return await this.hrbrainImportTransferEvalWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportWorkExpRequest
     * @param headers HrbrainImportWorkExpHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HrbrainImportWorkExpResponse
     */
    async hrbrainImportWorkExpWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "HrbrainImportWorkExp",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas/workExperiences/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrbrainImportWorkExpResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HrbrainImportWorkExpRequest
     * @return HrbrainImportWorkExpResponse
     */
    async hrbrainImportWorkExp(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrbrainImportWorkExpHeaders({});
        return await this.hrbrainImportWorkExpWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SyncDataRequest
     * @param headers SyncDataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SyncDataResponse
     */
    async syncDataWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.dataId)) {
            body["dataId"] = request.dataId;
        }
        if (!tea_util_1.default.isUnset(request.etlTime)) {
            body["etlTime"] = request.etlTime;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["projectId"] = request.projectId;
        }
        if (!tea_util_1.default.isUnset(request.schemaId)) {
            body["schemaId"] = request.schemaId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncData",
            version: "hrbrain_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrbrain/datas`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncDataResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SyncDataRequest
     * @return SyncDataResponse
     */
    async syncData(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncDataHeaders({});
        return await this.syncDataWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map