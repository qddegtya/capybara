"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetUserOkrHeaders = exports.GetPermissionResponse = exports.GetPermissionResponseBody = exports.GetPermissionRequest = exports.GetPermissionHeaders = exports.GetPeriodListResponse = exports.GetPeriodListResponseBody = exports.GetPeriodListHeaders = exports.DeletePermissionResponse = exports.DeletePermissionResponseBody = exports.DeletePermissionRequest = exports.DeletePermissionHeaders = exports.DeleteObjectiveResponse = exports.DeleteObjectiveResponseBody = exports.DeleteObjectiveRequest = exports.DeleteObjectiveHeaders = exports.DeleteKeyResultResponse = exports.DeleteKeyResultResponseBody = exports.DeleteKeyResultRequest = exports.DeleteKeyResultHeaders = exports.CreateObjectiveResponse = exports.CreateObjectiveResponseBody = exports.CreateObjectiveRequest = exports.CreateObjectiveHeaders = exports.CreateKeyResultResponse = exports.CreateKeyResultResponseBody = exports.CreateKeyResultRequest = exports.CreateKeyResultHeaders = exports.BatchQueryUserResponse = exports.BatchQueryUserResponseBody = exports.BatchQueryUserRequest = exports.BatchQueryUserHeaders = exports.BatchQueryObjectiveResponse = exports.BatchQueryObjectiveResponseBody = exports.BatchQueryObjectiveRequest = exports.BatchQueryObjectiveHeaders = exports.BatchAddPermissionResponse = exports.BatchAddPermissionResponseBody = exports.BatchAddPermissionRequest = exports.BatchAddPermissionHeaders = exports.AlignObjectiveResponse = exports.AlignObjectiveResponseBody = exports.AlignObjectiveRequest = exports.AlignObjectiveHeaders = exports.TitleMention = exports.OpenUserDTO = exports.OpenTeamDTO = exports.OpenPeriodDTO = exports.OpenObjectiveDTO = exports.OpenKeyResultDTO = void 0;
exports.BatchQueryObjectiveResponseBodyDataProgress = exports.BatchQueryObjectiveResponseBodyDataOwner = exports.BatchQueryObjectiveResponseBodyDataKrList = exports.BatchQueryObjectiveResponseBodyDataKrListProgress = exports.BatchAddPermissionResponseBodyData = exports.BatchAddPermissionResponseBodyDataPermissionTree = exports.BatchAddPermissionResponseBodyDataPermissionTreePolicyList = exports.BatchAddPermissionResponseBodyDataPermissionTreePolicyListMemberList = exports.BatchAddPermissionRequestList = exports.BatchAddPermissionRequestListMember = exports.AlignObjectiveResponseBodyData = exports.UpdatePrivacyResponse = exports.UpdatePrivacyResponseBody = exports.UpdatePrivacyRequest = exports.UpdatePrivacyHeaders = exports.UpdateObjectiveResponse = exports.UpdateObjectiveResponseBody = exports.UpdateObjectiveRequest = exports.UpdateObjectiveHeaders = exports.UpdateKROfWeightResponse = exports.UpdateKROfWeightResponseBody = exports.UpdateKROfWeightRequest = exports.UpdateKROfWeightHeaders = exports.UpdateKROfScoreResponse = exports.UpdateKROfScoreResponseBody = exports.UpdateKROfScoreRequest = exports.UpdateKROfScoreHeaders = exports.UpdateKROfContentResponse = exports.UpdateKROfContentResponseBody = exports.UpdateKROfContentRequest = exports.UpdateKROfContentHeaders = exports.UnAlignObjectiveResponse = exports.UnAlignObjectiveResponseBody = exports.UnAlignObjectiveRequest = exports.UnAlignObjectiveHeaders = exports.OkrPeriodsResponse = exports.OkrPeriodsResponseBody = exports.OkrPeriodsRequest = exports.OkrPeriodsHeaders = exports.OkrObjectivesByUserResponse = exports.OkrObjectivesByUserResponseBody = exports.OkrObjectivesByUserRequest = exports.OkrObjectivesByUserHeaders = exports.OkrObjectivesBatchResponse = exports.OkrObjectivesBatchResponseBody = exports.OkrObjectivesBatchRequest = exports.OkrObjectivesBatchHeaders = exports.GetUserOkrResponse = exports.GetUserOkrResponseBody = exports.GetUserOkrRequest = void 0;
exports.UpdatePrivacyResponseBodyData = exports.UpdatePrivacyResponseBodyDataPolicyList = exports.UpdatePrivacyResponseBodyDataPolicyListMemberList = exports.UpdateObjectiveResponseBodyData = exports.UpdateKROfWeightResponseBodyData = exports.UpdateKROfWeightResponseBodyDataObjectiveProgress = exports.UpdateKROfScoreResponseBodyData = exports.UnAlignObjectiveResponseBodyData = exports.OkrPeriodsResponseBodyContent = exports.OkrObjectivesByUserResponseBodyContent = exports.GetUserOkrResponseBodyData = exports.GetUserOkrResponseBodyDataList = exports.GetUserOkrResponseBodyDataListProgress = exports.GetUserOkrResponseBodyDataListOwner = exports.GetUserOkrResponseBodyDataListKrList = exports.GetUserOkrResponseBodyDataListKrListProgress = exports.GetPermissionResponseBodyData = exports.GetPermissionResponseBodyDataPolicyList = exports.GetPermissionResponseBodyDataPolicyListMemberList = exports.GetPeriodListResponseBodyData = exports.GetPeriodListResponseBodyDataPeriodList = exports.DeletePermissionResponseBodyData = exports.DeletePermissionResponseBodyDataPolicyList = exports.DeletePermissionResponseBodyDataPolicyListMemberList = exports.DeleteObjectiveResponseBodyData = exports.CreateObjectiveResponseBodyData = exports.CreateKeyResultResponseBodyData = exports.BatchQueryUserResponseBodyData = exports.BatchQueryObjectiveResponseBodyData = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class OpenKeyResultDTO extends $tea.Model {
    static names() {
        return {
            krId: 'krId',
            progress: 'progress',
            status: 'status',
            title: 'title',
            titleMentions: 'titleMentions',
            type: 'type',
            weight: 'weight',
        };
    }
    static types() {
        return {
            krId: 'string',
            progress: 'number',
            status: 'number',
            title: 'string',
            titleMentions: { 'type': 'array', 'itemType': TitleMention },
            type: 'number',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenKeyResultDTO = OpenKeyResultDTO;
class OpenObjectiveDTO extends $tea.Model {
    static names() {
        return {
            executor: 'executor',
            keyResults: 'keyResults',
            objectiveId: 'objectiveId',
            period: 'period',
            progress: 'progress',
            status: 'status',
            teams: 'teams',
            title: 'title',
            weight: 'weight',
        };
    }
    static types() {
        return {
            executor: OpenUserDTO,
            keyResults: { 'type': 'array', 'itemType': OpenKeyResultDTO },
            objectiveId: 'string',
            period: OpenPeriodDTO,
            progress: 'number',
            status: 'number',
            teams: { 'type': 'array', 'itemType': OpenTeamDTO },
            title: 'string',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenObjectiveDTO = OpenObjectiveDTO;
class OpenPeriodDTO extends $tea.Model {
    static names() {
        return {
            endDate: 'endDate',
            nameCn: 'nameCn',
            nameEn: 'nameEn',
            periodId: 'periodId',
            startDate: 'startDate',
            status: 'status',
        };
    }
    static types() {
        return {
            endDate: 'number',
            nameCn: 'string',
            nameEn: 'string',
            periodId: 'string',
            startDate: 'number',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenPeriodDTO = OpenPeriodDTO;
class OpenTeamDTO extends $tea.Model {
    static names() {
        return {
            deptUid: 'deptUid',
            dingDeptId: 'dingDeptId',
            name: 'name',
        };
    }
    static types() {
        return {
            deptUid: 'string',
            dingDeptId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenTeamDTO = OpenTeamDTO;
class OpenUserDTO extends $tea.Model {
    static names() {
        return {
            dingUserId: 'dingUserId',
            name: 'name',
            userUid: 'userUid',
            workNo: 'workNo',
        };
    }
    static types() {
        return {
            dingUserId: 'string',
            name: 'string',
            userUid: 'string',
            workNo: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserDTO = OpenUserDTO;
class TitleMention extends $tea.Model {
    static names() {
        return {
            length: 'length',
            offset: 'offset',
            user: 'user',
        };
    }
    static types() {
        return {
            length: 'number',
            offset: 'number',
            user: OpenUserDTO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TitleMention = TitleMention;
class AlignObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AlignObjectiveHeaders = AlignObjectiveHeaders;
class AlignObjectiveRequest extends $tea.Model {
    static names() {
        return {
            periodId: 'periodId',
            targetId: 'targetId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            periodId: 'string',
            targetId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AlignObjectiveRequest = AlignObjectiveRequest;
class AlignObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: AlignObjectiveResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AlignObjectiveResponseBody = AlignObjectiveResponseBody;
class AlignObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AlignObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AlignObjectiveResponse = AlignObjectiveResponse;
class BatchAddPermissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionHeaders = BatchAddPermissionHeaders;
class BatchAddPermissionRequest extends $tea.Model {
    static names() {
        return {
            list: 'list',
            targetId: 'targetId',
            targetType: 'targetType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': BatchAddPermissionRequestList },
            targetId: 'string',
            targetType: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionRequest = BatchAddPermissionRequest;
class BatchAddPermissionResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: BatchAddPermissionResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponseBody = BatchAddPermissionResponseBody;
class BatchAddPermissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddPermissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponse = BatchAddPermissionResponse;
class BatchQueryObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveHeaders = BatchQueryObjectiveHeaders;
class BatchQueryObjectiveRequest extends $tea.Model {
    static names() {
        return {
            objectiveIds: 'objectiveIds',
            periodId: 'periodId',
            withAlign: 'withAlign',
            withKr: 'withKr',
            withProgress: 'withProgress',
            userId: 'userId',
        };
    }
    static types() {
        return {
            objectiveIds: { 'type': 'array', 'itemType': 'string' },
            periodId: 'string',
            withAlign: 'boolean',
            withKr: 'boolean',
            withProgress: 'boolean',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveRequest = BatchQueryObjectiveRequest;
class BatchQueryObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': BatchQueryObjectiveResponseBodyData },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBody = BatchQueryObjectiveResponseBody;
class BatchQueryObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponse = BatchQueryObjectiveResponse;
class BatchQueryUserHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryUserHeaders = BatchQueryUserHeaders;
class BatchQueryUserRequest extends $tea.Model {
    static names() {
        return {
            okrUserIds: 'okrUserIds',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            okrUserIds: { 'type': 'array', 'itemType': 'string' },
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryUserRequest = BatchQueryUserRequest;
class BatchQueryUserResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': BatchQueryUserResponseBodyData },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryUserResponseBody = BatchQueryUserResponseBody;
class BatchQueryUserResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryUserResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryUserResponse = BatchQueryUserResponse;
class CreateKeyResultHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateKeyResultHeaders = CreateKeyResultHeaders;
class CreateKeyResultRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            objectiveId: 'objectiveId',
            periodId: 'periodId',
            prevPosition: 'prevPosition',
            weight: 'weight',
            userId: 'userId',
        };
    }
    static types() {
        return {
            content: 'string',
            objectiveId: 'string',
            periodId: 'string',
            prevPosition: 'number',
            weight: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateKeyResultRequest = CreateKeyResultRequest;
class CreateKeyResultResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: CreateKeyResultResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateKeyResultResponseBody = CreateKeyResultResponseBody;
class CreateKeyResultResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateKeyResultResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateKeyResultResponse = CreateKeyResultResponse;
class CreateObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateObjectiveHeaders = CreateObjectiveHeaders;
class CreateObjectiveRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            periodId: 'periodId',
            prevPosition: 'prevPosition',
            userId: 'userId',
        };
    }
    static types() {
        return {
            content: 'string',
            periodId: 'string',
            prevPosition: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateObjectiveRequest = CreateObjectiveRequest;
class CreateObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: CreateObjectiveResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateObjectiveResponseBody = CreateObjectiveResponseBody;
class CreateObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateObjectiveResponse = CreateObjectiveResponse;
class DeleteKeyResultHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKeyResultHeaders = DeleteKeyResultHeaders;
class DeleteKeyResultRequest extends $tea.Model {
    static names() {
        return {
            krId: 'krId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            krId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKeyResultRequest = DeleteKeyResultRequest;
class DeleteKeyResultResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKeyResultResponseBody = DeleteKeyResultResponseBody;
class DeleteKeyResultResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteKeyResultResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKeyResultResponse = DeleteKeyResultResponse;
class DeleteObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteObjectiveHeaders = DeleteObjectiveHeaders;
class DeleteObjectiveRequest extends $tea.Model {
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteObjectiveRequest = DeleteObjectiveRequest;
class DeleteObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: DeleteObjectiveResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteObjectiveResponseBody = DeleteObjectiveResponseBody;
class DeleteObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteObjectiveResponse = DeleteObjectiveResponse;
class DeletePermissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionHeaders = DeletePermissionHeaders;
class DeletePermissionRequest extends $tea.Model {
    static names() {
        return {
            id: 'id',
            policyType: 'policyType',
            targetId: 'targetId',
            targetType: 'targetType',
            type: 'type',
            userId: 'userId',
        };
    }
    static types() {
        return {
            id: 'string',
            policyType: 'number',
            targetId: 'string',
            targetType: 'string',
            type: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionRequest = DeletePermissionRequest;
class DeletePermissionResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: DeletePermissionResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionResponseBody = DeletePermissionResponseBody;
class DeletePermissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePermissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionResponse = DeletePermissionResponse;
class GetPeriodListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPeriodListHeaders = GetPeriodListHeaders;
class GetPeriodListResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: GetPeriodListResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPeriodListResponseBody = GetPeriodListResponseBody;
class GetPeriodListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPeriodListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPeriodListResponse = GetPeriodListResponse;
class GetPermissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionHeaders = GetPermissionHeaders;
class GetPermissionRequest extends $tea.Model {
    static names() {
        return {
            targetId: 'targetId',
            targetType: 'targetType',
            userId: 'userId',
            withKr: 'withKr',
            withObjective: 'withObjective',
        };
    }
    static types() {
        return {
            targetId: 'string',
            targetType: 'string',
            userId: 'string',
            withKr: 'boolean',
            withObjective: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionRequest = GetPermissionRequest;
class GetPermissionResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: GetPermissionResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionResponseBody = GetPermissionResponseBody;
class GetPermissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPermissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionResponse = GetPermissionResponse;
class GetUserOkrHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrHeaders = GetUserOkrHeaders;
class GetUserOkrRequest extends $tea.Model {
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            periodId: 'periodId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            periodId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrRequest = GetUserOkrRequest;
class GetUserOkrResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: GetUserOkrResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBody = GetUserOkrResponseBody;
class GetUserOkrResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserOkrResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponse = GetUserOkrResponse;
class OkrObjectivesBatchHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesBatchHeaders = OkrObjectivesBatchHeaders;
class OkrObjectivesBatchRequest extends $tea.Model {
    static names() {
        return {
            goodsCode: 'goodsCode',
            objectiveIds: 'objectiveIds',
        };
    }
    static types() {
        return {
            goodsCode: 'string',
            objectiveIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesBatchRequest = OkrObjectivesBatchRequest;
class OkrObjectivesBatchResponseBody extends $tea.Model {
    static names() {
        return {
            content: 'content',
            success: 'success',
        };
    }
    static types() {
        return {
            content: { 'type': 'array', 'itemType': OpenObjectiveDTO },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesBatchResponseBody = OkrObjectivesBatchResponseBody;
class OkrObjectivesBatchResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OkrObjectivesBatchResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesBatchResponse = OkrObjectivesBatchResponse;
class OkrObjectivesByUserHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesByUserHeaders = OkrObjectivesByUserHeaders;
class OkrObjectivesByUserRequest extends $tea.Model {
    static names() {
        return {
            goodsCode: 'goodsCode',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            goodsCode: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesByUserRequest = OkrObjectivesByUserRequest;
class OkrObjectivesByUserResponseBody extends $tea.Model {
    static names() {
        return {
            content: 'content',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            content: OkrObjectivesByUserResponseBodyContent,
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesByUserResponseBody = OkrObjectivesByUserResponseBody;
class OkrObjectivesByUserResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OkrObjectivesByUserResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesByUserResponse = OkrObjectivesByUserResponse;
class OkrPeriodsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrPeriodsHeaders = OkrPeriodsHeaders;
class OkrPeriodsRequest extends $tea.Model {
    static names() {
        return {
            goodsCode: 'goodsCode',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            status: 'status',
        };
    }
    static types() {
        return {
            goodsCode: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrPeriodsRequest = OkrPeriodsRequest;
class OkrPeriodsResponseBody extends $tea.Model {
    static names() {
        return {
            content: 'content',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            content: OkrPeriodsResponseBodyContent,
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrPeriodsResponseBody = OkrPeriodsResponseBody;
class OkrPeriodsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OkrPeriodsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrPeriodsResponse = OkrPeriodsResponse;
class UnAlignObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnAlignObjectiveHeaders = UnAlignObjectiveHeaders;
class UnAlignObjectiveRequest extends $tea.Model {
    static names() {
        return {
            periodId: 'periodId',
            targetId: 'targetId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            periodId: 'string',
            targetId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnAlignObjectiveRequest = UnAlignObjectiveRequest;
class UnAlignObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: UnAlignObjectiveResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnAlignObjectiveResponseBody = UnAlignObjectiveResponseBody;
class UnAlignObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnAlignObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnAlignObjectiveResponse = UnAlignObjectiveResponse;
class UpdateKROfContentHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfContentHeaders = UpdateKROfContentHeaders;
class UpdateKROfContentRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            updateQuoteList: 'updateQuoteList',
            krId: 'krId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            content: 'string',
            updateQuoteList: { 'type': 'array', 'itemType': 'string' },
            krId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfContentRequest = UpdateKROfContentRequest;
class UpdateKROfContentResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfContentResponseBody = UpdateKROfContentResponseBody;
class UpdateKROfContentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateKROfContentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfContentResponse = UpdateKROfContentResponse;
class UpdateKROfScoreHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfScoreHeaders = UpdateKROfScoreHeaders;
class UpdateKROfScoreRequest extends $tea.Model {
    static names() {
        return {
            score: 'score',
            krId: 'krId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            score: 'number',
            krId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfScoreRequest = UpdateKROfScoreRequest;
class UpdateKROfScoreResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: UpdateKROfScoreResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfScoreResponseBody = UpdateKROfScoreResponseBody;
class UpdateKROfScoreResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateKROfScoreResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfScoreResponse = UpdateKROfScoreResponse;
class UpdateKROfWeightHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightHeaders = UpdateKROfWeightHeaders;
class UpdateKROfWeightRequest extends $tea.Model {
    static names() {
        return {
            weight: 'weight',
            krId: 'krId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            weight: 'number',
            krId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightRequest = UpdateKROfWeightRequest;
class UpdateKROfWeightResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: UpdateKROfWeightResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightResponseBody = UpdateKROfWeightResponseBody;
class UpdateKROfWeightResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateKROfWeightResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightResponse = UpdateKROfWeightResponse;
class UpdateObjectiveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateObjectiveHeaders = UpdateObjectiveHeaders;
class UpdateObjectiveRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            userId: 'userId',
        };
    }
    static types() {
        return {
            content: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateObjectiveRequest = UpdateObjectiveRequest;
class UpdateObjectiveResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: UpdateObjectiveResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateObjectiveResponseBody = UpdateObjectiveResponseBody;
class UpdateObjectiveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateObjectiveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateObjectiveResponse = UpdateObjectiveResponse;
class UpdatePrivacyHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyHeaders = UpdatePrivacyHeaders;
class UpdatePrivacyRequest extends $tea.Model {
    static names() {
        return {
            privacy: 'privacy',
            targetId: 'targetId',
            targetType: 'targetType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            privacy: 'string',
            targetId: 'string',
            targetType: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyRequest = UpdatePrivacyRequest;
class UpdatePrivacyResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: UpdatePrivacyResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyResponseBody = UpdatePrivacyResponseBody;
class UpdatePrivacyResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdatePrivacyResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyResponse = UpdatePrivacyResponse;
class AlignObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            alignId: 'alignId',
            id: 'id',
        };
    }
    static types() {
        return {
            alignId: 'Readable',
            id: 'Readable',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AlignObjectiveResponseBodyData = AlignObjectiveResponseBodyData;
class BatchAddPermissionRequestListMember extends $tea.Model {
    static names() {
        return {
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionRequestListMember = BatchAddPermissionRequestListMember;
class BatchAddPermissionRequestList extends $tea.Model {
    static names() {
        return {
            member: 'member',
            policyType: 'policyType',
        };
    }
    static types() {
        return {
            member: BatchAddPermissionRequestListMember,
            policyType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionRequestList = BatchAddPermissionRequestList;
class BatchAddPermissionResponseBodyDataPermissionTreePolicyListMemberList extends $tea.Model {
    static names() {
        return {
            id: 'id',
            nickname: 'nickname',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            nickname: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponseBodyDataPermissionTreePolicyListMemberList = BatchAddPermissionResponseBodyDataPermissionTreePolicyListMemberList;
class BatchAddPermissionResponseBodyDataPermissionTreePolicyList extends $tea.Model {
    static names() {
        return {
            memberList: 'memberList',
            name: 'name',
            type: 'type',
        };
    }
    static types() {
        return {
            memberList: { 'type': 'array', 'itemType': BatchAddPermissionResponseBodyDataPermissionTreePolicyListMemberList },
            name: 'string',
            type: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponseBodyDataPermissionTreePolicyList = BatchAddPermissionResponseBodyDataPermissionTreePolicyList;
class BatchAddPermissionResponseBodyDataPermissionTree extends $tea.Model {
    static names() {
        return {
            id: 'id',
            policyList: 'policyList',
            privacy: 'privacy',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            policyList: { 'type': 'array', 'itemType': BatchAddPermissionResponseBodyDataPermissionTreePolicyList },
            privacy: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponseBodyDataPermissionTree = BatchAddPermissionResponseBodyDataPermissionTree;
class BatchAddPermissionResponseBodyData extends $tea.Model {
    static names() {
        return {
            hasInvalidUser: 'hasInvalidUser',
            permissionTree: 'permissionTree',
        };
    }
    static types() {
        return {
            hasInvalidUser: 'boolean',
            permissionTree: BatchAddPermissionResponseBodyDataPermissionTree,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchAddPermissionResponseBodyData = BatchAddPermissionResponseBodyData;
class BatchQueryObjectiveResponseBodyDataKrListProgress extends $tea.Model {
    static names() {
        return {
            percent: 'percent',
        };
    }
    static types() {
        return {
            percent: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBodyDataKrListProgress = BatchQueryObjectiveResponseBodyDataKrListProgress;
class BatchQueryObjectiveResponseBodyDataKrList extends $tea.Model {
    static names() {
        return {
            content: 'content',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            id: 'id',
            objectiveId: 'objectiveId',
            permission: 'permission',
            position: 'position',
            progress: 'progress',
            score: 'score',
            weight: 'weight',
        };
    }
    static types() {
        return {
            content: 'Readable',
            gmtCreate: 'number',
            gmtModified: 'number',
            id: 'Readable',
            objectiveId: 'Readable',
            permission: { 'type': 'array', 'itemType': 'number' },
            position: 'number',
            progress: BatchQueryObjectiveResponseBodyDataKrListProgress,
            score: 'number',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBodyDataKrList = BatchQueryObjectiveResponseBodyDataKrList;
class BatchQueryObjectiveResponseBodyDataOwner extends $tea.Model {
    static names() {
        return {
            avatarMediaId: 'avatarMediaId',
            corpId: 'corpId',
            id: 'id',
            nickname: 'nickname',
            userId: 'userId',
        };
    }
    static types() {
        return {
            avatarMediaId: 'Readable',
            corpId: 'Readable',
            id: 'Readable',
            nickname: 'Readable',
            userId: 'Readable',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBodyDataOwner = BatchQueryObjectiveResponseBodyDataOwner;
class BatchQueryObjectiveResponseBodyDataProgress extends $tea.Model {
    static names() {
        return {
            percent: 'percent',
        };
    }
    static types() {
        return {
            percent: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBodyDataProgress = BatchQueryObjectiveResponseBodyDataProgress;
class BatchQueryObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            alignFromIds: 'alignFromIds',
            alignToIds: 'alignToIds',
            content: 'content',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            id: 'id',
            krList: 'krList',
            owner: 'owner',
            periodId: 'periodId',
            permission: 'permission',
            position: 'position',
            progress: 'progress',
            progressPercent: 'progressPercent',
            published: 'published',
            score: 'score',
            status: 'status',
            userId: 'userId',
            weight: 'weight',
        };
    }
    static types() {
        return {
            alignFromIds: { 'type': 'array', 'itemType': 'Readable' },
            alignToIds: { 'type': 'array', 'itemType': 'Readable' },
            content: 'Readable',
            gmtCreate: 'number',
            gmtModified: 'number',
            id: 'Readable',
            krList: { 'type': 'array', 'itemType': BatchQueryObjectiveResponseBodyDataKrList },
            owner: BatchQueryObjectiveResponseBodyDataOwner,
            periodId: 'Readable',
            permission: { 'type': 'array', 'itemType': 'number' },
            position: 'number',
            progress: BatchQueryObjectiveResponseBodyDataProgress,
            progressPercent: 'number',
            published: 'boolean',
            score: 'number',
            status: 'number',
            userId: 'Readable',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryObjectiveResponseBodyData = BatchQueryObjectiveResponseBodyData;
class BatchQueryUserResponseBodyData extends $tea.Model {
    static names() {
        return {
            avatarMediaId: 'avatarMediaId',
            avatarUrl: 'avatarUrl',
            corpId: 'corpId',
            id: 'id',
            nickname: 'nickname',
            userId: 'userId',
        };
    }
    static types() {
        return {
            avatarMediaId: 'Readable',
            avatarUrl: 'Readable',
            corpId: 'Readable',
            id: 'Readable',
            nickname: 'Readable',
            userId: 'Readable',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryUserResponseBodyData = BatchQueryUserResponseBodyData;
class CreateKeyResultResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            position: 'position',
            weight: 'weight',
        };
    }
    static types() {
        return {
            id: 'Readable',
            position: 'number',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateKeyResultResponseBodyData = CreateKeyResultResponseBodyData;
class CreateObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            position: 'position',
        };
    }
    static types() {
        return {
            id: 'string',
            position: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateObjectiveResponseBodyData = CreateObjectiveResponseBodyData;
class DeleteObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteObjectiveResponseBodyData = DeleteObjectiveResponseBodyData;
class DeletePermissionResponseBodyDataPolicyListMemberList extends $tea.Model {
    static names() {
        return {
            id: 'id',
            nickname: 'nickname',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            nickname: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionResponseBodyDataPolicyListMemberList = DeletePermissionResponseBodyDataPolicyListMemberList;
class DeletePermissionResponseBodyDataPolicyList extends $tea.Model {
    static names() {
        return {
            memberList: 'memberList',
            name: 'name',
            type: 'type',
        };
    }
    static types() {
        return {
            memberList: { 'type': 'array', 'itemType': DeletePermissionResponseBodyDataPolicyListMemberList },
            name: 'string',
            type: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionResponseBodyDataPolicyList = DeletePermissionResponseBodyDataPolicyList;
class DeletePermissionResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            policyList: 'policyList',
            privacy: 'privacy',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            policyList: { 'type': 'array', 'itemType': DeletePermissionResponseBodyDataPolicyList },
            privacy: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePermissionResponseBodyData = DeletePermissionResponseBodyData;
class GetPeriodListResponseBodyDataPeriodList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            id: 'id',
            isCurrent: 'isCurrent',
            isYearly: 'isYearly',
            name: 'name',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'number',
            id: 'Readable',
            isCurrent: 'boolean',
            isYearly: 'boolean',
            name: 'Readable',
            startTime: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPeriodListResponseBodyDataPeriodList = GetPeriodListResponseBodyDataPeriodList;
class GetPeriodListResponseBodyData extends $tea.Model {
    static names() {
        return {
            periodList: 'periodList',
        };
    }
    static types() {
        return {
            periodList: { 'type': 'array', 'itemType': GetPeriodListResponseBodyDataPeriodList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPeriodListResponseBodyData = GetPeriodListResponseBodyData;
class GetPermissionResponseBodyDataPolicyListMemberList extends $tea.Model {
    static names() {
        return {
            id: 'id',
            nickname: 'nickname',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            nickname: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionResponseBodyDataPolicyListMemberList = GetPermissionResponseBodyDataPolicyListMemberList;
class GetPermissionResponseBodyDataPolicyList extends $tea.Model {
    static names() {
        return {
            memberList: 'memberList',
            name: 'name',
            type: 'type',
        };
    }
    static types() {
        return {
            memberList: { 'type': 'array', 'itemType': GetPermissionResponseBodyDataPolicyListMemberList },
            name: 'string',
            type: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionResponseBodyDataPolicyList = GetPermissionResponseBodyDataPolicyList;
class GetPermissionResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            policyList: 'policyList',
            privacy: 'privacy',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            policyList: { 'type': 'array', 'itemType': GetPermissionResponseBodyDataPolicyList },
            privacy: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPermissionResponseBodyData = GetPermissionResponseBodyData;
class GetUserOkrResponseBodyDataListKrListProgress extends $tea.Model {
    static names() {
        return {
            percent: 'percent',
        };
    }
    static types() {
        return {
            percent: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyDataListKrListProgress = GetUserOkrResponseBodyDataListKrListProgress;
class GetUserOkrResponseBodyDataListKrList extends $tea.Model {
    static names() {
        return {
            content: 'content',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            id: 'id',
            objectiveId: 'objectiveId',
            permission: 'permission',
            position: 'position',
            progress: 'progress',
            score: 'score',
            weight: 'weight',
        };
    }
    static types() {
        return {
            content: 'Readable',
            gmtCreate: 'number',
            gmtModified: 'number',
            id: 'Readable',
            objectiveId: 'Readable',
            permission: { 'type': 'array', 'itemType': 'number' },
            position: 'number',
            progress: GetUserOkrResponseBodyDataListKrListProgress,
            score: 'number',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyDataListKrList = GetUserOkrResponseBodyDataListKrList;
class GetUserOkrResponseBodyDataListOwner extends $tea.Model {
    static names() {
        return {
            avatarMediaId: 'avatarMediaId',
            corpId: 'corpId',
            id: 'id',
            nickname: 'nickname',
            userId: 'userId',
        };
    }
    static types() {
        return {
            avatarMediaId: 'Readable',
            corpId: 'Readable',
            id: 'Readable',
            nickname: 'Readable',
            userId: 'Readable',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyDataListOwner = GetUserOkrResponseBodyDataListOwner;
class GetUserOkrResponseBodyDataListProgress extends $tea.Model {
    static names() {
        return {
            percent: 'percent',
        };
    }
    static types() {
        return {
            percent: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyDataListProgress = GetUserOkrResponseBodyDataListProgress;
class GetUserOkrResponseBodyDataList extends $tea.Model {
    static names() {
        return {
            alignFromIds: 'alignFromIds',
            alignToIds: 'alignToIds',
            content: 'content',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            id: 'id',
            krList: 'krList',
            owner: 'owner',
            periodId: 'periodId',
            permission: 'permission',
            position: 'position',
            progress: 'progress',
            progressPercent: 'progressPercent',
            published: 'published',
            score: 'score',
            status: 'status',
            userId: 'userId',
            weight: 'weight',
        };
    }
    static types() {
        return {
            alignFromIds: { 'type': 'array', 'itemType': 'Readable' },
            alignToIds: { 'type': 'array', 'itemType': 'Readable' },
            content: 'Readable',
            gmtCreate: 'number',
            gmtModified: 'number',
            id: 'Readable',
            krList: { 'type': 'array', 'itemType': GetUserOkrResponseBodyDataListKrList },
            owner: GetUserOkrResponseBodyDataListOwner,
            periodId: 'Readable',
            permission: { 'type': 'array', 'itemType': 'number' },
            position: 'number',
            progress: GetUserOkrResponseBodyDataListProgress,
            progressPercent: 'number',
            published: 'boolean',
            score: 'number',
            status: 'number',
            userId: 'Readable',
            weight: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyDataList = GetUserOkrResponseBodyDataList;
class GetUserOkrResponseBodyData extends $tea.Model {
    static names() {
        return {
            list: 'list',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetUserOkrResponseBodyDataList },
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserOkrResponseBodyData = GetUserOkrResponseBodyData;
class OkrObjectivesByUserResponseBodyContent extends $tea.Model {
    static names() {
        return {
            result: 'result',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': OpenObjectiveDTO },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrObjectivesByUserResponseBodyContent = OkrObjectivesByUserResponseBodyContent;
class OkrPeriodsResponseBodyContent extends $tea.Model {
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            result: 'result',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            result: { 'type': 'array', 'itemType': OpenPeriodDTO },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OkrPeriodsResponseBodyContent = OkrPeriodsResponseBodyContent;
class UnAlignObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            alignId: 'alignId',
            id: 'id',
        };
    }
    static types() {
        return {
            alignId: 'Readable',
            id: 'Readable',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnAlignObjectiveResponseBodyData = UnAlignObjectiveResponseBodyData;
class UpdateKROfScoreResponseBodyData extends $tea.Model {
    static names() {
        return {
            objectiveScore: 'objectiveScore',
        };
    }
    static types() {
        return {
            objectiveScore: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfScoreResponseBodyData = UpdateKROfScoreResponseBodyData;
class UpdateKROfWeightResponseBodyDataObjectiveProgress extends $tea.Model {
    static names() {
        return {
            percent: 'percent',
        };
    }
    static types() {
        return {
            percent: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightResponseBodyDataObjectiveProgress = UpdateKROfWeightResponseBodyDataObjectiveProgress;
class UpdateKROfWeightResponseBodyData extends $tea.Model {
    static names() {
        return {
            objectiveProgress: 'objectiveProgress',
            objectiveScore: 'objectiveScore',
        };
    }
    static types() {
        return {
            objectiveProgress: UpdateKROfWeightResponseBodyDataObjectiveProgress,
            objectiveScore: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateKROfWeightResponseBodyData = UpdateKROfWeightResponseBodyData;
class UpdateObjectiveResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            position: 'position',
        };
    }
    static types() {
        return {
            id: 'string',
            position: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateObjectiveResponseBodyData = UpdateObjectiveResponseBodyData;
class UpdatePrivacyResponseBodyDataPolicyListMemberList extends $tea.Model {
    static names() {
        return {
            id: 'id',
            nickname: 'nickname',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            nickname: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyResponseBodyDataPolicyListMemberList = UpdatePrivacyResponseBodyDataPolicyListMemberList;
class UpdatePrivacyResponseBodyDataPolicyList extends $tea.Model {
    static names() {
        return {
            memberList: 'memberList',
            name: 'name',
            type: 'type',
        };
    }
    static types() {
        return {
            memberList: { 'type': 'array', 'itemType': UpdatePrivacyResponseBodyDataPolicyListMemberList },
            name: 'string',
            type: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyResponseBodyDataPolicyList = UpdatePrivacyResponseBodyDataPolicyList;
class UpdatePrivacyResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'id',
            policyList: 'policyList',
            privacy: 'privacy',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            policyList: { 'type': 'array', 'itemType': UpdatePrivacyResponseBodyDataPolicyList },
            privacy: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePrivacyResponseBodyData = UpdatePrivacyResponseBodyData;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request AlignObjectiveRequest
     * @param headers AlignObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AlignObjectiveResponse
     */
    async alignObjectiveWithOptions(objectiveId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.periodId)) {
            body["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.targetId)) {
            body["targetId"] = request.targetId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AlignObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives/${objectiveId}/alignments`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AlignObjectiveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AlignObjectiveRequest
     * @return AlignObjectiveResponse
     */
    async alignObjective(objectiveId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AlignObjectiveHeaders({});
        return await this.alignObjectiveWithOptions(objectiveId, request, headers, runtime);
    }
    /**
     * @summary  
     *
     * @param request BatchAddPermissionRequest
     * @param headers BatchAddPermissionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchAddPermissionResponse
     */
    async batchAddPermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.list)) {
            body["list"] = request.list;
        }
        if (!tea_util_1.default.isUnset(request.targetId)) {
            body["targetId"] = request.targetId;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            body["targetType"] = request.targetType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddPermission",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/permissions/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchAddPermissionResponse({}));
    }
    /**
     * @summary  
     *
     * @param request BatchAddPermissionRequest
     * @return BatchAddPermissionResponse
     */
    async batchAddPermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchAddPermissionHeaders({});
        return await this.batchAddPermissionWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchQueryObjectiveRequest
     * @param headers BatchQueryObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchQueryObjectiveResponse
     */
    async batchQueryObjectiveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.objectiveIds)) {
            body["objectiveIds"] = request.objectiveIds;
        }
        if (!tea_util_1.default.isUnset(request.periodId)) {
            body["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.withAlign)) {
            body["withAlign"] = request.withAlign;
        }
        if (!tea_util_1.default.isUnset(request.withKr)) {
            body["withKr"] = request.withKr;
        }
        if (!tea_util_1.default.isUnset(request.withProgress)) {
            body["withProgress"] = request.withProgress;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryObjectiveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchQueryObjectiveRequest
     * @return BatchQueryObjectiveResponse
     */
    async batchQueryObjective(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryObjectiveHeaders({});
        return await this.batchQueryObjectiveWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchQueryUserRequest
     * @param headers BatchQueryUserHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchQueryUserResponse
     */
    async batchQueryUserWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.okrUserIds)) {
            body["okrUserIds"] = request.okrUserIds;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryUser",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/users/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryUserResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchQueryUserRequest
     * @return BatchQueryUserResponse
     */
    async batchQueryUser(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryUserHeaders({});
        return await this.batchQueryUserWithOptions(request, headers, runtime);
    }
    /**
     * @summary keyResult
     *
     * @param request CreateKeyResultRequest
     * @param headers CreateKeyResultHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateKeyResultResponse
     */
    async createKeyResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.objectiveId)) {
            body["objectiveId"] = request.objectiveId;
        }
        if (!tea_util_1.default.isUnset(request.periodId)) {
            body["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.prevPosition)) {
            body["prevPosition"] = request.prevPosition;
        }
        if (!tea_util_1.default.isUnset(request.weight)) {
            body["weight"] = request.weight;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateKeyResult",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/keyResults`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateKeyResultResponse({}));
    }
    /**
     * @summary keyResult
     *
     * @param request CreateKeyResultRequest
     * @return CreateKeyResultResponse
     */
    async createKeyResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateKeyResultHeaders({});
        return await this.createKeyResultWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateObjectiveRequest
     * @param headers CreateObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateObjectiveResponse
     */
    async createObjectiveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.periodId)) {
            body["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.prevPosition)) {
            body["prevPosition"] = request.prevPosition;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateObjectiveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateObjectiveRequest
     * @return CreateObjectiveResponse
     */
    async createObjective(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateObjectiveHeaders({});
        return await this.createObjectiveWithOptions(request, headers, runtime);
    }
    /**
     * @summary keyresult
     *
     * @param request DeleteKeyResultRequest
     * @param headers DeleteKeyResultHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteKeyResultResponse
     */
    async deleteKeyResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.krId)) {
            query["krId"] = request.krId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteKeyResult",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/keyResults`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteKeyResultResponse({}));
    }
    /**
     * @summary keyresult
     *
     * @param request DeleteKeyResultRequest
     * @return DeleteKeyResultResponse
     */
    async deleteKeyResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteKeyResultHeaders({});
        return await this.deleteKeyResultWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteObjectiveRequest
     * @param headers DeleteObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteObjectiveResponse
     */
    async deleteObjectiveWithOptions(objectiveId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives/${objectiveId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteObjectiveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteObjectiveRequest
     * @return DeleteObjectiveResponse
     */
    async deleteObjective(objectiveId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteObjectiveHeaders({});
        return await this.deleteObjectiveWithOptions(objectiveId, request, headers, runtime);
    }
    /**
     * @summary  
     *
     * @param request DeletePermissionRequest
     * @param headers DeletePermissionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeletePermissionResponse
     */
    async deletePermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.id)) {
            query["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.policyType)) {
            query["policyType"] = request.policyType;
        }
        if (!tea_util_1.default.isUnset(request.targetId)) {
            query["targetId"] = request.targetId;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            query["targetType"] = request.targetType;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeletePermission",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/permissions/delete`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeletePermissionResponse({}));
    }
    /**
     * @summary  
     *
     * @param request DeletePermissionRequest
     * @return DeletePermissionResponse
     */
    async deletePermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeletePermissionHeaders({});
        return await this.deletePermissionWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers GetPeriodListHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetPeriodListResponse
     */
    async getPeriodListWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetPeriodList",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/periods`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetPeriodListResponse({}));
    }
    /**
     * @summary 
     *
     * @return GetPeriodListResponse
     */
    async getPeriodList() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPeriodListHeaders({});
        return await this.getPeriodListWithOptions(headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetPermissionRequest
     * @param headers GetPermissionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetPermissionResponse
     */
    async getPermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.targetId)) {
            query["targetId"] = request.targetId;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            query["targetType"] = request.targetType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.withKr)) {
            query["withKr"] = request.withKr;
        }
        if (!tea_util_1.default.isUnset(request.withObjective)) {
            query["withObjective"] = request.withObjective;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetPermission",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/permissions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetPermissionResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetPermissionRequest
     * @return GetPermissionResponse
     */
    async getPermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPermissionHeaders({});
        return await this.getPermissionWithOptions(request, headers, runtime);
    }
    /**
     * @summary   OKR 
     *
     * @param request GetUserOkrRequest
     * @param headers GetUserOkrHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetUserOkrResponse
     */
    async getUserOkrWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.periodId)) {
            query["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserOkr",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/users/okrs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserOkrResponse({}));
    }
    /**
     * @summary   OKR 
     *
     * @param request GetUserOkrRequest
     * @return GetUserOkrResponse
     */
    async getUserOkr(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserOkrHeaders({});
        return await this.getUserOkrWithOptions(request, headers, runtime);
    }
    /**
     * @summary OKR
     *
     * @param request OkrObjectivesBatchRequest
     * @param headers OkrObjectivesBatchHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return OkrObjectivesBatchResponse
     */
    async okrObjectivesBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.goodsCode)) {
            body["goodsCode"] = request.goodsCode;
        }
        if (!tea_util_1.default.isUnset(request.objectiveIds)) {
            body["objectiveIds"] = request.objectiveIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OkrObjectivesBatch",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/pro/objectives/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OkrObjectivesBatchResponse({}));
    }
    /**
     * @summary OKR
     *
     * @param request OkrObjectivesBatchRequest
     * @return OkrObjectivesBatchResponse
     */
    async okrObjectivesBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OkrObjectivesBatchHeaders({});
        return await this.okrObjectivesBatchWithOptions(request, headers, runtime);
    }
    /**
     * @summary OKR
     *
     * @param request OkrObjectivesByUserRequest
     * @param headers OkrObjectivesByUserHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return OkrObjectivesByUserResponse
     */
    async okrObjectivesByUserWithOptions(dingUserId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.goodsCode)) {
            query["goodsCode"] = request.goodsCode;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "OkrObjectivesByUser",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/pro/users/${dingUserId}/objectives`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OkrObjectivesByUserResponse({}));
    }
    /**
     * @summary OKR
     *
     * @param request OkrObjectivesByUserRequest
     * @return OkrObjectivesByUserResponse
     */
    async okrObjectivesByUser(dingUserId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OkrObjectivesByUserHeaders({});
        return await this.okrObjectivesByUserWithOptions(dingUserId, request, headers, runtime);
    }
    /**
     * @summary  OKR 
     *
     * @param request OkrPeriodsRequest
     * @param headers OkrPeriodsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return OkrPeriodsResponse
     */
    async okrPeriodsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.goodsCode)) {
            query["goodsCode"] = request.goodsCode;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            query["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "OkrPeriods",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/pro/periods`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OkrPeriodsResponse({}));
    }
    /**
     * @summary  OKR 
     *
     * @param request OkrPeriodsRequest
     * @return OkrPeriodsResponse
     */
    async okrPeriods(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OkrPeriodsHeaders({});
        return await this.okrPeriodsWithOptions(request, headers, runtime);
    }
    /**
     * @summary  Objective
     *
     * @param request UnAlignObjectiveRequest
     * @param headers UnAlignObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UnAlignObjectiveResponse
     */
    async unAlignObjectiveWithOptions(objectiveId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.periodId)) {
            body["periodId"] = request.periodId;
        }
        if (!tea_util_1.default.isUnset(request.targetId)) {
            body["targetId"] = request.targetId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UnAlignObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives/${objectiveId}/alignments/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UnAlignObjectiveResponse({}));
    }
    /**
     * @summary  Objective
     *
     * @param request UnAlignObjectiveRequest
     * @return UnAlignObjectiveResponse
     */
    async unAlignObjective(objectiveId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UnAlignObjectiveHeaders({});
        return await this.unAlignObjectiveWithOptions(objectiveId, request, headers, runtime);
    }
    /**
     * @summary KR
     *
     * @param request UpdateKROfContentRequest
     * @param headers UpdateKROfContentHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateKROfContentResponse
     */
    async updateKROfContentWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.krId)) {
            query["krId"] = request.krId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.updateQuoteList)) {
            body["updateQuoteList"] = request.updateQuoteList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateKROfContent",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/keyResults/contents`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateKROfContentResponse({}));
    }
    /**
     * @summary KR
     *
     * @param request UpdateKROfContentRequest
     * @return UpdateKROfContentResponse
     */
    async updateKROfContent(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateKROfContentHeaders({});
        return await this.updateKROfContentWithOptions(request, headers, runtime);
    }
    /**
     * @summary KR
     *
     * @param request UpdateKROfScoreRequest
     * @param headers UpdateKROfScoreHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateKROfScoreResponse
     */
    async updateKROfScoreWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.krId)) {
            query["krId"] = request.krId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.score)) {
            body["score"] = request.score;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateKROfScore",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/keyResults/scores`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateKROfScoreResponse({}));
    }
    /**
     * @summary KR
     *
     * @param request UpdateKROfScoreRequest
     * @return UpdateKROfScoreResponse
     */
    async updateKROfScore(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateKROfScoreHeaders({});
        return await this.updateKROfScoreWithOptions(request, headers, runtime);
    }
    /**
     * @summary  KR 
     *
     * @param request UpdateKROfWeightRequest
     * @param headers UpdateKROfWeightHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateKROfWeightResponse
     */
    async updateKROfWeightWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.krId)) {
            query["krId"] = request.krId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.weight)) {
            body["weight"] = request.weight;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateKROfWeight",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/keyResults/weights`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateKROfWeightResponse({}));
    }
    /**
     * @summary  KR 
     *
     * @param request UpdateKROfWeightRequest
     * @return UpdateKROfWeightResponse
     */
    async updateKROfWeight(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateKROfWeightHeaders({});
        return await this.updateKROfWeightWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateObjectiveRequest
     * @param headers UpdateObjectiveHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateObjectiveResponse
     */
    async updateObjectiveWithOptions(objectiveId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateObjective",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/objectives/${objectiveId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateObjectiveResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateObjectiveRequest
     * @return UpdateObjectiveResponse
     */
    async updateObjective(objectiveId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateObjectiveHeaders({});
        return await this.updateObjectiveWithOptions(objectiveId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdatePrivacyRequest
     * @param headers UpdatePrivacyHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdatePrivacyResponse
     */
    async updatePrivacyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.privacy)) {
            body["privacy"] = request.privacy;
        }
        if (!tea_util_1.default.isUnset(request.targetId)) {
            body["targetId"] = request.targetId;
        }
        if (!tea_util_1.default.isUnset(request.targetType)) {
            body["targetType"] = request.targetType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdatePrivacy",
            version: "okr_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/okr/permissions/privacies`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdatePrivacyResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdatePrivacyRequest
     * @return UpdatePrivacyResponse
     */
    async updatePrivacy(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdatePrivacyHeaders({});
        return await this.updatePrivacyWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map