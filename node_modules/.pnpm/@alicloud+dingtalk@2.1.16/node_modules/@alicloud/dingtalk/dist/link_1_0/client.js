"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendInteractiveOTOMessageResponseBody = exports.SendInteractiveOTOMessageRequest = exports.SendInteractiveOTOMessageHeaders = exports.SendAgentOTOMessageResponse = exports.SendAgentOTOMessageResponseBody = exports.SendAgentOTOMessageRequest = exports.SendAgentOTOMessageHeaders = exports.QueryUserFollowStatusResponse = exports.QueryUserFollowStatusResponseBody = exports.QueryUserFollowStatusRequest = exports.QueryUserFollowStatusHeaders = exports.ListFollowerResponse = exports.ListFollowerResponseBody = exports.ListFollowerRequest = exports.ListFollowerHeaders = exports.ListAccountInfoResponse = exports.ListAccountInfoResponseBody = exports.ListAccountInfoHeaders = exports.ListAccountResponse = exports.ListAccountResponseBody = exports.ListAccountHeaders = exports.GetUserFollowStatusResponse = exports.GetUserFollowStatusResponseBody = exports.GetUserFollowStatusRequest = exports.GetUserFollowStatusHeaders = exports.GetPictureDownloadUrlResponse = exports.GetPictureDownloadUrlResponseBody = exports.GetPictureDownloadUrlRequest = exports.GetPictureDownloadUrlHeaders = exports.GetFollowerInfoResponse = exports.GetFollowerInfoResponseBody = exports.GetFollowerInfoRequest = exports.GetFollowerInfoHeaders = exports.GetFollowerAuthInfoResponse = exports.GetFollowerAuthInfoResponseBody = exports.GetFollowerAuthInfoRequest = exports.GetFollowerAuthInfoHeaders = exports.CloseTopBoxInteractiveOTOMessageResponse = exports.CloseTopBoxInteractiveOTOMessageResponseBody = exports.CloseTopBoxInteractiveOTOMessageRequest = exports.CloseTopBoxInteractiveOTOMessageHeaders = exports.CallbackRegiesterResponse = exports.CallbackRegiesterResponseBody = exports.CallbackRegiesterRequest = exports.CallbackRegiesterHeaders = exports.ApplyFollowerAuthInfoResponse = exports.ApplyFollowerAuthInfoResponseBody = exports.ApplyFollowerAuthInfoRequest = exports.ApplyFollowerAuthInfoHeaders = exports.DetailUserIdPrivateDataMapValue = void 0;
exports.UpdateShortcutsRequestDetails = exports.UpdateInteractiveOTOMessageResponseBodyResult = exports.UpdateInteractiveOTOMessageRequestDetail = exports.UpdateInteractiveOTOMessageRequestDetailUpdateOptions = exports.SendTopBoxInteractiveOTOMessageRequestDetail = exports.SendTopBoxInteractiveOTOMessageRequestDetailCardData = exports.SendInteractiveOTOMessageResponseBodyResult = exports.SendInteractiveOTOMessageRequestDetail = exports.SendAgentOTOMessageResponseBodyResult = exports.SendAgentOTOMessageRequestDetail = exports.SendAgentOTOMessageRequestDetailMessageBody = exports.SendAgentOTOMessageRequestDetailMessageBodyText = exports.SendAgentOTOMessageRequestDetailMessageBodyMarkdown = exports.SendAgentOTOMessageRequestDetailMessageBodyLink = exports.SendAgentOTOMessageRequestDetailMessageBodyInteractiveMessage = exports.SendAgentOTOMessageRequestDetailMessageBodyImage = exports.SendAgentOTOMessageRequestDetailMessageBodyActionCard = exports.SendAgentOTOMessageRequestDetailMessageBodyActionCardButtonList = exports.QueryUserFollowStatusResponseBodyResult = exports.ListFollowerResponseBodyResult = exports.ListFollowerResponseBodyResultUserList = exports.ListAccountInfoResponseBodyResult = exports.ListAccountResponseBodyResult = exports.GetUserFollowStatusResponseBodyResult = exports.GetPictureDownloadUrlResponseBodyResult = exports.GetFollowerInfoResponseBodyResult = exports.GetFollowerInfoResponseBodyResultUser = exports.GetFollowerAuthInfoResponseBodyResult = exports.GetFollowerAuthInfoResponseBodyResultAuthInfo = exports.GetFollowerAuthInfoResponseBodyResultAuthInfoMobile = exports.GetFollowerAuthInfoResponseBodyResultAuthInfoMainCorp = exports.CloseTopBoxInteractiveOTOMessageRequestDetail = exports.CallbackRegiesterResponseBodyResult = exports.ApplyFollowerAuthInfoResponseBodyResult = exports.UpdateShortcutsResponse = exports.UpdateShortcutsResponseBody = exports.UpdateShortcutsRequest = exports.UpdateShortcutsHeaders = exports.UpdateInteractiveOTOMessageResponse = exports.UpdateInteractiveOTOMessageResponseBody = exports.UpdateInteractiveOTOMessageRequest = exports.UpdateInteractiveOTOMessageHeaders = exports.SendTopBoxInteractiveOTOMessageResponse = exports.SendTopBoxInteractiveOTOMessageResponseBody = exports.SendTopBoxInteractiveOTOMessageRequest = exports.SendTopBoxInteractiveOTOMessageHeaders = exports.SendInteractiveOTOMessageResponse = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class DetailUserIdPrivateDataMapValue extends $tea.Model {
    static names() {
        return {
            cardParamMap: 'cardParamMap',
            cardMediaIdParamMap: 'cardMediaIdParamMap',
        };
    }
    static types() {
        return {
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DetailUserIdPrivateDataMapValue = DetailUserIdPrivateDataMapValue;
class ApplyFollowerAuthInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFollowerAuthInfoHeaders = ApplyFollowerAuthInfoHeaders;
class ApplyFollowerAuthInfoRequest extends $tea.Model {
    static names() {
        return {
            appAuthKey: 'appAuthKey',
            fieldScope: 'fieldScope',
            sessionId: 'sessionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appAuthKey: 'string',
            fieldScope: 'string',
            sessionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFollowerAuthInfoRequest = ApplyFollowerAuthInfoRequest;
class ApplyFollowerAuthInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: ApplyFollowerAuthInfoResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFollowerAuthInfoResponseBody = ApplyFollowerAuthInfoResponseBody;
class ApplyFollowerAuthInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ApplyFollowerAuthInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFollowerAuthInfoResponse = ApplyFollowerAuthInfoResponse;
class CallbackRegiesterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CallbackRegiesterHeaders = CallbackRegiesterHeaders;
class CallbackRegiesterRequest extends $tea.Model {
    static names() {
        return {
            apiSecret: 'apiSecret',
            callbackKey: 'callbackKey',
            callbackUrl: 'callbackUrl',
            type: 'type',
        };
    }
    static types() {
        return {
            apiSecret: 'string',
            callbackKey: 'string',
            callbackUrl: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CallbackRegiesterRequest = CallbackRegiesterRequest;
class CallbackRegiesterResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: CallbackRegiesterResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CallbackRegiesterResponseBody = CallbackRegiesterResponseBody;
class CallbackRegiesterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CallbackRegiesterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CallbackRegiesterResponse = CallbackRegiesterResponse;
class CloseTopBoxInteractiveOTOMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseTopBoxInteractiveOTOMessageHeaders = CloseTopBoxInteractiveOTOMessageHeaders;
class CloseTopBoxInteractiveOTOMessageRequest extends $tea.Model {
    static names() {
        return {
            detail: 'detail',
        };
    }
    static types() {
        return {
            detail: CloseTopBoxInteractiveOTOMessageRequestDetail,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseTopBoxInteractiveOTOMessageRequest = CloseTopBoxInteractiveOTOMessageRequest;
class CloseTopBoxInteractiveOTOMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseTopBoxInteractiveOTOMessageResponseBody = CloseTopBoxInteractiveOTOMessageResponseBody;
class CloseTopBoxInteractiveOTOMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseTopBoxInteractiveOTOMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseTopBoxInteractiveOTOMessageResponse = CloseTopBoxInteractiveOTOMessageResponse;
class GetFollowerAuthInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoHeaders = GetFollowerAuthInfoHeaders;
class GetFollowerAuthInfoRequest extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoRequest = GetFollowerAuthInfoRequest;
class GetFollowerAuthInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetFollowerAuthInfoResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponseBody = GetFollowerAuthInfoResponseBody;
class GetFollowerAuthInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFollowerAuthInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponse = GetFollowerAuthInfoResponse;
class GetFollowerInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoHeaders = GetFollowerInfoHeaders;
class GetFollowerInfoRequest extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoRequest = GetFollowerInfoRequest;
class GetFollowerInfoResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: GetFollowerInfoResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoResponseBody = GetFollowerInfoResponseBody;
class GetFollowerInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFollowerInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoResponse = GetFollowerInfoResponse;
class GetPictureDownloadUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPictureDownloadUrlHeaders = GetPictureDownloadUrlHeaders;
class GetPictureDownloadUrlRequest extends $tea.Model {
    static names() {
        return {
            downloadCode: 'downloadCode',
            sessionId: 'sessionId',
        };
    }
    static types() {
        return {
            downloadCode: 'string',
            sessionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPictureDownloadUrlRequest = GetPictureDownloadUrlRequest;
class GetPictureDownloadUrlResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: GetPictureDownloadUrlResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPictureDownloadUrlResponseBody = GetPictureDownloadUrlResponseBody;
class GetPictureDownloadUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPictureDownloadUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPictureDownloadUrlResponse = GetPictureDownloadUrlResponse;
class GetUserFollowStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserFollowStatusHeaders = GetUserFollowStatusHeaders;
class GetUserFollowStatusRequest extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserFollowStatusRequest = GetUserFollowStatusRequest;
class GetUserFollowStatusResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetUserFollowStatusResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserFollowStatusResponseBody = GetUserFollowStatusResponseBody;
class GetUserFollowStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserFollowStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserFollowStatusResponse = GetUserFollowStatusResponse;
class ListAccountHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountHeaders = ListAccountHeaders;
class ListAccountResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': ListAccountResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountResponseBody = ListAccountResponseBody;
class ListAccountResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAccountResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountResponse = ListAccountResponse;
class ListAccountInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountInfoHeaders = ListAccountInfoHeaders;
class ListAccountInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': ListAccountInfoResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountInfoResponseBody = ListAccountInfoResponseBody;
class ListAccountInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAccountInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountInfoResponse = ListAccountInfoResponse;
class ListFollowerHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerHeaders = ListFollowerHeaders;
class ListFollowerRequest extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            accountId: 'string',
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerRequest = ListFollowerRequest;
class ListFollowerResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: ListFollowerResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerResponseBody = ListFollowerResponseBody;
class ListFollowerResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListFollowerResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerResponse = ListFollowerResponse;
class QueryUserFollowStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserFollowStatusHeaders = QueryUserFollowStatusHeaders;
class QueryUserFollowStatusRequest extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserFollowStatusRequest = QueryUserFollowStatusRequest;
class QueryUserFollowStatusResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: QueryUserFollowStatusResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserFollowStatusResponseBody = QueryUserFollowStatusResponseBody;
class QueryUserFollowStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUserFollowStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserFollowStatusResponse = QueryUserFollowStatusResponse;
class SendAgentOTOMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageHeaders = SendAgentOTOMessageHeaders;
class SendAgentOTOMessageRequest extends $tea.Model {
    static names() {
        return {
            detail: 'detail',
        };
    }
    static types() {
        return {
            detail: SendAgentOTOMessageRequestDetail,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequest = SendAgentOTOMessageRequest;
class SendAgentOTOMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: SendAgentOTOMessageResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageResponseBody = SendAgentOTOMessageResponseBody;
class SendAgentOTOMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendAgentOTOMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageResponse = SendAgentOTOMessageResponse;
class SendInteractiveOTOMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageHeaders = SendInteractiveOTOMessageHeaders;
class SendInteractiveOTOMessageRequest extends $tea.Model {
    static names() {
        return {
            detail: 'detail',
        };
    }
    static types() {
        return {
            detail: SendInteractiveOTOMessageRequestDetail,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageRequest = SendInteractiveOTOMessageRequest;
class SendInteractiveOTOMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: SendInteractiveOTOMessageResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageResponseBody = SendInteractiveOTOMessageResponseBody;
class SendInteractiveOTOMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendInteractiveOTOMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageResponse = SendInteractiveOTOMessageResponse;
class SendTopBoxInteractiveOTOMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageHeaders = SendTopBoxInteractiveOTOMessageHeaders;
class SendTopBoxInteractiveOTOMessageRequest extends $tea.Model {
    static names() {
        return {
            detail: 'detail',
        };
    }
    static types() {
        return {
            detail: SendTopBoxInteractiveOTOMessageRequestDetail,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageRequest = SendTopBoxInteractiveOTOMessageRequest;
class SendTopBoxInteractiveOTOMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageResponseBody = SendTopBoxInteractiveOTOMessageResponseBody;
class SendTopBoxInteractiveOTOMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendTopBoxInteractiveOTOMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageResponse = SendTopBoxInteractiveOTOMessageResponse;
class UpdateInteractiveOTOMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageHeaders = UpdateInteractiveOTOMessageHeaders;
class UpdateInteractiveOTOMessageRequest extends $tea.Model {
    static names() {
        return {
            detail: 'detail',
        };
    }
    static types() {
        return {
            detail: UpdateInteractiveOTOMessageRequestDetail,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageRequest = UpdateInteractiveOTOMessageRequest;
class UpdateInteractiveOTOMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: UpdateInteractiveOTOMessageResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageResponseBody = UpdateInteractiveOTOMessageResponseBody;
class UpdateInteractiveOTOMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateInteractiveOTOMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageResponse = UpdateInteractiveOTOMessageResponse;
class UpdateShortcutsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateShortcutsHeaders = UpdateShortcutsHeaders;
class UpdateShortcutsRequest extends $tea.Model {
    static names() {
        return {
            details: 'details',
            sessionId: 'sessionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            details: { 'type': 'array', 'itemType': UpdateShortcutsRequestDetails },
            sessionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateShortcutsRequest = UpdateShortcutsRequest;
class UpdateShortcutsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateShortcutsResponseBody = UpdateShortcutsResponseBody;
class UpdateShortcutsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateShortcutsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateShortcutsResponse = UpdateShortcutsResponse;
class ApplyFollowerAuthInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openApplyId: 'openApplyId',
        };
    }
    static types() {
        return {
            openApplyId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFollowerAuthInfoResponseBodyResult = ApplyFollowerAuthInfoResponseBodyResult;
class CallbackRegiesterResponseBodyResult extends $tea.Model {
    static names() {
        return {
            apiSecret: 'apiSecret',
            callbackUrl: 'callbackUrl',
        };
    }
    static types() {
        return {
            apiSecret: 'string',
            callbackUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CallbackRegiesterResponseBodyResult = CallbackRegiesterResponseBodyResult;
class CloseTopBoxInteractiveOTOMessageRequestDetail extends $tea.Model {
    static names() {
        return {
            cardBizId: 'cardBizId',
            cardTemplateId: 'cardTemplateId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            cardBizId: 'string',
            cardTemplateId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseTopBoxInteractiveOTOMessageRequestDetail = CloseTopBoxInteractiveOTOMessageRequestDetail;
class GetFollowerAuthInfoResponseBodyResultAuthInfoMainCorp extends $tea.Model {
    static names() {
        return {
            authorized: 'authorized',
            corpName: 'corpName',
        };
    }
    static types() {
        return {
            authorized: 'boolean',
            corpName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponseBodyResultAuthInfoMainCorp = GetFollowerAuthInfoResponseBodyResultAuthInfoMainCorp;
class GetFollowerAuthInfoResponseBodyResultAuthInfoMobile extends $tea.Model {
    static names() {
        return {
            authorized: 'authorized',
            mobile: 'mobile',
            stateCode: 'stateCode',
        };
    }
    static types() {
        return {
            authorized: 'boolean',
            mobile: 'string',
            stateCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponseBodyResultAuthInfoMobile = GetFollowerAuthInfoResponseBodyResultAuthInfoMobile;
class GetFollowerAuthInfoResponseBodyResultAuthInfo extends $tea.Model {
    static names() {
        return {
            mainCorp: 'mainCorp',
            mobile: 'mobile',
        };
    }
    static types() {
        return {
            mainCorp: GetFollowerAuthInfoResponseBodyResultAuthInfoMainCorp,
            mobile: GetFollowerAuthInfoResponseBodyResultAuthInfoMobile,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponseBodyResultAuthInfo = GetFollowerAuthInfoResponseBodyResultAuthInfo;
class GetFollowerAuthInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            authInfo: 'authInfo',
        };
    }
    static types() {
        return {
            authInfo: GetFollowerAuthInfoResponseBodyResultAuthInfo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerAuthInfoResponseBodyResult = GetFollowerAuthInfoResponseBodyResult;
class GetFollowerInfoResponseBodyResultUser extends $tea.Model {
    static names() {
        return {
            name: 'name',
            timestamp: 'timestamp',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            timestamp: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoResponseBodyResultUser = GetFollowerInfoResponseBodyResultUser;
class GetFollowerInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            user: 'user',
        };
    }
    static types() {
        return {
            user: GetFollowerInfoResponseBodyResultUser,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFollowerInfoResponseBodyResult = GetFollowerInfoResponseBodyResult;
class GetPictureDownloadUrlResponseBodyResult extends $tea.Model {
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPictureDownloadUrlResponseBodyResult = GetPictureDownloadUrlResponseBodyResult;
class GetUserFollowStatusResponseBodyResult extends $tea.Model {
    static names() {
        return {
            status: 'status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserFollowStatusResponseBodyResult = GetUserFollowStatusResponseBodyResult;
class ListAccountResponseBodyResult extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            accountName: 'accountName',
        };
    }
    static types() {
        return {
            accountId: 'string',
            accountName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountResponseBodyResult = ListAccountResponseBodyResult;
class ListAccountInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            accountId: 'accountId',
            accountName: 'accountName',
        };
    }
    static types() {
        return {
            accountId: 'string',
            accountName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAccountInfoResponseBodyResult = ListAccountInfoResponseBodyResult;
class ListFollowerResponseBodyResultUserList extends $tea.Model {
    static names() {
        return {
            name: 'name',
            timestamp: 'timestamp',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            timestamp: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerResponseBodyResultUserList = ListFollowerResponseBodyResultUserList;
class ListFollowerResponseBodyResult extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            userList: 'userList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            userList: { 'type': 'array', 'itemType': ListFollowerResponseBodyResultUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFollowerResponseBodyResult = ListFollowerResponseBodyResult;
class QueryUserFollowStatusResponseBodyResult extends $tea.Model {
    static names() {
        return {
            status: 'status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserFollowStatusResponseBodyResult = QueryUserFollowStatusResponseBodyResult;
class SendAgentOTOMessageRequestDetailMessageBodyActionCardButtonList extends $tea.Model {
    static names() {
        return {
            actionUrl: 'actionUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyActionCardButtonList = SendAgentOTOMessageRequestDetailMessageBodyActionCardButtonList;
class SendAgentOTOMessageRequestDetailMessageBodyActionCard extends $tea.Model {
    static names() {
        return {
            buttonList: 'buttonList',
            buttonOrientation: 'buttonOrientation',
            markdown: 'markdown',
            singleTitle: 'singleTitle',
            singleUrl: 'singleUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            buttonList: { 'type': 'array', 'itemType': SendAgentOTOMessageRequestDetailMessageBodyActionCardButtonList },
            buttonOrientation: 'string',
            markdown: 'string',
            singleTitle: 'string',
            singleUrl: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyActionCard = SendAgentOTOMessageRequestDetailMessageBodyActionCard;
class SendAgentOTOMessageRequestDetailMessageBodyImage extends $tea.Model {
    static names() {
        return {
            mediaId: 'mediaId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyImage = SendAgentOTOMessageRequestDetailMessageBodyImage;
class SendAgentOTOMessageRequestDetailMessageBodyInteractiveMessage extends $tea.Model {
    static names() {
        return {
            callbackUrl: 'callbackUrl',
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
        };
    }
    static types() {
        return {
            callbackUrl: 'string',
            cardBizId: 'string',
            cardData: 'string',
            cardTemplateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyInteractiveMessage = SendAgentOTOMessageRequestDetailMessageBodyInteractiveMessage;
class SendAgentOTOMessageRequestDetailMessageBodyLink extends $tea.Model {
    static names() {
        return {
            messageUrl: 'messageUrl',
            picUrl: 'picUrl',
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            messageUrl: 'string',
            picUrl: 'string',
            text: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyLink = SendAgentOTOMessageRequestDetailMessageBodyLink;
class SendAgentOTOMessageRequestDetailMessageBodyMarkdown extends $tea.Model {
    static names() {
        return {
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            text: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyMarkdown = SendAgentOTOMessageRequestDetailMessageBodyMarkdown;
class SendAgentOTOMessageRequestDetailMessageBodyText extends $tea.Model {
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBodyText = SendAgentOTOMessageRequestDetailMessageBodyText;
class SendAgentOTOMessageRequestDetailMessageBody extends $tea.Model {
    static names() {
        return {
            actionCard: 'actionCard',
            image: 'image',
            interactiveMessage: 'interactiveMessage',
            link: 'link',
            markdown: 'markdown',
            text: 'text',
        };
    }
    static types() {
        return {
            actionCard: SendAgentOTOMessageRequestDetailMessageBodyActionCard,
            image: SendAgentOTOMessageRequestDetailMessageBodyImage,
            interactiveMessage: SendAgentOTOMessageRequestDetailMessageBodyInteractiveMessage,
            link: SendAgentOTOMessageRequestDetailMessageBodyLink,
            markdown: SendAgentOTOMessageRequestDetailMessageBodyMarkdown,
            text: SendAgentOTOMessageRequestDetailMessageBodyText,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetailMessageBody = SendAgentOTOMessageRequestDetailMessageBody;
class SendAgentOTOMessageRequestDetail extends $tea.Model {
    static names() {
        return {
            messageBody: 'messageBody',
            msgType: 'msgType',
            sessionId: 'sessionId',
            userId: 'userId',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            messageBody: SendAgentOTOMessageRequestDetailMessageBody,
            msgType: 'string',
            sessionId: 'string',
            userId: 'string',
            uuid: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageRequestDetail = SendAgentOTOMessageRequestDetail;
class SendAgentOTOMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendAgentOTOMessageResponseBodyResult = SendAgentOTOMessageResponseBodyResult;
class SendInteractiveOTOMessageRequestDetail extends $tea.Model {
    static names() {
        return {
            callbackUrl: 'callbackUrl',
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
            userId: 'userId',
            userIdPrivateDataMap: 'userIdPrivateDataMap',
        };
    }
    static types() {
        return {
            callbackUrl: 'string',
            cardBizId: 'string',
            cardData: 'string',
            cardTemplateId: 'string',
            userId: 'string',
            userIdPrivateDataMap: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageRequestDetail = SendInteractiveOTOMessageRequestDetail;
class SendInteractiveOTOMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveOTOMessageResponseBodyResult = SendInteractiveOTOMessageResponseBodyResult;
class SendTopBoxInteractiveOTOMessageRequestDetailCardData extends $tea.Model {
    static names() {
        return {
            cardMediaIdParamMap: 'cardMediaIdParamMap',
            cardParamMap: 'cardParamMap',
        };
    }
    static types() {
        return {
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageRequestDetailCardData = SendTopBoxInteractiveOTOMessageRequestDetailCardData;
class SendTopBoxInteractiveOTOMessageRequestDetail extends $tea.Model {
    static names() {
        return {
            callbackUrl: 'callbackUrl',
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
            expiredTime: 'expiredTime',
            userId: 'userId',
            userIdPrivateDataMap: 'userIdPrivateDataMap',
        };
    }
    static types() {
        return {
            callbackUrl: 'string',
            cardBizId: 'string',
            cardData: SendTopBoxInteractiveOTOMessageRequestDetailCardData,
            cardTemplateId: 'string',
            expiredTime: 'number',
            userId: 'string',
            userIdPrivateDataMap: { 'type': 'map', 'keyType': 'string', 'valueType': DetailUserIdPrivateDataMapValue },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTopBoxInteractiveOTOMessageRequestDetail = SendTopBoxInteractiveOTOMessageRequestDetail;
class UpdateInteractiveOTOMessageRequestDetailUpdateOptions extends $tea.Model {
    static names() {
        return {
            updateCardDataByKey: 'updateCardDataByKey',
            updatePrivateDataByKey: 'updatePrivateDataByKey',
        };
    }
    static types() {
        return {
            updateCardDataByKey: 'boolean',
            updatePrivateDataByKey: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageRequestDetailUpdateOptions = UpdateInteractiveOTOMessageRequestDetailUpdateOptions;
class UpdateInteractiveOTOMessageRequestDetail extends $tea.Model {
    static names() {
        return {
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            updateOptions: 'updateOptions',
            userIdPrivateDataMap: 'userIdPrivateDataMap',
        };
    }
    static types() {
        return {
            cardBizId: 'string',
            cardData: 'string',
            updateOptions: UpdateInteractiveOTOMessageRequestDetailUpdateOptions,
            userIdPrivateDataMap: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageRequestDetail = UpdateInteractiveOTOMessageRequestDetail;
class UpdateInteractiveOTOMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveOTOMessageResponseBodyResult = UpdateInteractiveOTOMessageResponseBodyResult;
class UpdateShortcutsRequestDetails extends $tea.Model {
    static names() {
        return {
            actionUrl: 'actionUrl',
            callbackKey: 'callbackKey',
            iconFont: 'iconFont',
            iconMediaId: 'iconMediaId',
            shortcutId: 'shortcutId',
            slideIconMediaId: 'slideIconMediaId',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            callbackKey: 'string',
            iconFont: 'string',
            iconMediaId: 'string',
            shortcutId: 'string',
            slideIconMediaId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateShortcutsRequestDetails = UpdateShortcutsRequestDetails;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request ApplyFollowerAuthInfoRequest
     * @param headers ApplyFollowerAuthInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ApplyFollowerAuthInfoResponse
     */
    async applyFollowerAuthInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appAuthKey)) {
            body["appAuthKey"] = request.appAuthKey;
        }
        if (!tea_util_1.default.isUnset(request.fieldScope)) {
            body["fieldScope"] = request.fieldScope;
        }
        if (!tea_util_1.default.isUnset(request.sessionId)) {
            body["sessionId"] = request.sessionId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ApplyFollowerAuthInfo",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/followers/authInfos/apply`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ApplyFollowerAuthInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ApplyFollowerAuthInfoRequest
     * @return ApplyFollowerAuthInfoResponse
     */
    async applyFollowerAuthInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ApplyFollowerAuthInfoHeaders({});
        return await this.applyFollowerAuthInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CallbackRegiesterRequest
     * @param headers CallbackRegiesterHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CallbackRegiesterResponse
     */
    async callbackRegiesterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiSecret)) {
            body["apiSecret"] = request.apiSecret;
        }
        if (!tea_util_1.default.isUnset(request.callbackKey)) {
            body["callbackKey"] = request.callbackKey;
        }
        if (!tea_util_1.default.isUnset(request.callbackUrl)) {
            body["callbackUrl"] = request.callbackUrl;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CallbackRegiester",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/callbacks/regiester`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CallbackRegiesterResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CallbackRegiesterRequest
     * @return CallbackRegiesterResponse
     */
    async callbackRegiester(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CallbackRegiesterHeaders({});
        return await this.callbackRegiesterWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CloseTopBoxInteractiveOTOMessageRequest
     * @param headers CloseTopBoxInteractiveOTOMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CloseTopBoxInteractiveOTOMessageResponse
     */
    async closeTopBoxInteractiveOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CloseTopBoxInteractiveOTOMessage",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/topBoxes/close`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseTopBoxInteractiveOTOMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CloseTopBoxInteractiveOTOMessageRequest
     * @return CloseTopBoxInteractiveOTOMessageResponse
     */
    async closeTopBoxInteractiveOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseTopBoxInteractiveOTOMessageHeaders({});
        return await this.closeTopBoxInteractiveOTOMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetFollowerAuthInfoRequest
     * @param headers GetFollowerAuthInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetFollowerAuthInfoResponse
     */
    async getFollowerAuthInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFollowerAuthInfo",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/followers/authInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFollowerAuthInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetFollowerAuthInfoRequest
     * @return GetFollowerAuthInfoResponse
     */
    async getFollowerAuthInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFollowerAuthInfoHeaders({});
        return await this.getFollowerAuthInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetFollowerInfoRequest
     * @param headers GetFollowerInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetFollowerInfoResponse
     */
    async getFollowerInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFollowerInfo",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/followers/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFollowerInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetFollowerInfoRequest
     * @return GetFollowerInfoResponse
     */
    async getFollowerInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFollowerInfoHeaders({});
        return await this.getFollowerInfoWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetPictureDownloadUrlRequest
     * @param headers GetPictureDownloadUrlHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetPictureDownloadUrlResponse
     */
    async getPictureDownloadUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.downloadCode)) {
            query["downloadCode"] = request.downloadCode;
        }
        if (!tea_util_1.default.isUnset(request.sessionId)) {
            query["sessionId"] = request.sessionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetPictureDownloadUrl",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/pictures/downloadUrls`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetPictureDownloadUrlResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetPictureDownloadUrlRequest
     * @return GetPictureDownloadUrlResponse
     */
    async getPictureDownloadUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPictureDownloadUrlHeaders({});
        return await this.getPictureDownloadUrlWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetUserFollowStatusRequest
     * @param headers GetUserFollowStatusHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetUserFollowStatusResponse
     */
    async getUserFollowStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserFollowStatus",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/followers/statuses`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserFollowStatusResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetUserFollowStatusRequest
     * @return GetUserFollowStatusResponse
     */
    async getUserFollowStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserFollowStatusHeaders({});
        return await this.getUserFollowStatusWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers ListAccountHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListAccountResponse
     */
    async listAccountWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ListAccount",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/accounts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAccountResponse({}));
    }
    /**
     * @summary 
     *
     * @return ListAccountResponse
     */
    async listAccount() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAccountHeaders({});
        return await this.listAccountWithOptions(headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers ListAccountInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListAccountInfoResponse
     */
    async listAccountInfoWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ListAccountInfo",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/isv/accounts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAccountInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @return ListAccountInfoResponse
     */
    async listAccountInfo() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAccountInfoHeaders({});
        return await this.listAccountInfoWithOptions(headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListFollowerRequest
     * @param headers ListFollowerHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListFollowerResponse
     */
    async listFollowerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListFollower",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/followers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListFollowerResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListFollowerRequest
     * @return ListFollowerResponse
     */
    async listFollower(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListFollowerHeaders({});
        return await this.listFollowerWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryUserFollowStatusRequest
     * @param headers QueryUserFollowStatusHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryUserFollowStatusResponse
     */
    async queryUserFollowStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUserFollowStatus",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/isv/followers/statuses`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUserFollowStatusResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryUserFollowStatusRequest
     * @return QueryUserFollowStatusResponse
     */
    async queryUserFollowStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserFollowStatusHeaders({});
        return await this.queryUserFollowStatusWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendAgentOTOMessageRequest
     * @param headers SendAgentOTOMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendAgentOTOMessageResponse
     */
    async sendAgentOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendAgentOTOMessage",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/agentMessages`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendAgentOTOMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendAgentOTOMessageRequest
     * @return SendAgentOTOMessageResponse
     */
    async sendAgentOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendAgentOTOMessageHeaders({});
        return await this.sendAgentOTOMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendInteractiveOTOMessageRequest
     * @param headers SendInteractiveOTOMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendInteractiveOTOMessageResponse
     */
    async sendInteractiveOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendInteractiveOTOMessage",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/interactiveMessages`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendInteractiveOTOMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendInteractiveOTOMessageRequest
     * @return SendInteractiveOTOMessageResponse
     */
    async sendInteractiveOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendInteractiveOTOMessageHeaders({});
        return await this.sendInteractiveOTOMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SendTopBoxInteractiveOTOMessageRequest
     * @param headers SendTopBoxInteractiveOTOMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SendTopBoxInteractiveOTOMessageResponse
     */
    async sendTopBoxInteractiveOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendTopBoxInteractiveOTOMessage",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/topBoxes/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendTopBoxInteractiveOTOMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SendTopBoxInteractiveOTOMessageRequest
     * @return SendTopBoxInteractiveOTOMessageResponse
     */
    async sendTopBoxInteractiveOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendTopBoxInteractiveOTOMessageHeaders({});
        return await this.sendTopBoxInteractiveOTOMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateInteractiveOTOMessageRequest
     * @param headers UpdateInteractiveOTOMessageHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateInteractiveOTOMessageResponse
     */
    async updateInteractiveOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateInteractiveOTOMessage",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/oToMessages/interactiveMessages`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateInteractiveOTOMessageResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateInteractiveOTOMessageRequest
     * @return UpdateInteractiveOTOMessageResponse
     */
    async updateInteractiveOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInteractiveOTOMessageHeaders({});
        return await this.updateInteractiveOTOMessageWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateShortcutsRequest
     * @param headers UpdateShortcutsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateShortcutsResponse
     */
    async updateShortcutsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.details)) {
            body["details"] = request.details;
        }
        if (!tea_util_1.default.isUnset(request.sessionId)) {
            body["sessionId"] = request.sessionId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateShortcuts",
            version: "link_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/link/shortcuts`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateShortcutsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateShortcutsRequest
     * @return UpdateShortcutsResponse
     */
    async updateShortcuts(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateShortcutsHeaders({});
        return await this.updateShortcutsWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map