"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRangeProtectionResponseBody = exports.CreateRangeProtectionRequest = exports.CreateRangeProtectionHeaders = exports.CreateDeveloperMetadataResponse = exports.CreateDeveloperMetadataResponseBody = exports.CreateDeveloperMetadataRequest = exports.CreateDeveloperMetadataHeaders = exports.CreateConditionalFormattingRuleResponse = exports.CreateConditionalFormattingRuleResponseBody = exports.CreateConditionalFormattingRuleRequest = exports.CreateConditionalFormattingRuleHeaders = exports.ClearDataResponse = exports.ClearDataResponseBody = exports.ClearDataRequest = exports.ClearDataHeaders = exports.ClearResponse = exports.ClearResponseBody = exports.ClearRequest = exports.ClearHeaders = exports.BindCoolAppToSheetResponse = exports.BindCoolAppToSheetResponseBody = exports.BindCoolAppToSheetRequest = exports.BindCoolAppToSheetHeaders = exports.BatchGetWorkspacesResponse = exports.BatchGetWorkspacesResponseBody = exports.BatchGetWorkspacesRequest = exports.BatchGetWorkspacesHeaders = exports.BatchGetWorkspaceDocsResponse = exports.BatchGetWorkspaceDocsResponseBody = exports.BatchGetWorkspaceDocsRequest = exports.BatchGetWorkspaceDocsHeaders = exports.BatchResponse = exports.BatchResponseBody = exports.BatchRequest = exports.BatchHeaders = exports.AppendRowsResponse = exports.AppendRowsRequest = exports.AppendRowsHeaders = exports.AddWorkspaceMembersResponse = exports.AddWorkspaceMembersResponseBody = exports.AddWorkspaceMembersRequest = exports.AddWorkspaceMembersHeaders = exports.AddWorkspaceDocMembersResponse = exports.AddWorkspaceDocMembersRequest = exports.AddWorkspaceDocMembersHeaders = exports.AddCommentResponse = exports.AddCommentResponseBody = exports.AddCommentRequest = exports.AddCommentHeaders = exports.AttachmentsMapValue = void 0;
exports.DocAppendTextResponse = exports.DocAppendTextResponseBody = exports.DocAppendTextRequest = exports.DocAppendTextHeaders = exports.DocAppendParagraphResponse = exports.DocAppendParagraphResponseBody = exports.DocAppendParagraphRequest = exports.DocAppendParagraphHeaders = exports.DeleteWorkspaceMembersResponse = exports.DeleteWorkspaceMembersRequest = exports.DeleteWorkspaceMembersHeaders = exports.DeleteWorkspaceDocMembersResponse = exports.DeleteWorkspaceDocMembersRequest = exports.DeleteWorkspaceDocMembersHeaders = exports.DeleteWorkspaceDocResponse = exports.DeleteWorkspaceDocRequest = exports.DeleteWorkspaceDocHeaders = exports.DeleteSheetResponse = exports.DeleteSheetResponseBody = exports.DeleteSheetRequest = exports.DeleteSheetHeaders = exports.DeleteRowsResponse = exports.DeleteRowsResponseBody = exports.DeleteRowsRequest = exports.DeleteRowsHeaders = exports.DeleteRangeProtectionResponse = exports.DeleteRangeProtectionResponseBody = exports.DeleteRangeProtectionRequest = exports.DeleteRangeProtectionHeaders = exports.DeleteDropdownListsResponse = exports.DeleteDropdownListsResponseBody = exports.DeleteDropdownListsRequest = exports.DeleteDropdownListsHeaders = exports.DeleteColumnsResponse = exports.DeleteColumnsResponseBody = exports.DeleteColumnsRequest = exports.DeleteColumnsHeaders = exports.CreateWorkspaceDocResponse = exports.CreateWorkspaceDocResponseBody = exports.CreateWorkspaceDocRequest = exports.CreateWorkspaceDocHeaders = exports.CreateWorkspaceResponse = exports.CreateWorkspaceResponseBody = exports.CreateWorkspaceRequest = exports.CreateWorkspaceHeaders = exports.CreateSheetResponse = exports.CreateSheetResponseBody = exports.CreateSheetRequest = exports.CreateSheetHeaders = exports.CreateRangeProtectionResponse = void 0;
exports.GetWorkspaceResponseBody = exports.GetWorkspaceHeaders = exports.GetTemplateByIdResponse = exports.GetTemplateByIdResponseBody = exports.GetTemplateByIdRequest = exports.GetTemplateByIdHeaders = exports.GetSheetResponse = exports.GetSheetResponseBody = exports.GetSheetRequest = exports.GetSheetHeaders = exports.GetRelatedWorkspacesResponse = exports.GetRelatedWorkspacesResponseBody = exports.GetRelatedWorkspacesRequest = exports.GetRelatedWorkspacesHeaders = exports.GetRecentOpenDocsResponse = exports.GetRecentOpenDocsResponseBody = exports.GetRecentOpenDocsRequest = exports.GetRecentOpenDocsHeaders = exports.GetRecentEditDocsResponse = exports.GetRecentEditDocsResponseBody = exports.GetRecentEditDocsRequest = exports.GetRecentEditDocsHeaders = exports.GetRangeResponse = exports.GetRangeResponseBody = exports.GetRangeRequest = exports.GetRangeHeaders = exports.GetDeveloperMetadataResponse = exports.GetDeveloperMetadataResponseBody = exports.GetDeveloperMetadataRequest = exports.GetDeveloperMetadataHeaders = exports.GetAllSheetsResponse = exports.GetAllSheetsResponseBody = exports.GetAllSheetsRequest = exports.GetAllSheetsHeaders = exports.DocUpdateContentResponse = exports.DocUpdateContentResponseBody = exports.DocUpdateContentRequest = exports.DocUpdateContentHeaders = exports.DocInsertBlocksResponse = exports.DocInsertBlocksResponseBody = exports.DocInsertBlocksRequest = exports.DocInsertBlocksHeaders = exports.DocDeleteBlockResponse = exports.DocDeleteBlockResponseBody = exports.DocDeleteBlockRequest = exports.DocDeleteBlockHeaders = exports.DocBlocksQueryResponse = exports.DocBlocksQueryResponseBody = exports.DocBlocksQueryRequest = exports.DocBlocksQueryHeaders = void 0;
exports.SetRowHeightRequest = exports.SetRowHeightHeaders = exports.SetColumnsVisibilityResponse = exports.SetColumnsVisibilityResponseBody = exports.SetColumnsVisibilityRequest = exports.SetColumnsVisibilityHeaders = exports.SetColumnWidthResponse = exports.SetColumnWidthResponseBody = exports.SetColumnWidthRequest = exports.SetColumnWidthHeaders = exports.SearchWorkspaceDocsResponse = exports.SearchWorkspaceDocsResponseBody = exports.SearchWorkspaceDocsRequest = exports.SearchWorkspaceDocsHeaders = exports.RangeFindNextResponse = exports.RangeFindNextResponseBody = exports.RangeFindNextRequest = exports.RangeFindNextHeaders = exports.MergeRangeResponse = exports.MergeRangeResponseBody = exports.MergeRangeRequest = exports.MergeRangeHeaders = exports.ListTemplateResponse = exports.ListTemplateResponseBody = exports.ListTemplateRequest = exports.ListTemplateHeaders = exports.InsertRowsBeforeResponse = exports.InsertRowsBeforeResponseBody = exports.InsertRowsBeforeRequest = exports.InsertRowsBeforeHeaders = exports.InsertDropdownListsResponse = exports.InsertDropdownListsResponseBody = exports.InsertDropdownListsRequest = exports.InsertDropdownListsHeaders = exports.InsertColumnsBeforeResponse = exports.InsertColumnsBeforeResponseBody = exports.InsertColumnsBeforeRequest = exports.InsertColumnsBeforeHeaders = exports.InsertBlocksResponse = exports.InsertBlocksRequest = exports.InsertBlocksHeaders = exports.InitDocumentResponse = exports.InitDocumentResponseBody = exports.InitDocumentRequest = exports.InitDocumentHeaders = exports.GetWorkspaceNodeResponse = exports.GetWorkspaceNodeResponseBody = exports.GetWorkspaceNodeRequest = exports.GetWorkspaceNodeHeaders = exports.GetWorkspaceResponse = void 0;
exports.DocAppendTextResponseBodyResult = exports.DocAppendParagraphResponseBodyResult = exports.DeleteWorkspaceMembersRequestMembers = exports.DeleteWorkspaceDocMembersRequestMembers = exports.CreateRangeProtectionRequestEditableSetting = exports.CreateDeveloperMetadataRequestAssociatedRow = exports.CreateDeveloperMetadataRequestAssociatedColumn = exports.CreateConditionalFormattingRuleRequestDuplicateCondition = exports.CreateConditionalFormattingRuleRequestCellStyle = exports.BatchGetWorkspacesResponseBodyWorkspaces = exports.BatchGetWorkspacesResponseBodyWorkspacesWorkspace = exports.BatchGetWorkspacesResponseBodyWorkspacesWorkspaceRecentList = exports.BatchGetWorkspaceDocsResponseBodyResult = exports.BatchGetWorkspaceDocsResponseBodyResultWorkspaceBO = exports.BatchGetWorkspaceDocsResponseBodyResultNodeBO = exports.BatchRequestRequests = exports.AddWorkspaceMembersRequestMembers = exports.AddWorkspaceDocMembersRequestMembers = exports.AddCommentRequestOption = exports.UpdateWorkspaceMembersResponse = exports.UpdateWorkspaceMembersRequest = exports.UpdateWorkspaceMembersHeaders = exports.UpdateWorkspaceDocMembersResponse = exports.UpdateWorkspaceDocMembersRequest = exports.UpdateWorkspaceDocMembersHeaders = exports.UpdateSheetResponse = exports.UpdateSheetRequest = exports.UpdateSheetHeaders = exports.UpdateRangeResponse = exports.UpdateRangeResponseBody = exports.UpdateRangeRequest = exports.UpdateRangeHeaders = exports.UnbindCoolAppToSheetResponse = exports.UnbindCoolAppToSheetResponseBody = exports.UnbindCoolAppToSheetRequest = exports.UnbindCoolAppToSheetHeaders = exports.SheetFindAllResponse = exports.SheetFindAllResponseBody = exports.SheetFindAllRequest = exports.SheetFindAllHeaders = exports.SheetAutofitRowsResponse = exports.SheetAutofitRowsResponseBody = exports.SheetAutofitRowsRequest = exports.SheetAutofitRowsHeaders = exports.SetRowsVisibilityResponse = exports.SetRowsVisibilityResponseBody = exports.SetRowsVisibilityRequest = exports.SetRowsVisibilityHeaders = exports.SetRowHeightResponse = exports.SetRowHeightResponseBody = void 0;
exports.UpdateWorkspaceMembersRequestMembers = exports.UpdateWorkspaceDocMembersRequestMembers = exports.UpdateRangeRequestHyperlinks = exports.SheetFindAllResponseBodyValue = exports.SheetFindAllRequestFindOptions = exports.SearchWorkspaceDocsResponseBodyDocs = exports.SearchWorkspaceDocsResponseBodyDocsWorkspaceBO = exports.SearchWorkspaceDocsResponseBodyDocsNodeBO = exports.RangeFindNextRequestFindOptions = exports.ListTemplateResponseBodyTemplateList = exports.InsertDropdownListsRequestOptions = exports.InsertBlocksRequestLocation = exports.InsertBlocksRequestBlocks = exports.InsertBlocksRequestBlocksParagraph = exports.InsertBlocksRequestBlocksParagraphStyle = exports.InsertBlocksRequestBlocksParagraphChildren = exports.InsertBlocksRequestBlocksParagraphChildrenText = exports.InsertBlocksRequestBlocksParagraphChildrenTextTextStyle = exports.GetWorkspaceNodeResponseBodyWorkspaceBO = exports.GetWorkspaceNodeResponseBodyNodeBO = exports.GetRelatedWorkspacesResponseBodyWorkspaces = exports.GetRelatedWorkspacesResponseBodyWorkspacesRecentList = exports.GetRecentOpenDocsResponseBodyRecentList = exports.GetRecentOpenDocsResponseBodyRecentListWorkspaceBO = exports.GetRecentOpenDocsResponseBodyRecentListNodeBO = exports.GetRecentEditDocsResponseBodyRecentList = exports.GetRecentEditDocsResponseBodyRecentListWorkspaceBO = exports.GetRecentEditDocsResponseBodyRecentListNodeBO = exports.GetRangeResponseBodyBackgroundColors = exports.GetDeveloperMetadataResponseBodyAssociatedRow = exports.GetDeveloperMetadataResponseBodyAssociatedColumn = exports.GetAllSheetsResponseBodyValue = exports.DocInsertBlocksResponseBodyResult = exports.DocDeleteBlockResponseBodyResult = exports.DocBlocksQueryResponseBodyResult = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AttachmentsMapValue extends $tea.Model {
    static names() {
        return {
            uploadKey: 'uploadKey',
            name: 'name',
            mediaType: 'mediaType',
        };
    }
    static types() {
        return {
            uploadKey: 'string',
            name: 'string',
            mediaType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AttachmentsMapValue = AttachmentsMapValue;
class AddCommentHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCommentHeaders = AddCommentHeaders;
class AddCommentRequest extends $tea.Model {
    static names() {
        return {
            commentContent: 'commentContent',
            commentType: 'commentType',
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            commentContent: 'string',
            commentType: 'string',
            option: AddCommentRequestOption,
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCommentRequest = AddCommentRequest;
class AddCommentResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCommentResponseBody = AddCommentResponseBody;
class AddCommentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddCommentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCommentResponse = AddCommentResponse;
class AddWorkspaceDocMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceDocMembersHeaders = AddWorkspaceDocMembersHeaders;
class AddWorkspaceDocMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': AddWorkspaceDocMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceDocMembersRequest = AddWorkspaceDocMembersRequest;
class AddWorkspaceDocMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceDocMembersResponse = AddWorkspaceDocMembersResponse;
class AddWorkspaceMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceMembersHeaders = AddWorkspaceMembersHeaders;
class AddWorkspaceMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': AddWorkspaceMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceMembersRequest = AddWorkspaceMembersRequest;
class AddWorkspaceMembersResponseBody extends $tea.Model {
    static names() {
        return {
            notInOrgList: 'notInOrgList',
        };
    }
    static types() {
        return {
            notInOrgList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceMembersResponseBody = AddWorkspaceMembersResponseBody;
class AddWorkspaceMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddWorkspaceMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceMembersResponse = AddWorkspaceMembersResponse;
class AppendRowsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AppendRowsHeaders = AppendRowsHeaders;
class AppendRowsRequest extends $tea.Model {
    static names() {
        return {
            values: 'values',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AppendRowsRequest = AppendRowsRequest;
class AppendRowsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AppendRowsResponse = AppendRowsResponse;
class BatchHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchHeaders = BatchHeaders;
class BatchRequest extends $tea.Model {
    static names() {
        return {
            requests: 'requests',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            requests: { 'type': 'array', 'itemType': BatchRequestRequests },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchRequest = BatchRequest;
class BatchResponseBody extends $tea.Model {
    static names() {
        return {
            responses: 'responses',
        };
    }
    static types() {
        return {
            responses: { 'type': 'array', 'itemType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchResponseBody = BatchResponseBody;
class BatchResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchResponse = BatchResponse;
class BatchGetWorkspaceDocsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsHeaders = BatchGetWorkspaceDocsHeaders;
class BatchGetWorkspaceDocsRequest extends $tea.Model {
    static names() {
        return {
            nodeIds: 'nodeIds',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            nodeIds: { 'type': 'array', 'itemType': 'string' },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsRequest = BatchGetWorkspaceDocsRequest;
class BatchGetWorkspaceDocsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': BatchGetWorkspaceDocsResponseBodyResult },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsResponseBody = BatchGetWorkspaceDocsResponseBody;
class BatchGetWorkspaceDocsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetWorkspaceDocsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsResponse = BatchGetWorkspaceDocsResponse;
class BatchGetWorkspacesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesHeaders = BatchGetWorkspacesHeaders;
class BatchGetWorkspacesRequest extends $tea.Model {
    static names() {
        return {
            includeRecent: 'includeRecent',
            operatorId: 'operatorId',
            workspaceIds: 'workspaceIds',
        };
    }
    static types() {
        return {
            includeRecent: 'boolean',
            operatorId: 'string',
            workspaceIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesRequest = BatchGetWorkspacesRequest;
class BatchGetWorkspacesResponseBody extends $tea.Model {
    static names() {
        return {
            workspaces: 'workspaces',
        };
    }
    static types() {
        return {
            workspaces: { 'type': 'array', 'itemType': BatchGetWorkspacesResponseBodyWorkspaces },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesResponseBody = BatchGetWorkspacesResponseBody;
class BatchGetWorkspacesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchGetWorkspacesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesResponse = BatchGetWorkspacesResponse;
class BindCoolAppToSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BindCoolAppToSheetHeaders = BindCoolAppToSheetHeaders;
class BindCoolAppToSheetRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BindCoolAppToSheetRequest = BindCoolAppToSheetRequest;
class BindCoolAppToSheetResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BindCoolAppToSheetResponseBody = BindCoolAppToSheetResponseBody;
class BindCoolAppToSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BindCoolAppToSheetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BindCoolAppToSheetResponse = BindCoolAppToSheetResponse;
class ClearHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearHeaders = ClearHeaders;
class ClearRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearRequest = ClearRequest;
class ClearResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearResponseBody = ClearResponseBody;
class ClearResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearResponse = ClearResponse;
class ClearDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearDataHeaders = ClearDataHeaders;
class ClearDataRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearDataRequest = ClearDataRequest;
class ClearDataResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearDataResponseBody = ClearDataResponseBody;
class ClearDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ClearDataResponse = ClearDataResponse;
class CreateConditionalFormattingRuleHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleHeaders = CreateConditionalFormattingRuleHeaders;
class CreateConditionalFormattingRuleRequest extends $tea.Model {
    static names() {
        return {
            cellStyle: 'cellStyle',
            duplicateCondition: 'duplicateCondition',
            ranges: 'ranges',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            cellStyle: CreateConditionalFormattingRuleRequestCellStyle,
            duplicateCondition: CreateConditionalFormattingRuleRequestDuplicateCondition,
            ranges: { 'type': 'array', 'itemType': 'string' },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleRequest = CreateConditionalFormattingRuleRequest;
class CreateConditionalFormattingRuleResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleResponseBody = CreateConditionalFormattingRuleResponseBody;
class CreateConditionalFormattingRuleResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateConditionalFormattingRuleResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleResponse = CreateConditionalFormattingRuleResponse;
class CreateDeveloperMetadataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataHeaders = CreateDeveloperMetadataHeaders;
class CreateDeveloperMetadataRequest extends $tea.Model {
    static names() {
        return {
            associatedColumn: 'associatedColumn',
            associatedRow: 'associatedRow',
            value: 'value',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            associatedColumn: CreateDeveloperMetadataRequestAssociatedColumn,
            associatedRow: CreateDeveloperMetadataRequestAssociatedRow,
            value: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataRequest = CreateDeveloperMetadataRequest;
class CreateDeveloperMetadataResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataResponseBody = CreateDeveloperMetadataResponseBody;
class CreateDeveloperMetadataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDeveloperMetadataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataResponse = CreateDeveloperMetadataResponse;
class CreateRangeProtectionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateRangeProtectionHeaders = CreateRangeProtectionHeaders;
class CreateRangeProtectionRequest extends $tea.Model {
    static names() {
        return {
            editableSetting: 'editableSetting',
            otherUserPermission: 'otherUserPermission',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            editableSetting: CreateRangeProtectionRequestEditableSetting,
            otherUserPermission: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateRangeProtectionRequest = CreateRangeProtectionRequest;
class CreateRangeProtectionResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateRangeProtectionResponseBody = CreateRangeProtectionResponseBody;
class CreateRangeProtectionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateRangeProtectionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateRangeProtectionResponse = CreateRangeProtectionResponse;
class CreateSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSheetHeaders = CreateSheetHeaders;
class CreateSheetRequest extends $tea.Model {
    static names() {
        return {
            name: 'name',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSheetRequest = CreateSheetRequest;
class CreateSheetResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
            name: 'name',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
            visibility: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSheetResponseBody = CreateSheetResponseBody;
class CreateSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSheetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSheetResponse = CreateSheetResponse;
class CreateWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceHeaders = CreateWorkspaceHeaders;
class CreateWorkspaceRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
            name: 'name',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceRequest = CreateWorkspaceRequest;
class CreateWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            description: 'description',
            name: 'name',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceResponseBody = CreateWorkspaceResponseBody;
class CreateWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceResponse = CreateWorkspaceResponse;
class CreateWorkspaceDocHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceDocHeaders = CreateWorkspaceDocHeaders;
class CreateWorkspaceDocRequest extends $tea.Model {
    static names() {
        return {
            docType: 'docType',
            name: 'name',
            operatorId: 'operatorId',
            parentNodeId: 'parentNodeId',
            templateId: 'templateId',
            templateType: 'templateType',
        };
    }
    static types() {
        return {
            docType: 'string',
            name: 'string',
            operatorId: 'string',
            parentNodeId: 'string',
            templateId: 'string',
            templateType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceDocRequest = CreateWorkspaceDocRequest;
class CreateWorkspaceDocResponseBody extends $tea.Model {
    static names() {
        return {
            dentryUuid: 'dentryUuid',
            docKey: 'docKey',
            nodeId: 'nodeId',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            dentryUuid: 'string',
            docKey: 'string',
            nodeId: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceDocResponseBody = CreateWorkspaceDocResponseBody;
class CreateWorkspaceDocResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateWorkspaceDocResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateWorkspaceDocResponse = CreateWorkspaceDocResponse;
class DeleteColumnsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteColumnsHeaders = DeleteColumnsHeaders;
class DeleteColumnsRequest extends $tea.Model {
    static names() {
        return {
            column: 'column',
            columnCount: 'columnCount',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            column: 'number',
            columnCount: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteColumnsRequest = DeleteColumnsRequest;
class DeleteColumnsResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteColumnsResponseBody = DeleteColumnsResponseBody;
class DeleteColumnsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteColumnsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteColumnsResponse = DeleteColumnsResponse;
class DeleteDropdownListsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDropdownListsHeaders = DeleteDropdownListsHeaders;
class DeleteDropdownListsRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDropdownListsRequest = DeleteDropdownListsRequest;
class DeleteDropdownListsResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDropdownListsResponseBody = DeleteDropdownListsResponseBody;
class DeleteDropdownListsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDropdownListsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDropdownListsResponse = DeleteDropdownListsResponse;
class DeleteRangeProtectionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRangeProtectionHeaders = DeleteRangeProtectionHeaders;
class DeleteRangeProtectionRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRangeProtectionRequest = DeleteRangeProtectionRequest;
class DeleteRangeProtectionResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRangeProtectionResponseBody = DeleteRangeProtectionResponseBody;
class DeleteRangeProtectionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRangeProtectionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRangeProtectionResponse = DeleteRangeProtectionResponse;
class DeleteRowsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRowsHeaders = DeleteRowsHeaders;
class DeleteRowsRequest extends $tea.Model {
    static names() {
        return {
            row: 'row',
            rowCount: 'rowCount',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            row: 'number',
            rowCount: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRowsRequest = DeleteRowsRequest;
class DeleteRowsResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRowsResponseBody = DeleteRowsResponseBody;
class DeleteRowsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRowsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteRowsResponse = DeleteRowsResponse;
class DeleteSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSheetHeaders = DeleteSheetHeaders;
class DeleteSheetRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSheetRequest = DeleteSheetRequest;
class DeleteSheetResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSheetResponseBody = DeleteSheetResponseBody;
class DeleteSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteSheetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteSheetResponse = DeleteSheetResponse;
class DeleteWorkspaceDocHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocHeaders = DeleteWorkspaceDocHeaders;
class DeleteWorkspaceDocRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocRequest = DeleteWorkspaceDocRequest;
class DeleteWorkspaceDocResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocResponse = DeleteWorkspaceDocResponse;
class DeleteWorkspaceDocMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocMembersHeaders = DeleteWorkspaceDocMembersHeaders;
class DeleteWorkspaceDocMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': DeleteWorkspaceDocMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocMembersRequest = DeleteWorkspaceDocMembersRequest;
class DeleteWorkspaceDocMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocMembersResponse = DeleteWorkspaceDocMembersResponse;
class DeleteWorkspaceMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceMembersHeaders = DeleteWorkspaceMembersHeaders;
class DeleteWorkspaceMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': DeleteWorkspaceMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceMembersRequest = DeleteWorkspaceMembersRequest;
class DeleteWorkspaceMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceMembersResponse = DeleteWorkspaceMembersResponse;
class DocAppendParagraphHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendParagraphHeaders = DocAppendParagraphHeaders;
class DocAppendParagraphRequest extends $tea.Model {
    static names() {
        return {
            elementType: 'elementType',
            properties: 'properties',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            elementType: 'string',
            properties: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendParagraphRequest = DocAppendParagraphRequest;
class DocAppendParagraphResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DocAppendParagraphResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendParagraphResponseBody = DocAppendParagraphResponseBody;
class DocAppendParagraphResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocAppendParagraphResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendParagraphResponse = DocAppendParagraphResponse;
class DocAppendTextHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendTextHeaders = DocAppendTextHeaders;
class DocAppendTextRequest extends $tea.Model {
    static names() {
        return {
            text: 'text',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            text: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendTextRequest = DocAppendTextRequest;
class DocAppendTextResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DocAppendTextResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendTextResponseBody = DocAppendTextResponseBody;
class DocAppendTextResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocAppendTextResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendTextResponse = DocAppendTextResponse;
class DocBlocksQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocBlocksQueryHeaders = DocBlocksQueryHeaders;
class DocBlocksQueryRequest extends $tea.Model {
    static names() {
        return {
            blockType: 'blockType',
            endIndex: 'endIndex',
            operatorId: 'operatorId',
            startIndex: 'startIndex',
        };
    }
    static types() {
        return {
            blockType: 'string',
            endIndex: 'number',
            operatorId: 'string',
            startIndex: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocBlocksQueryRequest = DocBlocksQueryRequest;
class DocBlocksQueryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DocBlocksQueryResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocBlocksQueryResponseBody = DocBlocksQueryResponseBody;
class DocBlocksQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocBlocksQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocBlocksQueryResponse = DocBlocksQueryResponse;
class DocDeleteBlockHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocDeleteBlockHeaders = DocDeleteBlockHeaders;
class DocDeleteBlockRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocDeleteBlockRequest = DocDeleteBlockRequest;
class DocDeleteBlockResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DocDeleteBlockResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocDeleteBlockResponseBody = DocDeleteBlockResponseBody;
class DocDeleteBlockResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocDeleteBlockResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocDeleteBlockResponse = DocDeleteBlockResponse;
class DocInsertBlocksHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocInsertBlocksHeaders = DocInsertBlocksHeaders;
class DocInsertBlocksRequest extends $tea.Model {
    static names() {
        return {
            blockId: 'blockId',
            element: 'element',
            index: 'index',
            where: 'where',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            blockId: 'string',
            element: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            index: 'number',
            where: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocInsertBlocksRequest = DocInsertBlocksRequest;
class DocInsertBlocksResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DocInsertBlocksResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocInsertBlocksResponseBody = DocInsertBlocksResponseBody;
class DocInsertBlocksResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocInsertBlocksResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocInsertBlocksResponse = DocInsertBlocksResponse;
class DocUpdateContentHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocUpdateContentHeaders = DocUpdateContentHeaders;
class DocUpdateContentRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            dataType: 'dataType',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            content: 'string',
            dataType: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocUpdateContentRequest = DocUpdateContentRequest;
class DocUpdateContentResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocUpdateContentResponseBody = DocUpdateContentResponseBody;
class DocUpdateContentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocUpdateContentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocUpdateContentResponse = DocUpdateContentResponse;
class GetAllSheetsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAllSheetsHeaders = GetAllSheetsHeaders;
class GetAllSheetsRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAllSheetsRequest = GetAllSheetsRequest;
class GetAllSheetsResponseBody extends $tea.Model {
    static names() {
        return {
            value: 'value',
        };
    }
    static types() {
        return {
            value: { 'type': 'array', 'itemType': GetAllSheetsResponseBodyValue },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAllSheetsResponseBody = GetAllSheetsResponseBody;
class GetAllSheetsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAllSheetsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAllSheetsResponse = GetAllSheetsResponse;
class GetDeveloperMetadataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataHeaders = GetDeveloperMetadataHeaders;
class GetDeveloperMetadataRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataRequest = GetDeveloperMetadataRequest;
class GetDeveloperMetadataResponseBody extends $tea.Model {
    static names() {
        return {
            associatedColumn: 'associatedColumn',
            associatedRow: 'associatedRow',
            value: 'value',
        };
    }
    static types() {
        return {
            associatedColumn: GetDeveloperMetadataResponseBodyAssociatedColumn,
            associatedRow: GetDeveloperMetadataResponseBodyAssociatedRow,
            value: 'any',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataResponseBody = GetDeveloperMetadataResponseBody;
class GetDeveloperMetadataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDeveloperMetadataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataResponse = GetDeveloperMetadataResponse;
class GetRangeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRangeHeaders = GetRangeHeaders;
class GetRangeRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
            select: 'select',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            select: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRangeRequest = GetRangeRequest;
class GetRangeResponseBody extends $tea.Model {
    static names() {
        return {
            backgroundColors: 'backgroundColors',
            displayValues: 'displayValues',
            fontSizes: 'fontSizes',
            fontWeights: 'fontWeights',
            formulas: 'formulas',
            horizontalAlignments: 'horizontalAlignments',
            values: 'values',
            verticalAlignments: 'verticalAlignments',
        };
    }
    static types() {
        return {
            backgroundColors: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': GetRangeResponseBodyBackgroundColors } },
            displayValues: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            fontSizes: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'number' } },
            fontWeights: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            formulas: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            horizontalAlignments: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'any' } },
            verticalAlignments: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRangeResponseBody = GetRangeResponseBody;
class GetRangeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRangeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRangeResponse = GetRangeResponse;
class GetRecentEditDocsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsHeaders = GetRecentEditDocsHeaders;
class GetRecentEditDocsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsRequest = GetRecentEditDocsRequest;
class GetRecentEditDocsResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            recentList: 'recentList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            recentList: { 'type': 'array', 'itemType': GetRecentEditDocsResponseBodyRecentList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsResponseBody = GetRecentEditDocsResponseBody;
class GetRecentEditDocsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRecentEditDocsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsResponse = GetRecentEditDocsResponse;
class GetRecentOpenDocsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsHeaders = GetRecentOpenDocsHeaders;
class GetRecentOpenDocsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsRequest = GetRecentOpenDocsRequest;
class GetRecentOpenDocsResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            recentList: 'recentList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            recentList: { 'type': 'array', 'itemType': GetRecentOpenDocsResponseBodyRecentList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsResponseBody = GetRecentOpenDocsResponseBody;
class GetRecentOpenDocsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRecentOpenDocsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsResponse = GetRecentOpenDocsResponse;
class GetRelatedWorkspacesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesHeaders = GetRelatedWorkspacesHeaders;
class GetRelatedWorkspacesRequest extends $tea.Model {
    static names() {
        return {
            includeRecent: 'includeRecent',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            includeRecent: 'boolean',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesRequest = GetRelatedWorkspacesRequest;
class GetRelatedWorkspacesResponseBody extends $tea.Model {
    static names() {
        return {
            workspaces: 'workspaces',
        };
    }
    static types() {
        return {
            workspaces: { 'type': 'array', 'itemType': GetRelatedWorkspacesResponseBodyWorkspaces },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesResponseBody = GetRelatedWorkspacesResponseBody;
class GetRelatedWorkspacesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRelatedWorkspacesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesResponse = GetRelatedWorkspacesResponse;
class GetSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSheetHeaders = GetSheetHeaders;
class GetSheetRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSheetRequest = GetSheetRequest;
class GetSheetResponseBody extends $tea.Model {
    static names() {
        return {
            columnCount: 'columnCount',
            id: 'id',
            lastNonEmptyColumn: 'lastNonEmptyColumn',
            lastNonEmptyRow: 'lastNonEmptyRow',
            name: 'name',
            rowCount: 'rowCount',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            columnCount: 'number',
            id: 'string',
            lastNonEmptyColumn: 'number',
            lastNonEmptyRow: 'number',
            name: 'string',
            rowCount: 'number',
            visibility: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSheetResponseBody = GetSheetResponseBody;
class GetSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSheetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSheetResponse = GetSheetResponse;
class GetTemplateByIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTemplateByIdHeaders = GetTemplateByIdHeaders;
class GetTemplateByIdRequest extends $tea.Model {
    static names() {
        return {
            belong: 'belong',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            belong: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTemplateByIdRequest = GetTemplateByIdRequest;
class GetTemplateByIdResponseBody extends $tea.Model {
    static names() {
        return {
            coverUrl: 'coverUrl',
            createTime: 'createTime',
            docType: 'docType',
            id: 'id',
            templateType: 'templateType',
            title: 'title',
            updateTime: 'updateTime',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            coverUrl: 'string',
            createTime: 'number',
            docType: 'string',
            id: 'string',
            templateType: 'string',
            title: 'string',
            updateTime: 'number',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTemplateByIdResponseBody = GetTemplateByIdResponseBody;
class GetTemplateByIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTemplateByIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTemplateByIdResponse = GetTemplateByIdResponse;
class GetWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceHeaders = GetWorkspaceHeaders;
class GetWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            isDeleted: 'isDeleted',
            owner: 'owner',
            rootDentryUuid: 'rootDentryUuid',
            url: 'url',
        };
    }
    static types() {
        return {
            isDeleted: 'boolean',
            owner: 'string',
            rootDentryUuid: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponseBody = GetWorkspaceResponseBody;
class GetWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponse = GetWorkspaceResponse;
class GetWorkspaceNodeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeHeaders = GetWorkspaceNodeHeaders;
class GetWorkspaceNodeRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeRequest = GetWorkspaceNodeRequest;
class GetWorkspaceNodeResponseBody extends $tea.Model {
    static names() {
        return {
            hasPermission: 'hasPermission',
            nodeBO: 'nodeBO',
            workspaceBO: 'workspaceBO',
        };
    }
    static types() {
        return {
            hasPermission: 'boolean',
            nodeBO: GetWorkspaceNodeResponseBodyNodeBO,
            workspaceBO: GetWorkspaceNodeResponseBodyWorkspaceBO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeResponseBody = GetWorkspaceNodeResponseBody;
class GetWorkspaceNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWorkspaceNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeResponse = GetWorkspaceNodeResponse;
class InitDocumentHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InitDocumentHeaders = InitDocumentHeaders;
class InitDocumentRequest extends $tea.Model {
    static names() {
        return {
            attachmentsMap: 'attachmentsMap',
            importType: 'importType',
            linksKey: 'linksKey',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            attachmentsMap: { 'type': 'map', 'keyType': 'string', 'valueType': AttachmentsMapValue },
            importType: 'number',
            linksKey: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InitDocumentRequest = InitDocumentRequest;
class InitDocumentResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InitDocumentResponseBody = InitDocumentResponseBody;
class InitDocumentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InitDocumentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InitDocumentResponse = InitDocumentResponse;
class InsertBlocksHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksHeaders = InsertBlocksHeaders;
class InsertBlocksRequest extends $tea.Model {
    static names() {
        return {
            blocks: 'blocks',
            location: 'location',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            blocks: { 'type': 'array', 'itemType': InsertBlocksRequestBlocks },
            location: InsertBlocksRequestLocation,
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequest = InsertBlocksRequest;
class InsertBlocksResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksResponse = InsertBlocksResponse;
class InsertColumnsBeforeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertColumnsBeforeHeaders = InsertColumnsBeforeHeaders;
class InsertColumnsBeforeRequest extends $tea.Model {
    static names() {
        return {
            column: 'column',
            columnCount: 'columnCount',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            column: 'number',
            columnCount: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertColumnsBeforeRequest = InsertColumnsBeforeRequest;
class InsertColumnsBeforeResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertColumnsBeforeResponseBody = InsertColumnsBeforeResponseBody;
class InsertColumnsBeforeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InsertColumnsBeforeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertColumnsBeforeResponse = InsertColumnsBeforeResponse;
class InsertDropdownListsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertDropdownListsHeaders = InsertDropdownListsHeaders;
class InsertDropdownListsRequest extends $tea.Model {
    static names() {
        return {
            options: 'options',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            options: { 'type': 'array', 'itemType': InsertDropdownListsRequestOptions },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertDropdownListsRequest = InsertDropdownListsRequest;
class InsertDropdownListsResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertDropdownListsResponseBody = InsertDropdownListsResponseBody;
class InsertDropdownListsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InsertDropdownListsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertDropdownListsResponse = InsertDropdownListsResponse;
class InsertRowsBeforeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertRowsBeforeHeaders = InsertRowsBeforeHeaders;
class InsertRowsBeforeRequest extends $tea.Model {
    static names() {
        return {
            row: 'row',
            rowCount: 'rowCount',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            row: 'number',
            rowCount: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertRowsBeforeRequest = InsertRowsBeforeRequest;
class InsertRowsBeforeResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertRowsBeforeResponseBody = InsertRowsBeforeResponseBody;
class InsertRowsBeforeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InsertRowsBeforeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertRowsBeforeResponse = InsertRowsBeforeResponse;
class ListTemplateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTemplateHeaders = ListTemplateHeaders;
class ListTemplateRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            templateType: 'templateType',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            templateType: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTemplateRequest = ListTemplateRequest;
class ListTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            templateList: 'templateList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            templateList: { 'type': 'array', 'itemType': ListTemplateResponseBodyTemplateList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTemplateResponseBody = ListTemplateResponseBody;
class ListTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTemplateResponse = ListTemplateResponse;
class MergeRangeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MergeRangeHeaders = MergeRangeHeaders;
class MergeRangeRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MergeRangeRequest = MergeRangeRequest;
class MergeRangeResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MergeRangeResponseBody = MergeRangeResponseBody;
class MergeRangeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MergeRangeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MergeRangeResponse = MergeRangeResponse;
class RangeFindNextHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RangeFindNextHeaders = RangeFindNextHeaders;
class RangeFindNextRequest extends $tea.Model {
    static names() {
        return {
            findOptions: 'findOptions',
            text: 'text',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            findOptions: RangeFindNextRequestFindOptions,
            text: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RangeFindNextRequest = RangeFindNextRequest;
class RangeFindNextResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RangeFindNextResponseBody = RangeFindNextResponseBody;
class RangeFindNextResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RangeFindNextResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RangeFindNextResponse = RangeFindNextResponse;
class SearchWorkspaceDocsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsHeaders = SearchWorkspaceDocsHeaders;
class SearchWorkspaceDocsRequest extends $tea.Model {
    static names() {
        return {
            keyword: 'keyword',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            keyword: 'string',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsRequest = SearchWorkspaceDocsRequest;
class SearchWorkspaceDocsResponseBody extends $tea.Model {
    static names() {
        return {
            docs: 'docs',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            docs: { 'type': 'array', 'itemType': SearchWorkspaceDocsResponseBodyDocs },
            hasMore: 'boolean',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsResponseBody = SearchWorkspaceDocsResponseBody;
class SearchWorkspaceDocsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchWorkspaceDocsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsResponse = SearchWorkspaceDocsResponse;
class SetColumnWidthHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnWidthHeaders = SetColumnWidthHeaders;
class SetColumnWidthRequest extends $tea.Model {
    static names() {
        return {
            column: 'column',
            width: 'width',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            column: 'number',
            width: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnWidthRequest = SetColumnWidthRequest;
class SetColumnWidthResponseBody extends $tea.Model {
    static names() {
        return {
            sheetId: 'sheetId',
            sheetName: 'sheetName',
        };
    }
    static types() {
        return {
            sheetId: 'string',
            sheetName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnWidthResponseBody = SetColumnWidthResponseBody;
class SetColumnWidthResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetColumnWidthResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnWidthResponse = SetColumnWidthResponse;
class SetColumnsVisibilityHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnsVisibilityHeaders = SetColumnsVisibilityHeaders;
class SetColumnsVisibilityRequest extends $tea.Model {
    static names() {
        return {
            column: 'column',
            columnCount: 'columnCount',
            visibility: 'visibility',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            column: 'number',
            columnCount: 'number',
            visibility: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnsVisibilityRequest = SetColumnsVisibilityRequest;
class SetColumnsVisibilityResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnsVisibilityResponseBody = SetColumnsVisibilityResponseBody;
class SetColumnsVisibilityResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetColumnsVisibilityResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetColumnsVisibilityResponse = SetColumnsVisibilityResponse;
class SetRowHeightHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowHeightHeaders = SetRowHeightHeaders;
class SetRowHeightRequest extends $tea.Model {
    static names() {
        return {
            height: 'height',
            row: 'row',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            height: 'number',
            row: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowHeightRequest = SetRowHeightRequest;
class SetRowHeightResponseBody extends $tea.Model {
    static names() {
        return {
            sheetId: 'sheetId',
            sheetName: 'sheetName',
        };
    }
    static types() {
        return {
            sheetId: 'string',
            sheetName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowHeightResponseBody = SetRowHeightResponseBody;
class SetRowHeightResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRowHeightResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowHeightResponse = SetRowHeightResponse;
class SetRowsVisibilityHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowsVisibilityHeaders = SetRowsVisibilityHeaders;
class SetRowsVisibilityRequest extends $tea.Model {
    static names() {
        return {
            row: 'row',
            rowCount: 'rowCount',
            visibility: 'visibility',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            row: 'number',
            rowCount: 'number',
            visibility: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowsVisibilityRequest = SetRowsVisibilityRequest;
class SetRowsVisibilityResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowsVisibilityResponseBody = SetRowsVisibilityResponseBody;
class SetRowsVisibilityResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRowsVisibilityResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRowsVisibilityResponse = SetRowsVisibilityResponse;
class SheetAutofitRowsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetAutofitRowsHeaders = SheetAutofitRowsHeaders;
class SheetAutofitRowsRequest extends $tea.Model {
    static names() {
        return {
            fontWidth: 'fontWidth',
            row: 'row',
            rowCount: 'rowCount',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            fontWidth: 'number',
            row: 'number',
            rowCount: 'number',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetAutofitRowsRequest = SheetAutofitRowsRequest;
class SheetAutofitRowsResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetAutofitRowsResponseBody = SheetAutofitRowsResponseBody;
class SheetAutofitRowsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SheetAutofitRowsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetAutofitRowsResponse = SheetAutofitRowsResponse;
class SheetFindAllHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllHeaders = SheetFindAllHeaders;
class SheetFindAllRequest extends $tea.Model {
    static names() {
        return {
            findOptions: 'findOptions',
            text: 'text',
            operatorId: 'operatorId',
            select: 'select',
        };
    }
    static types() {
        return {
            findOptions: SheetFindAllRequestFindOptions,
            text: 'string',
            operatorId: 'string',
            select: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllRequest = SheetFindAllRequest;
class SheetFindAllResponseBody extends $tea.Model {
    static names() {
        return {
            value: 'value',
        };
    }
    static types() {
        return {
            value: { 'type': 'array', 'itemType': SheetFindAllResponseBodyValue },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllResponseBody = SheetFindAllResponseBody;
class SheetFindAllResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SheetFindAllResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllResponse = SheetFindAllResponse;
class UnbindCoolAppToSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnbindCoolAppToSheetHeaders = UnbindCoolAppToSheetHeaders;
class UnbindCoolAppToSheetRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnbindCoolAppToSheetRequest = UnbindCoolAppToSheetRequest;
class UnbindCoolAppToSheetResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnbindCoolAppToSheetResponseBody = UnbindCoolAppToSheetResponseBody;
class UnbindCoolAppToSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnbindCoolAppToSheetResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UnbindCoolAppToSheetResponse = UnbindCoolAppToSheetResponse;
class UpdateRangeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRangeHeaders = UpdateRangeHeaders;
class UpdateRangeRequest extends $tea.Model {
    static names() {
        return {
            backgroundColors: 'backgroundColors',
            fontSizes: 'fontSizes',
            fontWeights: 'fontWeights',
            horizontalAlignments: 'horizontalAlignments',
            hyperlinks: 'hyperlinks',
            numberFormat: 'numberFormat',
            values: 'values',
            verticalAlignments: 'verticalAlignments',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            backgroundColors: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            fontSizes: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'number' } },
            fontWeights: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            horizontalAlignments: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            hyperlinks: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': UpdateRangeRequestHyperlinks } },
            numberFormat: 'string',
            values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            verticalAlignments: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRangeRequest = UpdateRangeRequest;
class UpdateRangeResponseBody extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRangeResponseBody = UpdateRangeResponseBody;
class UpdateRangeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRangeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRangeResponse = UpdateRangeResponse;
class UpdateSheetHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSheetHeaders = UpdateSheetHeaders;
class UpdateSheetRequest extends $tea.Model {
    static names() {
        return {
            name: 'name',
            visibility: 'visibility',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            visibility: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSheetRequest = UpdateSheetRequest;
class UpdateSheetResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSheetResponse = UpdateSheetResponse;
class UpdateWorkspaceDocMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceDocMembersHeaders = UpdateWorkspaceDocMembersHeaders;
class UpdateWorkspaceDocMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': UpdateWorkspaceDocMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceDocMembersRequest = UpdateWorkspaceDocMembersRequest;
class UpdateWorkspaceDocMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceDocMembersResponse = UpdateWorkspaceDocMembersResponse;
class UpdateWorkspaceMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceMembersHeaders = UpdateWorkspaceMembersHeaders;
class UpdateWorkspaceMembersRequest extends $tea.Model {
    static names() {
        return {
            members: 'members',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': UpdateWorkspaceMembersRequestMembers },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceMembersRequest = UpdateWorkspaceMembersRequest;
class UpdateWorkspaceMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceMembersResponse = UpdateWorkspaceMembersResponse;
class AddCommentRequestOption extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            extra: 'extra',
        };
    }
    static types() {
        return {
            createTime: 'string',
            extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCommentRequestOption = AddCommentRequestOption;
class AddWorkspaceDocMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleType: 'roleType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
            roleType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceDocMembersRequestMembers = AddWorkspaceDocMembersRequestMembers;
class AddWorkspaceMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleType: 'roleType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
            roleType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceMembersRequestMembers = AddWorkspaceMembersRequestMembers;
class BatchRequestRequests extends $tea.Model {
    static names() {
        return {
            body: 'body',
            method: 'method',
            path: 'path',
        };
    }
    static types() {
        return {
            body: 'any',
            method: 'string',
            path: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchRequestRequests = BatchRequestRequests;
class BatchGetWorkspaceDocsResponseBodyResultNodeBO extends $tea.Model {
    static names() {
        return {
            deleted: 'deleted',
            docType: 'docType',
            lastEditTime: 'lastEditTime',
            name: 'name',
            nodeId: 'nodeId',
            url: 'url',
        };
    }
    static types() {
        return {
            deleted: 'boolean',
            docType: 'string',
            lastEditTime: 'number',
            name: 'string',
            nodeId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsResponseBodyResultNodeBO = BatchGetWorkspaceDocsResponseBodyResultNodeBO;
class BatchGetWorkspaceDocsResponseBodyResultWorkspaceBO extends $tea.Model {
    static names() {
        return {
            name: 'name',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            name: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsResponseBodyResultWorkspaceBO = BatchGetWorkspaceDocsResponseBodyResultWorkspaceBO;
class BatchGetWorkspaceDocsResponseBodyResult extends $tea.Model {
    static names() {
        return {
            hasPermission: 'hasPermission',
            nodeBO: 'nodeBO',
            workspaceBO: 'workspaceBO',
        };
    }
    static types() {
        return {
            hasPermission: 'boolean',
            nodeBO: BatchGetWorkspaceDocsResponseBodyResultNodeBO,
            workspaceBO: BatchGetWorkspaceDocsResponseBodyResultWorkspaceBO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspaceDocsResponseBodyResult = BatchGetWorkspaceDocsResponseBodyResult;
class BatchGetWorkspacesResponseBodyWorkspacesWorkspaceRecentList extends $tea.Model {
    static names() {
        return {
            lastEditTime: 'lastEditTime',
            name: 'name',
            nodeId: 'nodeId',
            url: 'url',
        };
    }
    static types() {
        return {
            lastEditTime: 'string',
            name: 'string',
            nodeId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesResponseBodyWorkspacesWorkspaceRecentList = BatchGetWorkspacesResponseBodyWorkspacesWorkspaceRecentList;
class BatchGetWorkspacesResponseBodyWorkspacesWorkspace extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            name: 'name',
            orgPublished: 'orgPublished',
            recentList: 'recentList',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            createTime: 'number',
            name: 'string',
            orgPublished: 'boolean',
            recentList: { 'type': 'array', 'itemType': BatchGetWorkspacesResponseBodyWorkspacesWorkspaceRecentList },
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesResponseBodyWorkspacesWorkspace = BatchGetWorkspacesResponseBodyWorkspacesWorkspace;
class BatchGetWorkspacesResponseBodyWorkspaces extends $tea.Model {
    static names() {
        return {
            hasPermission: 'hasPermission',
            workspace: 'workspace',
        };
    }
    static types() {
        return {
            hasPermission: 'boolean',
            workspace: BatchGetWorkspacesResponseBodyWorkspacesWorkspace,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchGetWorkspacesResponseBodyWorkspaces = BatchGetWorkspacesResponseBodyWorkspaces;
class CreateConditionalFormattingRuleRequestCellStyle extends $tea.Model {
    static names() {
        return {
            backgroundColor: 'backgroundColor',
        };
    }
    static types() {
        return {
            backgroundColor: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleRequestCellStyle = CreateConditionalFormattingRuleRequestCellStyle;
class CreateConditionalFormattingRuleRequestDuplicateCondition extends $tea.Model {
    static names() {
        return {
            operator: 'operator',
        };
    }
    static types() {
        return {
            operator: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateConditionalFormattingRuleRequestDuplicateCondition = CreateConditionalFormattingRuleRequestDuplicateCondition;
class CreateDeveloperMetadataRequestAssociatedColumn extends $tea.Model {
    static names() {
        return {
            column: 'column',
            sheet: 'sheet',
        };
    }
    static types() {
        return {
            column: 'number',
            sheet: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataRequestAssociatedColumn = CreateDeveloperMetadataRequestAssociatedColumn;
class CreateDeveloperMetadataRequestAssociatedRow extends $tea.Model {
    static names() {
        return {
            row: 'row',
            sheet: 'sheet',
        };
    }
    static types() {
        return {
            row: 'number',
            sheet: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateDeveloperMetadataRequestAssociatedRow = CreateDeveloperMetadataRequestAssociatedRow;
class CreateRangeProtectionRequestEditableSetting extends $tea.Model {
    static names() {
        return {
            deleteColumns: 'deleteColumns',
            deleteRows: 'deleteRows',
            editCells: 'editCells',
            formatCells: 'formatCells',
            insertColumns: 'insertColumns',
            insertRows: 'insertRows',
            toggleColumnsVisibility: 'toggleColumnsVisibility',
            toggleRowsVisibility: 'toggleRowsVisibility',
        };
    }
    static types() {
        return {
            deleteColumns: 'boolean',
            deleteRows: 'boolean',
            editCells: 'boolean',
            formatCells: 'boolean',
            insertColumns: 'boolean',
            insertRows: 'boolean',
            toggleColumnsVisibility: 'boolean',
            toggleRowsVisibility: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateRangeProtectionRequestEditableSetting = CreateRangeProtectionRequestEditableSetting;
class DeleteWorkspaceDocMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceDocMembersRequestMembers = DeleteWorkspaceDocMembersRequestMembers;
class DeleteWorkspaceMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteWorkspaceMembersRequestMembers = DeleteWorkspaceMembersRequestMembers;
class DocAppendParagraphResponseBodyResult extends $tea.Model {
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendParagraphResponseBodyResult = DocAppendParagraphResponseBodyResult;
class DocAppendTextResponseBodyResult extends $tea.Model {
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocAppendTextResponseBodyResult = DocAppendTextResponseBodyResult;
class DocBlocksQueryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocBlocksQueryResponseBodyResult = DocBlocksQueryResponseBodyResult;
class DocDeleteBlockResponseBodyResult extends $tea.Model {
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocDeleteBlockResponseBodyResult = DocDeleteBlockResponseBodyResult;
class DocInsertBlocksResponseBodyResult extends $tea.Model {
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DocInsertBlocksResponseBodyResult = DocInsertBlocksResponseBodyResult;
class GetAllSheetsResponseBodyValue extends $tea.Model {
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAllSheetsResponseBodyValue = GetAllSheetsResponseBodyValue;
class GetDeveloperMetadataResponseBodyAssociatedColumn extends $tea.Model {
    static names() {
        return {
            column: 'column',
            sheetId: 'sheetId',
        };
    }
    static types() {
        return {
            column: 'number',
            sheetId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataResponseBodyAssociatedColumn = GetDeveloperMetadataResponseBodyAssociatedColumn;
class GetDeveloperMetadataResponseBodyAssociatedRow extends $tea.Model {
    static names() {
        return {
            row: 'row',
            sheetId: 'sheetId',
        };
    }
    static types() {
        return {
            row: 'number',
            sheetId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDeveloperMetadataResponseBodyAssociatedRow = GetDeveloperMetadataResponseBodyAssociatedRow;
class GetRangeResponseBodyBackgroundColors extends $tea.Model {
    static names() {
        return {
            red: 'red',
            green: 'green',
            blue: 'blue',
            hexString: 'hexString',
        };
    }
    static types() {
        return {
            red: 'number',
            green: 'number',
            blue: 'number',
            hexString: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRangeResponseBodyBackgroundColors = GetRangeResponseBodyBackgroundColors;
class GetRecentEditDocsResponseBodyRecentListNodeBO extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            docType: 'docType',
            isDeleted: 'isDeleted',
            lastEditTime: 'lastEditTime',
            nodeId: 'nodeId',
            nodeName: 'nodeName',
            updateTime: 'updateTime',
            url: 'url',
        };
    }
    static types() {
        return {
            createTime: 'number',
            docType: 'string',
            isDeleted: 'boolean',
            lastEditTime: 'number',
            nodeId: 'string',
            nodeName: 'string',
            updateTime: 'number',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsResponseBodyRecentListNodeBO = GetRecentEditDocsResponseBodyRecentListNodeBO;
class GetRecentEditDocsResponseBodyRecentListWorkspaceBO extends $tea.Model {
    static names() {
        return {
            url: 'url',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            url: 'string',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsResponseBodyRecentListWorkspaceBO = GetRecentEditDocsResponseBodyRecentListWorkspaceBO;
class GetRecentEditDocsResponseBodyRecentList extends $tea.Model {
    static names() {
        return {
            nodeBO: 'nodeBO',
            workspaceBO: 'workspaceBO',
        };
    }
    static types() {
        return {
            nodeBO: GetRecentEditDocsResponseBodyRecentListNodeBO,
            workspaceBO: GetRecentEditDocsResponseBodyRecentListWorkspaceBO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentEditDocsResponseBodyRecentList = GetRecentEditDocsResponseBodyRecentList;
class GetRecentOpenDocsResponseBodyRecentListNodeBO extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            docType: 'docType',
            isDeleted: 'isDeleted',
            lastOpenTime: 'lastOpenTime',
            nodeId: 'nodeId',
            nodeName: 'nodeName',
            updateTime: 'updateTime',
            url: 'url',
        };
    }
    static types() {
        return {
            createTime: 'number',
            docType: 'string',
            isDeleted: 'boolean',
            lastOpenTime: 'number',
            nodeId: 'string',
            nodeName: 'string',
            updateTime: 'number',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsResponseBodyRecentListNodeBO = GetRecentOpenDocsResponseBodyRecentListNodeBO;
class GetRecentOpenDocsResponseBodyRecentListWorkspaceBO extends $tea.Model {
    static names() {
        return {
            url: 'url',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            url: 'string',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsResponseBodyRecentListWorkspaceBO = GetRecentOpenDocsResponseBodyRecentListWorkspaceBO;
class GetRecentOpenDocsResponseBodyRecentList extends $tea.Model {
    static names() {
        return {
            nodeBO: 'nodeBO',
            workspaceBO: 'workspaceBO',
        };
    }
    static types() {
        return {
            nodeBO: GetRecentOpenDocsResponseBodyRecentListNodeBO,
            workspaceBO: GetRecentOpenDocsResponseBodyRecentListWorkspaceBO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRecentOpenDocsResponseBodyRecentList = GetRecentOpenDocsResponseBodyRecentList;
class GetRelatedWorkspacesResponseBodyWorkspacesRecentList extends $tea.Model {
    static names() {
        return {
            lastEditTime: 'lastEditTime',
            name: 'name',
            nodeId: 'nodeId',
            url: 'url',
        };
    }
    static types() {
        return {
            lastEditTime: 'number',
            name: 'string',
            nodeId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesResponseBodyWorkspacesRecentList = GetRelatedWorkspacesResponseBodyWorkspacesRecentList;
class GetRelatedWorkspacesResponseBodyWorkspaces extends $tea.Model {
    static names() {
        return {
            createTime: 'createTime',
            deleted: 'deleted',
            name: 'name',
            owner: 'owner',
            recentList: 'recentList',
            role: 'role',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            createTime: 'number',
            deleted: 'boolean',
            name: 'string',
            owner: 'string',
            recentList: { 'type': 'array', 'itemType': GetRelatedWorkspacesResponseBodyWorkspacesRecentList },
            role: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetRelatedWorkspacesResponseBodyWorkspaces = GetRelatedWorkspacesResponseBodyWorkspaces;
class GetWorkspaceNodeResponseBodyNodeBO extends $tea.Model {
    static names() {
        return {
            docType: 'docType',
            lastEditTime: 'lastEditTime',
            name: 'name',
            nodeId: 'nodeId',
            url: 'url',
        };
    }
    static types() {
        return {
            docType: 'string',
            lastEditTime: 'number',
            name: 'string',
            nodeId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeResponseBodyNodeBO = GetWorkspaceNodeResponseBodyNodeBO;
class GetWorkspaceNodeResponseBodyWorkspaceBO extends $tea.Model {
    static names() {
        return {
            name: 'name',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            name: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceNodeResponseBodyWorkspaceBO = GetWorkspaceNodeResponseBodyWorkspaceBO;
class InsertBlocksRequestBlocksParagraphChildrenTextTextStyle extends $tea.Model {
    static names() {
        return {
            bold: 'bold',
            dataType: 'dataType',
            fontSize: 'fontSize',
            sizeUnit: 'sizeUnit',
        };
    }
    static types() {
        return {
            bold: 'boolean',
            dataType: 'string',
            fontSize: 'number',
            sizeUnit: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocksParagraphChildrenTextTextStyle = InsertBlocksRequestBlocksParagraphChildrenTextTextStyle;
class InsertBlocksRequestBlocksParagraphChildrenText extends $tea.Model {
    static names() {
        return {
            content: 'content',
            textStyle: 'textStyle',
        };
    }
    static types() {
        return {
            content: 'string',
            textStyle: InsertBlocksRequestBlocksParagraphChildrenTextTextStyle,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocksParagraphChildrenText = InsertBlocksRequestBlocksParagraphChildrenText;
class InsertBlocksRequestBlocksParagraphChildren extends $tea.Model {
    static names() {
        return {
            elementType: 'elementType',
            text: 'text',
        };
    }
    static types() {
        return {
            elementType: 'string',
            text: InsertBlocksRequestBlocksParagraphChildrenText,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocksParagraphChildren = InsertBlocksRequestBlocksParagraphChildren;
class InsertBlocksRequestBlocksParagraphStyle extends $tea.Model {
    static names() {
        return {
            headingLevel: 'headingLevel',
        };
    }
    static types() {
        return {
            headingLevel: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocksParagraphStyle = InsertBlocksRequestBlocksParagraphStyle;
class InsertBlocksRequestBlocksParagraph extends $tea.Model {
    static names() {
        return {
            children: 'children',
            style: 'style',
        };
    }
    static types() {
        return {
            children: { 'type': 'array', 'itemType': InsertBlocksRequestBlocksParagraphChildren },
            style: InsertBlocksRequestBlocksParagraphStyle,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocksParagraph = InsertBlocksRequestBlocksParagraph;
class InsertBlocksRequestBlocks extends $tea.Model {
    static names() {
        return {
            blockType: 'blockType',
            paragraph: 'paragraph',
        };
    }
    static types() {
        return {
            blockType: 'string',
            paragraph: InsertBlocksRequestBlocksParagraph,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestBlocks = InsertBlocksRequestBlocks;
class InsertBlocksRequestLocation extends $tea.Model {
    static names() {
        return {
            head: 'head',
        };
    }
    static types() {
        return {
            head: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertBlocksRequestLocation = InsertBlocksRequestLocation;
class InsertDropdownListsRequestOptions extends $tea.Model {
    static names() {
        return {
            color: 'color',
            value: 'value',
        };
    }
    static types() {
        return {
            color: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InsertDropdownListsRequestOptions = InsertDropdownListsRequestOptions;
class ListTemplateResponseBodyTemplateList extends $tea.Model {
    static names() {
        return {
            coverUrl: 'coverUrl',
            createTime: 'createTime',
            docType: 'docType',
            id: 'id',
            templateType: 'templateType',
            title: 'title',
            updateTime: 'updateTime',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            coverUrl: 'string',
            createTime: 'number',
            docType: 'string',
            id: 'string',
            templateType: 'string',
            title: 'string',
            updateTime: 'number',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTemplateResponseBodyTemplateList = ListTemplateResponseBodyTemplateList;
class RangeFindNextRequestFindOptions extends $tea.Model {
    static names() {
        return {
            includeHidden: 'includeHidden',
            matchCase: 'matchCase',
            matchEntireCell: 'matchEntireCell',
            matchFormulaText: 'matchFormulaText',
            scope: 'scope',
            useRegExp: 'useRegExp',
        };
    }
    static types() {
        return {
            includeHidden: 'boolean',
            matchCase: 'boolean',
            matchEntireCell: 'boolean',
            matchFormulaText: 'boolean',
            scope: 'string',
            useRegExp: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RangeFindNextRequestFindOptions = RangeFindNextRequestFindOptions;
class SearchWorkspaceDocsResponseBodyDocsNodeBO extends $tea.Model {
    static names() {
        return {
            docType: 'docType',
            lastEditTime: 'lastEditTime',
            name: 'name',
            nodeId: 'nodeId',
            originName: 'originName',
            url: 'url',
        };
    }
    static types() {
        return {
            docType: 'string',
            lastEditTime: 'number',
            name: 'string',
            nodeId: 'string',
            originName: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsResponseBodyDocsNodeBO = SearchWorkspaceDocsResponseBodyDocsNodeBO;
class SearchWorkspaceDocsResponseBodyDocsWorkspaceBO extends $tea.Model {
    static names() {
        return {
            name: 'name',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            name: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsResponseBodyDocsWorkspaceBO = SearchWorkspaceDocsResponseBodyDocsWorkspaceBO;
class SearchWorkspaceDocsResponseBodyDocs extends $tea.Model {
    static names() {
        return {
            nodeBO: 'nodeBO',
            workspaceBO: 'workspaceBO',
        };
    }
    static types() {
        return {
            nodeBO: SearchWorkspaceDocsResponseBodyDocsNodeBO,
            workspaceBO: SearchWorkspaceDocsResponseBodyDocsWorkspaceBO,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchWorkspaceDocsResponseBodyDocs = SearchWorkspaceDocsResponseBodyDocs;
class SheetFindAllRequestFindOptions extends $tea.Model {
    static names() {
        return {
            includeHidden: 'includeHidden',
            matchCase: 'matchCase',
            matchEntireCell: 'matchEntireCell',
            matchFormulaText: 'matchFormulaText',
            scope: 'scope',
            unionCells: 'unionCells',
            useRegExp: 'useRegExp',
        };
    }
    static types() {
        return {
            includeHidden: 'boolean',
            matchCase: 'boolean',
            matchEntireCell: 'boolean',
            matchFormulaText: 'boolean',
            scope: 'string',
            unionCells: 'boolean',
            useRegExp: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllRequestFindOptions = SheetFindAllRequestFindOptions;
class SheetFindAllResponseBodyValue extends $tea.Model {
    static names() {
        return {
            a1Notation: 'a1Notation',
            values: 'values',
        };
    }
    static types() {
        return {
            a1Notation: 'string',
            values: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'any' } },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SheetFindAllResponseBodyValue = SheetFindAllResponseBodyValue;
class UpdateRangeRequestHyperlinks extends $tea.Model {
    static names() {
        return {
            type: 'type',
            link: 'link',
            text: 'text',
        };
    }
    static types() {
        return {
            type: 'string',
            link: 'string',
            text: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRangeRequestHyperlinks = UpdateRangeRequestHyperlinks;
class UpdateWorkspaceDocMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleType: 'roleType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
            roleType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceDocMembersRequestMembers = UpdateWorkspaceDocMembersRequestMembers;
class UpdateWorkspaceMembersRequestMembers extends $tea.Model {
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleType: 'roleType',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'string',
            roleType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateWorkspaceMembersRequestMembers = UpdateWorkspaceMembersRequestMembers;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request AddCommentRequest
     * @param headers AddCommentHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddCommentResponse
     */
    async addCommentWithOptions(docId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.commentContent)) {
            body["commentContent"] = request.commentContent;
        }
        if (!tea_util_1.default.isUnset(request.commentType)) {
            body["commentType"] = request.commentType;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddComment",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/docs/${docId}/comments`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddCommentResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddCommentRequest
     * @return AddCommentResponse
     */
    async addComment(docId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddCommentHeaders({});
        return await this.addCommentWithOptions(docId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceDocMembersRequest
     * @param headers AddWorkspaceDocMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddWorkspaceDocMembersResponse
     */
    async addWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddWorkspaceDocMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs/${nodeId}/members`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddWorkspaceDocMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceDocMembersRequest
     * @return AddWorkspaceDocMembersResponse
     */
    async addWorkspaceDocMembers(workspaceId, nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddWorkspaceDocMembersHeaders({});
        return await this.addWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceMembersRequest
     * @param headers AddWorkspaceMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddWorkspaceMembersResponse
     */
    async addWorkspaceMembersWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddWorkspaceMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/members`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddWorkspaceMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceMembersRequest
     * @return AddWorkspaceMembersResponse
     */
    async addWorkspaceMembers(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddWorkspaceMembersHeaders({});
        return await this.addWorkspaceMembersWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AppendRowsRequest
     * @param headers AppendRowsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AppendRowsResponse
     */
    async appendRowsWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.values)) {
            body["values"] = request.values;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AppendRows",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/appendRows`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AppendRowsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AppendRowsRequest
     * @return AppendRowsResponse
     */
    async appendRows(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AppendRowsHeaders({});
        return await this.appendRowsWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchRequest
     * @param headers BatchHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchResponse
     */
    async batchWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.requests)) {
            body["requests"] = request.requests;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Batch",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchRequest
     * @return BatchResponse
     */
    async batch(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchHeaders({});
        return await this.batchWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchGetWorkspaceDocsRequest
     * @param headers BatchGetWorkspaceDocsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchGetWorkspaceDocsResponse
     */
    async batchGetWorkspaceDocsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.nodeIds)) {
            body["nodeIds"] = request.nodeIds;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetWorkspaceDocs",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/docs/infos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchGetWorkspaceDocsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchGetWorkspaceDocsRequest
     * @return BatchGetWorkspaceDocsResponse
     */
    async batchGetWorkspaceDocs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchGetWorkspaceDocsHeaders({});
        return await this.batchGetWorkspaceDocsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BatchGetWorkspacesRequest
     * @param headers BatchGetWorkspacesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BatchGetWorkspacesResponse
     */
    async batchGetWorkspacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.includeRecent)) {
            body["includeRecent"] = request.includeRecent;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.workspaceIds)) {
            body["workspaceIds"] = request.workspaceIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchGetWorkspaces",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/infos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchGetWorkspacesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BatchGetWorkspacesRequest
     * @return BatchGetWorkspacesResponse
     */
    async batchGetWorkspaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchGetWorkspacesHeaders({});
        return await this.batchGetWorkspacesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request BindCoolAppToSheetRequest
     * @param headers BindCoolAppToSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return BindCoolAppToSheetResponse
     */
    async bindCoolAppToSheetWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BindCoolAppToSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/coolApps`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BindCoolAppToSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request BindCoolAppToSheetRequest
     * @return BindCoolAppToSheetResponse
     */
    async bindCoolAppToSheet(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BindCoolAppToSheetHeaders({});
        return await this.bindCoolAppToSheetWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ClearRequest
     * @param headers ClearHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ClearResponse
     */
    async clearWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "Clear",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/clear`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ClearResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ClearRequest
     * @return ClearResponse
     */
    async clear(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearHeaders({});
        return await this.clearWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ClearDataRequest
     * @param headers ClearDataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ClearDataResponse
     */
    async clearDataWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ClearData",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/clearData`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ClearDataResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ClearDataRequest
     * @return ClearDataResponse
     */
    async clearData(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearDataHeaders({});
        return await this.clearDataWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateConditionalFormattingRuleRequest
     * @param headers CreateConditionalFormattingRuleHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateConditionalFormattingRuleResponse
     */
    async createConditionalFormattingRuleWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.cellStyle)) {
            body["cellStyle"] = request.cellStyle;
        }
        if (!tea_util_1.default.isUnset(request.duplicateCondition)) {
            body["duplicateCondition"] = request.duplicateCondition;
        }
        if (!tea_util_1.default.isUnset(request.ranges)) {
            body["ranges"] = request.ranges;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateConditionalFormattingRule",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/conditionalFormattingRules`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateConditionalFormattingRuleResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateConditionalFormattingRuleRequest
     * @return CreateConditionalFormattingRuleResponse
     */
    async createConditionalFormattingRule(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateConditionalFormattingRuleHeaders({});
        return await this.createConditionalFormattingRuleWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateDeveloperMetadataRequest
     * @param headers CreateDeveloperMetadataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateDeveloperMetadataResponse
     */
    async createDeveloperMetadataWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.associatedColumn)) {
            body["associatedColumn"] = request.associatedColumn;
        }
        if (!tea_util_1.default.isUnset(request.associatedRow)) {
            body["associatedRow"] = request.associatedRow;
        }
        if (!tea_util_1.default.isUnset(request.value)) {
            body["value"] = request.value;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDeveloperMetadata",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/developerMetadatas`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateDeveloperMetadataResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateDeveloperMetadataRequest
     * @return CreateDeveloperMetadataResponse
     */
    async createDeveloperMetadata(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateDeveloperMetadataHeaders({});
        return await this.createDeveloperMetadataWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateRangeProtectionRequest
     * @param headers CreateRangeProtectionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateRangeProtectionResponse
     */
    async createRangeProtectionWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.editableSetting)) {
            body["editableSetting"] = request.editableSetting;
        }
        if (!tea_util_1.default.isUnset(request.otherUserPermission)) {
            body["otherUserPermission"] = request.otherUserPermission;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateRangeProtection",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/protections`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateRangeProtectionResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateRangeProtectionRequest
     * @return CreateRangeProtectionResponse
     */
    async createRangeProtection(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateRangeProtectionHeaders({});
        return await this.createRangeProtectionWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateSheetRequest
     * @param headers CreateSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateSheetResponse
     */
    async createSheetWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateSheetRequest
     * @return CreateSheetResponse
     */
    async createSheet(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateSheetHeaders({});
        return await this.createSheetWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateWorkspaceRequest
     * @param headers CreateWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateWorkspaceResponse
     */
    async createWorkspaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateWorkspace",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateWorkspaceRequest
     * @return CreateWorkspaceResponse
     */
    async createWorkspace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateWorkspaceHeaders({});
        return await this.createWorkspaceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateWorkspaceDocRequest
     * @param headers CreateWorkspaceDocHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateWorkspaceDocResponse
     */
    async createWorkspaceDocWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.docType)) {
            body["docType"] = request.docType;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.parentNodeId)) {
            body["parentNodeId"] = request.parentNodeId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            body["templateType"] = request.templateType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateWorkspaceDoc",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateWorkspaceDocResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateWorkspaceDocRequest
     * @return CreateWorkspaceDocResponse
     */
    async createWorkspaceDoc(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateWorkspaceDocHeaders({});
        return await this.createWorkspaceDocWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteColumnsRequest
     * @param headers DeleteColumnsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteColumnsResponse
     */
    async deleteColumnsWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.column)) {
            body["column"] = request.column;
        }
        if (!tea_util_1.default.isUnset(request.columnCount)) {
            body["columnCount"] = request.columnCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteColumns",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/deleteColumns`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteColumnsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteColumnsRequest
     * @return DeleteColumnsResponse
     */
    async deleteColumns(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteColumnsHeaders({});
        return await this.deleteColumnsWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteDropdownListsRequest
     * @param headers DeleteDropdownListsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteDropdownListsResponse
     */
    async deleteDropdownListsWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDropdownLists",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/deleteDropdownLists`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteDropdownListsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteDropdownListsRequest
     * @return DeleteDropdownListsResponse
     */
    async deleteDropdownLists(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDropdownListsHeaders({});
        return await this.deleteDropdownListsWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteRangeProtectionRequest
     * @param headers DeleteRangeProtectionHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteRangeProtectionResponse
     */
    async deleteRangeProtectionWithOptions(workbookId, sheetId, rangeAddress, protectionId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRangeProtection",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/protections/${protectionId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteRangeProtectionResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteRangeProtectionRequest
     * @return DeleteRangeProtectionResponse
     */
    async deleteRangeProtection(workbookId, sheetId, rangeAddress, protectionId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRangeProtectionHeaders({});
        return await this.deleteRangeProtectionWithOptions(workbookId, sheetId, rangeAddress, protectionId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteRowsRequest
     * @param headers DeleteRowsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteRowsResponse
     */
    async deleteRowsWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.row)) {
            body["row"] = request.row;
        }
        if (!tea_util_1.default.isUnset(request.rowCount)) {
            body["rowCount"] = request.rowCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRows",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/deleteRows`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteRowsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteRowsRequest
     * @return DeleteRowsResponse
     */
    async deleteRows(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRowsHeaders({});
        return await this.deleteRowsWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteSheetRequest
     * @param headers DeleteSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteSheetResponse
     */
    async deleteSheetWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteSheetRequest
     * @return DeleteSheetResponse
     */
    async deleteSheet(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteSheetHeaders({});
        return await this.deleteSheetWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceDocRequest
     * @param headers DeleteWorkspaceDocHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteWorkspaceDocResponse
     */
    async deleteWorkspaceDocWithOptions(workspaceId, nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteWorkspaceDoc",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs/${nodeId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteWorkspaceDocResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceDocRequest
     * @return DeleteWorkspaceDocResponse
     */
    async deleteWorkspaceDoc(workspaceId, nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteWorkspaceDocHeaders({});
        return await this.deleteWorkspaceDocWithOptions(workspaceId, nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceDocMembersRequest
     * @param headers DeleteWorkspaceDocMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteWorkspaceDocMembersResponse
     */
    async deleteWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteWorkspaceDocMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs/${nodeId}/members/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteWorkspaceDocMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceDocMembersRequest
     * @return DeleteWorkspaceDocMembersResponse
     */
    async deleteWorkspaceDocMembers(workspaceId, nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteWorkspaceDocMembersHeaders({});
        return await this.deleteWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceMembersRequest
     * @param headers DeleteWorkspaceMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteWorkspaceMembersResponse
     */
    async deleteWorkspaceMembersWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteWorkspaceMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/members/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteWorkspaceMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteWorkspaceMembersRequest
     * @return DeleteWorkspaceMembersResponse
     */
    async deleteWorkspaceMembers(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteWorkspaceMembersHeaders({});
        return await this.deleteWorkspaceMembersWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DocAppendParagraphRequest
     * @param headers DocAppendParagraphHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocAppendParagraphResponse
     */
    async docAppendParagraphWithOptions(docKey, blockId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.elementType)) {
            body["elementType"] = request.elementType;
        }
        if (!tea_util_1.default.isUnset(request.properties)) {
            body["properties"] = request.properties;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DocAppendParagraph",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/blocks/${blockId}/paragraph/appendElement`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocAppendParagraphResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DocAppendParagraphRequest
     * @return DocAppendParagraphResponse
     */
    async docAppendParagraph(docKey, blockId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocAppendParagraphHeaders({});
        return await this.docAppendParagraphWithOptions(docKey, blockId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DocAppendTextRequest
     * @param headers DocAppendTextHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocAppendTextResponse
     */
    async docAppendTextWithOptions(docKey, blockId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.text)) {
            body["text"] = request.text;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DocAppendText",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/blocks/${blockId}/paragraph/appendText`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocAppendTextResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DocAppendTextRequest
     * @return DocAppendTextResponse
     */
    async docAppendText(docKey, blockId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocAppendTextHeaders({});
        return await this.docAppendTextWithOptions(docKey, blockId, request, headers, runtime);
    }
    /**
     * @summary Block
     *
     * @param request DocBlocksQueryRequest
     * @param headers DocBlocksQueryHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocBlocksQueryResponse
     */
    async docBlocksQueryWithOptions(docKey, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.blockType)) {
            query["blockType"] = request.blockType;
        }
        if (!tea_util_1.default.isUnset(request.endIndex)) {
            query["endIndex"] = request.endIndex;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.startIndex)) {
            query["startIndex"] = request.startIndex;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DocBlocksQuery",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/blocks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocBlocksQueryResponse({}));
    }
    /**
     * @summary Block
     *
     * @param request DocBlocksQueryRequest
     * @return DocBlocksQueryResponse
     */
    async docBlocksQuery(docKey, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocBlocksQueryHeaders({});
        return await this.docBlocksQueryWithOptions(docKey, request, headers, runtime);
    }
    /**
     * @summary  Block
     *
     * @param request DocDeleteBlockRequest
     * @param headers DocDeleteBlockHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocDeleteBlockResponse
     */
    async docDeleteBlockWithOptions(docKey, blockId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DocDeleteBlock",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/blocks/${blockId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocDeleteBlockResponse({}));
    }
    /**
     * @summary  Block
     *
     * @param request DocDeleteBlockRequest
     * @return DocDeleteBlockResponse
     */
    async docDeleteBlock(docKey, blockId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocDeleteBlockHeaders({});
        return await this.docDeleteBlockWithOptions(docKey, blockId, request, headers, runtime);
    }
    /**
     * @summary Block
     *
     * @param request DocInsertBlocksRequest
     * @param headers DocInsertBlocksHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocInsertBlocksResponse
     */
    async docInsertBlocksWithOptions(docKey, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.blockId)) {
            body["blockId"] = request.blockId;
        }
        if (!tea_util_1.default.isUnset(request.element)) {
            body["element"] = request.element;
        }
        if (!tea_util_1.default.isUnset(request.index)) {
            body["index"] = request.index;
        }
        if (!tea_util_1.default.isUnset(request.where)) {
            body["where"] = request.where;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DocInsertBlocks",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/blocks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocInsertBlocksResponse({}));
    }
    /**
     * @summary Block
     *
     * @param request DocInsertBlocksRequest
     * @return DocInsertBlocksResponse
     */
    async docInsertBlocks(docKey, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocInsertBlocksHeaders({});
        return await this.docInsertBlocksWithOptions(docKey, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DocUpdateContentRequest
     * @param headers DocUpdateContentHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DocUpdateContentResponse
     */
    async docUpdateContentWithOptions(docKey, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.dataType)) {
            body["dataType"] = request.dataType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DocUpdateContent",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/suites/documents/${docKey}/overwriteContent`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocUpdateContentResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DocUpdateContentRequest
     * @return DocUpdateContentResponse
     */
    async docUpdateContent(docKey, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocUpdateContentHeaders({});
        return await this.docUpdateContentWithOptions(docKey, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetAllSheetsRequest
     * @param headers GetAllSheetsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetAllSheetsResponse
     */
    async getAllSheetsWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAllSheets",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAllSheetsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetAllSheetsRequest
     * @return GetAllSheetsResponse
     */
    async getAllSheets(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAllSheetsHeaders({});
        return await this.getAllSheetsWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetDeveloperMetadataRequest
     * @param headers GetDeveloperMetadataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetDeveloperMetadataResponse
     */
    async getDeveloperMetadataWithOptions(workbookId, developerMetadataId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDeveloperMetadata",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/developerMetadatas/${developerMetadataId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDeveloperMetadataResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetDeveloperMetadataRequest
     * @return GetDeveloperMetadataResponse
     */
    async getDeveloperMetadata(workbookId, developerMetadataId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDeveloperMetadataHeaders({});
        return await this.getDeveloperMetadataWithOptions(workbookId, developerMetadataId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetRangeRequest
     * @param headers GetRangeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetRangeResponse
     */
    async getRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.select)) {
            query["select"] = request.select;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRange",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRangeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetRangeRequest
     * @return GetRangeResponse
     */
    async getRange(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRangeHeaders({});
        return await this.getRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetRecentEditDocsRequest
     * @param headers GetRecentEditDocsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetRecentEditDocsResponse
     */
    async getRecentEditDocsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRecentEditDocs",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/docs/recentEditDocs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRecentEditDocsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetRecentEditDocsRequest
     * @return GetRecentEditDocsResponse
     */
    async getRecentEditDocs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecentEditDocsHeaders({});
        return await this.getRecentEditDocsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetRecentOpenDocsRequest
     * @param headers GetRecentOpenDocsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetRecentOpenDocsResponse
     */
    async getRecentOpenDocsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRecentOpenDocs",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/docs/recentOpenDocs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRecentOpenDocsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetRecentOpenDocsRequest
     * @return GetRecentOpenDocsResponse
     */
    async getRecentOpenDocs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecentOpenDocsHeaders({});
        return await this.getRecentOpenDocsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetRelatedWorkspacesRequest
     * @param headers GetRelatedWorkspacesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetRelatedWorkspacesResponse
     */
    async getRelatedWorkspacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.includeRecent)) {
            query["includeRecent"] = request.includeRecent;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRelatedWorkspaces",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRelatedWorkspacesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetRelatedWorkspacesRequest
     * @return GetRelatedWorkspacesResponse
     */
    async getRelatedWorkspaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRelatedWorkspacesHeaders({});
        return await this.getRelatedWorkspacesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetSheetRequest
     * @param headers GetSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetSheetResponse
     */
    async getSheetWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetSheetRequest
     * @return GetSheetResponse
     */
    async getSheet(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSheetHeaders({});
        return await this.getSheetWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetTemplateByIdRequest
     * @param headers GetTemplateByIdHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetTemplateByIdResponse
     */
    async getTemplateByIdWithOptions(templateId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.belong)) {
            query["belong"] = request.belong;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTemplateById",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/templates/${templateId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTemplateByIdResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetTemplateByIdRequest
     * @return GetTemplateByIdResponse
     */
    async getTemplateById(templateId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTemplateByIdHeaders({});
        return await this.getTemplateByIdWithOptions(templateId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers GetWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWorkspaceResponse
     */
    async getWorkspaceWithOptions(workspaceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetWorkspace",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @return GetWorkspaceResponse
     */
    async getWorkspace(workspaceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWorkspaceHeaders({});
        return await this.getWorkspaceWithOptions(workspaceId, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetWorkspaceNodeRequest
     * @param headers GetWorkspaceNodeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWorkspaceNodeResponse
     */
    async getWorkspaceNodeWithOptions(workspaceId, nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetWorkspaceNode",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs/${nodeId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWorkspaceNodeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetWorkspaceNodeRequest
     * @return GetWorkspaceNodeResponse
     */
    async getWorkspaceNode(workspaceId, nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWorkspaceNodeHeaders({});
        return await this.getWorkspaceNodeWithOptions(workspaceId, nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InitDocumentRequest
     * @param headers InitDocumentHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InitDocumentResponse
     */
    async initDocumentWithOptions(docId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.attachmentsMap)) {
            body["attachmentsMap"] = request.attachmentsMap;
        }
        if (!tea_util_1.default.isUnset(request.importType)) {
            body["importType"] = request.importType;
        }
        if (!tea_util_1.default.isUnset(request.linksKey)) {
            body["linksKey"] = request.linksKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InitDocument",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/docs/${docId}/init`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InitDocumentResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InitDocumentRequest
     * @return InitDocumentResponse
     */
    async initDocument(docId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InitDocumentHeaders({});
        return await this.initDocumentWithOptions(docId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InsertBlocksRequest
     * @param headers InsertBlocksHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InsertBlocksResponse
     */
    async insertBlocksWithOptions(documentId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.blocks)) {
            body["blocks"] = request.blocks;
        }
        if (!tea_util_1.default.isUnset(request.location)) {
            body["location"] = request.location;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InsertBlocks",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/documents/${documentId}/blocks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InsertBlocksResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InsertBlocksRequest
     * @return InsertBlocksResponse
     */
    async insertBlocks(documentId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InsertBlocksHeaders({});
        return await this.insertBlocksWithOptions(documentId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InsertColumnsBeforeRequest
     * @param headers InsertColumnsBeforeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InsertColumnsBeforeResponse
     */
    async insertColumnsBeforeWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.column)) {
            body["column"] = request.column;
        }
        if (!tea_util_1.default.isUnset(request.columnCount)) {
            body["columnCount"] = request.columnCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InsertColumnsBefore",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/insertColumnsBefore`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InsertColumnsBeforeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InsertColumnsBeforeRequest
     * @return InsertColumnsBeforeResponse
     */
    async insertColumnsBefore(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InsertColumnsBeforeHeaders({});
        return await this.insertColumnsBeforeWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InsertDropdownListsRequest
     * @param headers InsertDropdownListsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InsertDropdownListsResponse
     */
    async insertDropdownListsWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InsertDropdownLists",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/insertDropdownLists`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InsertDropdownListsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InsertDropdownListsRequest
     * @return InsertDropdownListsResponse
     */
    async insertDropdownLists(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InsertDropdownListsHeaders({});
        return await this.insertDropdownListsWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InsertRowsBeforeRequest
     * @param headers InsertRowsBeforeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InsertRowsBeforeResponse
     */
    async insertRowsBeforeWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.row)) {
            body["row"] = request.row;
        }
        if (!tea_util_1.default.isUnset(request.rowCount)) {
            body["rowCount"] = request.rowCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InsertRowsBefore",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/insertRowsBefore`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InsertRowsBeforeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InsertRowsBeforeRequest
     * @return InsertRowsBeforeResponse
     */
    async insertRowsBefore(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InsertRowsBeforeHeaders({});
        return await this.insertRowsBeforeWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListTemplateRequest
     * @param headers ListTemplateHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListTemplateResponse
     */
    async listTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            query["templateType"] = request.templateType;
        }
        if (!tea_util_1.default.isUnset(request.workspaceId)) {
            query["workspaceId"] = request.workspaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTemplate",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/templates`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListTemplateResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListTemplateRequest
     * @return ListTemplateResponse
     */
    async listTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTemplateHeaders({});
        return await this.listTemplateWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MergeRangeRequest
     * @param headers MergeRangeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MergeRangeResponse
     */
    async mergeRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MergeRange",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/merge`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MergeRangeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MergeRangeRequest
     * @return MergeRangeResponse
     */
    async mergeRange(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MergeRangeHeaders({});
        return await this.mergeRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request RangeFindNextRequest
     * @param headers RangeFindNextHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return RangeFindNextResponse
     */
    async rangeFindNextWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.findOptions)) {
            body["findOptions"] = request.findOptions;
        }
        if (!tea_util_1.default.isUnset(request.text)) {
            body["text"] = request.text;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RangeFindNext",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}/findNext`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RangeFindNextResponse({}));
    }
    /**
     * @summary 
     *
     * @param request RangeFindNextRequest
     * @return RangeFindNextResponse
     */
    async rangeFindNext(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RangeFindNextHeaders({});
        return await this.rangeFindNextWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SearchWorkspaceDocsRequest
     * @param headers SearchWorkspaceDocsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SearchWorkspaceDocsResponse
     */
    async searchWorkspaceDocsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.keyword)) {
            query["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.workspaceId)) {
            query["workspaceId"] = request.workspaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SearchWorkspaceDocs",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/docs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchWorkspaceDocsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SearchWorkspaceDocsRequest
     * @return SearchWorkspaceDocsResponse
     */
    async searchWorkspaceDocs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchWorkspaceDocsHeaders({});
        return await this.searchWorkspaceDocsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetColumnWidthRequest
     * @param headers SetColumnWidthHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetColumnWidthResponse
     */
    async setColumnWidthWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.column)) {
            body["column"] = request.column;
        }
        if (!tea_util_1.default.isUnset(request.width)) {
            body["width"] = request.width;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetColumnWidth",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/setColumnWidth`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetColumnWidthResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetColumnWidthRequest
     * @return SetColumnWidthResponse
     */
    async setColumnWidth(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetColumnWidthHeaders({});
        return await this.setColumnWidthWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetColumnsVisibilityRequest
     * @param headers SetColumnsVisibilityHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetColumnsVisibilityResponse
     */
    async setColumnsVisibilityWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.column)) {
            body["column"] = request.column;
        }
        if (!tea_util_1.default.isUnset(request.columnCount)) {
            body["columnCount"] = request.columnCount;
        }
        if (!tea_util_1.default.isUnset(request.visibility)) {
            body["visibility"] = request.visibility;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetColumnsVisibility",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/setColumnsVisibility`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetColumnsVisibilityResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetColumnsVisibilityRequest
     * @return SetColumnsVisibilityResponse
     */
    async setColumnsVisibility(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetColumnsVisibilityHeaders({});
        return await this.setColumnsVisibilityWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetRowHeightRequest
     * @param headers SetRowHeightHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetRowHeightResponse
     */
    async setRowHeightWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.height)) {
            body["height"] = request.height;
        }
        if (!tea_util_1.default.isUnset(request.row)) {
            body["row"] = request.row;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetRowHeight",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/setRowHeight`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetRowHeightResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetRowHeightRequest
     * @return SetRowHeightResponse
     */
    async setRowHeight(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetRowHeightHeaders({});
        return await this.setRowHeightWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetRowsVisibilityRequest
     * @param headers SetRowsVisibilityHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetRowsVisibilityResponse
     */
    async setRowsVisibilityWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.row)) {
            body["row"] = request.row;
        }
        if (!tea_util_1.default.isUnset(request.rowCount)) {
            body["rowCount"] = request.rowCount;
        }
        if (!tea_util_1.default.isUnset(request.visibility)) {
            body["visibility"] = request.visibility;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetRowsVisibility",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/setRowsVisibility`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetRowsVisibilityResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetRowsVisibilityRequest
     * @return SetRowsVisibilityResponse
     */
    async setRowsVisibility(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetRowsVisibilityHeaders({});
        return await this.setRowsVisibilityWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary SheetAutofitRows
     *
     * @param request SheetAutofitRowsRequest
     * @param headers SheetAutofitRowsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SheetAutofitRowsResponse
     */
    async sheetAutofitRowsWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fontWidth)) {
            body["fontWidth"] = request.fontWidth;
        }
        if (!tea_util_1.default.isUnset(request.row)) {
            body["row"] = request.row;
        }
        if (!tea_util_1.default.isUnset(request.rowCount)) {
            body["rowCount"] = request.rowCount;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SheetAutofitRows",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/autofitRows`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SheetAutofitRowsResponse({}));
    }
    /**
     * @summary SheetAutofitRows
     *
     * @param request SheetAutofitRowsRequest
     * @return SheetAutofitRowsResponse
     */
    async sheetAutofitRows(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SheetAutofitRowsHeaders({});
        return await this.sheetAutofitRowsWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SheetFindAllRequest
     * @param headers SheetFindAllHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SheetFindAllResponse
     */
    async sheetFindAllWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.select)) {
            query["select"] = request.select;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.findOptions)) {
            body["findOptions"] = request.findOptions;
        }
        if (!tea_util_1.default.isUnset(request.text)) {
            body["text"] = request.text;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SheetFindAll",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/findAll`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SheetFindAllResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SheetFindAllRequest
     * @return SheetFindAllResponse
     */
    async sheetFindAll(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SheetFindAllHeaders({});
        return await this.sheetFindAllWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UnbindCoolAppToSheetRequest
     * @param headers UnbindCoolAppToSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UnbindCoolAppToSheetResponse
     */
    async unbindCoolAppToSheetWithOptions(workbookId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            query["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnbindCoolAppToSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/coolApps`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UnbindCoolAppToSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UnbindCoolAppToSheetRequest
     * @return UnbindCoolAppToSheetResponse
     */
    async unbindCoolAppToSheet(workbookId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UnbindCoolAppToSheetHeaders({});
        return await this.unbindCoolAppToSheetWithOptions(workbookId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateRangeRequest
     * @param headers UpdateRangeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateRangeResponse
     */
    async updateRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.backgroundColors)) {
            body["backgroundColors"] = request.backgroundColors;
        }
        if (!tea_util_1.default.isUnset(request.fontSizes)) {
            body["fontSizes"] = request.fontSizes;
        }
        if (!tea_util_1.default.isUnset(request.fontWeights)) {
            body["fontWeights"] = request.fontWeights;
        }
        if (!tea_util_1.default.isUnset(request.horizontalAlignments)) {
            body["horizontalAlignments"] = request.horizontalAlignments;
        }
        if (!tea_util_1.default.isUnset(request.hyperlinks)) {
            body["hyperlinks"] = request.hyperlinks;
        }
        if (!tea_util_1.default.isUnset(request.numberFormat)) {
            body["numberFormat"] = request.numberFormat;
        }
        if (!tea_util_1.default.isUnset(request.values)) {
            body["values"] = request.values;
        }
        if (!tea_util_1.default.isUnset(request.verticalAlignments)) {
            body["verticalAlignments"] = request.verticalAlignments;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRange",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}/ranges/${rangeAddress}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateRangeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateRangeRequest
     * @return UpdateRangeResponse
     */
    async updateRange(workbookId, sheetId, rangeAddress, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateRangeHeaders({});
        return await this.updateRangeWithOptions(workbookId, sheetId, rangeAddress, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateSheetRequest
     * @param headers UpdateSheetHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateSheetResponse
     */
    async updateSheetWithOptions(workbookId, sheetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.visibility)) {
            body["visibility"] = request.visibility;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSheet",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workbooks/${workbookId}/sheets/${sheetId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateSheetResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateSheetRequest
     * @return UpdateSheetResponse
     */
    async updateSheet(workbookId, sheetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateSheetHeaders({});
        return await this.updateSheetWithOptions(workbookId, sheetId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateWorkspaceDocMembersRequest
     * @param headers UpdateWorkspaceDocMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateWorkspaceDocMembersResponse
     */
    async updateWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateWorkspaceDocMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/docs/${nodeId}/members`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateWorkspaceDocMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateWorkspaceDocMembersRequest
     * @return UpdateWorkspaceDocMembersResponse
     */
    async updateWorkspaceDocMembers(workspaceId, nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateWorkspaceDocMembersHeaders({});
        return await this.updateWorkspaceDocMembersWithOptions(workspaceId, nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateWorkspaceMembersRequest
     * @param headers UpdateWorkspaceMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateWorkspaceMembersResponse
     */
    async updateWorkspaceMembersWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateWorkspaceMembers",
            version: "doc_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/doc/workspaces/${workspaceId}/members`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateWorkspaceMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateWorkspaceMembersRequest
     * @return UpdateWorkspaceMembersResponse
     */
    async updateWorkspaceMembers(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateWorkspaceMembersHeaders({});
        return await this.updateWorkspaceMembersWithOptions(workspaceId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map