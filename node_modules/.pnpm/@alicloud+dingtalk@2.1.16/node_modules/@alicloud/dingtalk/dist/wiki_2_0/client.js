"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListNodesRequest = exports.ListNodesHeaders = exports.HandOverWorkspaceResponse = exports.HandOverWorkspaceResponseBody = exports.HandOverWorkspaceRequest = exports.HandOverWorkspaceHeaders = exports.GetWorkspacesResponse = exports.GetWorkspacesResponseBody = exports.GetWorkspacesRequest = exports.GetWorkspacesHeaders = exports.GetWorkspaceResponse = exports.GetWorkspaceResponseBody = exports.GetWorkspaceRequest = exports.GetWorkspaceHeaders = exports.GetTeamResponse = exports.GetTeamResponseBody = exports.GetTeamRequest = exports.GetTeamHeaders = exports.GetNodesResponse = exports.GetNodesResponseBody = exports.GetNodesRequest = exports.GetNodesHeaders = exports.GetNodeByUrlResponse = exports.GetNodeByUrlResponseBody = exports.GetNodeByUrlRequest = exports.GetNodeByUrlHeaders = exports.GetNodeResponse = exports.GetNodeResponseBody = exports.GetNodeRequest = exports.GetNodeHeaders = exports.GetMineWorkspaceResponse = exports.GetMineWorkspaceResponseBody = exports.GetMineWorkspaceRequest = exports.GetMineWorkspaceHeaders = exports.GetDefaultHandOverUserResponse = exports.GetDefaultHandOverUserResponseBody = exports.GetDefaultHandOverUserRequest = exports.GetDefaultHandOverUserHeaders = exports.DeleteTeamResponse = exports.DeleteTeamResponseBody = exports.DeleteTeamRequest = exports.DeleteTeamHeaders = exports.AddWorkspaceResponse = exports.AddWorkspaceResponseBody = exports.AddWorkspaceRequest = exports.AddWorkspaceHeaders = exports.AddTeamResponse = exports.AddTeamResponseBody = exports.AddTeamRequest = exports.AddTeamHeaders = void 0;
exports.ListWorkspacesResponseBodyWorkspaces = exports.ListWorkspacesResponseBodyWorkspacesIcon = exports.ListTeamsResponseBodyTeams = exports.ListTeamsResponseBodyTeamsIcon = exports.ListNodesResponseBodyNodes = exports.ListNodesResponseBodyNodesStatisticalInfo = exports.GetWorkspacesResponseBodyWorkspaces = exports.GetWorkspacesResponseBodyWorkspacesIcon = exports.GetWorkspacesRequestOption = exports.GetWorkspaceResponseBodyWorkspace = exports.GetWorkspaceResponseBodyWorkspaceIcon = exports.GetTeamResponseBodyTeam = exports.GetTeamResponseBodyTeamIcon = exports.GetNodesResponseBodyNodes = exports.GetNodesResponseBodyNodesStatisticalInfo = exports.GetNodesRequestOption = exports.GetNodeByUrlResponseBodyNode = exports.GetNodeByUrlResponseBodyNodeStatisticalInfo = exports.GetNodeByUrlRequestOption = exports.GetNodeResponseBodyNode = exports.GetNodeResponseBodyNodeStatisticalInfo = exports.GetMineWorkspaceResponseBodyWorkspace = exports.GetMineWorkspaceResponseBodyWorkspaceIcon = exports.AddWorkspaceResponseBodyWorkspace = exports.AddWorkspaceResponseBodyWorkspaceIcon = exports.AddWorkspaceRequestOption = exports.AddTeamResponseBodyTeam = exports.AddTeamResponseBodyTeamIcon = exports.AddTeamRequestOption = exports.AddTeamRequestOptionIcon = exports.SetDefaultHandOverUserResponse = exports.SetDefaultHandOverUserResponseBody = exports.SetDefaultHandOverUserRequest = exports.SetDefaultHandOverUserHeaders = exports.ListWorkspacesResponse = exports.ListWorkspacesResponseBody = exports.ListWorkspacesRequest = exports.ListWorkspacesHeaders = exports.ListTeamsResponse = exports.ListTeamsResponseBody = exports.ListTeamsRequest = exports.ListTeamsHeaders = exports.ListNodesResponse = exports.ListNodesResponseBody = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddTeamHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamHeaders = AddTeamHeaders;
class AddTeamRequest extends $tea.Model {
    static names() {
        return {
            name: 'name',
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: AddTeamRequestOption,
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamRequest = AddTeamRequest;
class AddTeamResponseBody extends $tea.Model {
    static names() {
        return {
            team: 'team',
        };
    }
    static types() {
        return {
            team: AddTeamResponseBodyTeam,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamResponseBody = AddTeamResponseBody;
class AddTeamResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddTeamResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamResponse = AddTeamResponse;
class AddWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceHeaders = AddWorkspaceHeaders;
class AddWorkspaceRequest extends $tea.Model {
    static names() {
        return {
            name: 'name',
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: AddWorkspaceRequestOption,
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceRequest = AddWorkspaceRequest;
class AddWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            workspace: 'workspace',
        };
    }
    static types() {
        return {
            workspace: AddWorkspaceResponseBodyWorkspace,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceResponseBody = AddWorkspaceResponseBody;
class AddWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceResponse = AddWorkspaceResponse;
class DeleteTeamHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteTeamHeaders = DeleteTeamHeaders;
class DeleteTeamRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteTeamRequest = DeleteTeamRequest;
class DeleteTeamResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteTeamResponseBody = DeleteTeamResponseBody;
class DeleteTeamResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteTeamResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteTeamResponse = DeleteTeamResponse;
class GetDefaultHandOverUserHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDefaultHandOverUserHeaders = GetDefaultHandOverUserHeaders;
class GetDefaultHandOverUserRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDefaultHandOverUserRequest = GetDefaultHandOverUserRequest;
class GetDefaultHandOverUserResponseBody extends $tea.Model {
    static names() {
        return {
            defaultHandoverUserId: 'defaultHandoverUserId',
        };
    }
    static types() {
        return {
            defaultHandoverUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDefaultHandOverUserResponseBody = GetDefaultHandOverUserResponseBody;
class GetDefaultHandOverUserResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDefaultHandOverUserResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDefaultHandOverUserResponse = GetDefaultHandOverUserResponse;
class GetMineWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceHeaders = GetMineWorkspaceHeaders;
class GetMineWorkspaceRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceRequest = GetMineWorkspaceRequest;
class GetMineWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            workspace: 'workspace',
        };
    }
    static types() {
        return {
            workspace: GetMineWorkspaceResponseBodyWorkspace,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceResponseBody = GetMineWorkspaceResponseBody;
class GetMineWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMineWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceResponse = GetMineWorkspaceResponse;
class GetNodeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeHeaders = GetNodeHeaders;
class GetNodeRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
            withPermissionRole: 'withPermissionRole',
            withStatisticalInfo: 'withStatisticalInfo',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            withPermissionRole: 'boolean',
            withStatisticalInfo: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeRequest = GetNodeRequest;
class GetNodeResponseBody extends $tea.Model {
    static names() {
        return {
            node: 'node',
        };
    }
    static types() {
        return {
            node: GetNodeResponseBodyNode,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeResponseBody = GetNodeResponseBody;
class GetNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeResponse = GetNodeResponse;
class GetNodeByUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlHeaders = GetNodeByUrlHeaders;
class GetNodeByUrlRequest extends $tea.Model {
    static names() {
        return {
            option: 'option',
            url: 'url',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: GetNodeByUrlRequestOption,
            url: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlRequest = GetNodeByUrlRequest;
class GetNodeByUrlResponseBody extends $tea.Model {
    static names() {
        return {
            node: 'node',
        };
    }
    static types() {
        return {
            node: GetNodeByUrlResponseBodyNode,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlResponseBody = GetNodeByUrlResponseBody;
class GetNodeByUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetNodeByUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlResponse = GetNodeByUrlResponse;
class GetNodesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesHeaders = GetNodesHeaders;
class GetNodesRequest extends $tea.Model {
    static names() {
        return {
            nodeIds: 'nodeIds',
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            nodeIds: { 'type': 'array', 'itemType': 'string' },
            option: GetNodesRequestOption,
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesRequest = GetNodesRequest;
class GetNodesResponseBody extends $tea.Model {
    static names() {
        return {
            nodes: 'nodes',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': GetNodesResponseBodyNodes },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesResponseBody = GetNodesResponseBody;
class GetNodesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetNodesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesResponse = GetNodesResponse;
class GetTeamHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamHeaders = GetTeamHeaders;
class GetTeamRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamRequest = GetTeamRequest;
class GetTeamResponseBody extends $tea.Model {
    static names() {
        return {
            team: 'team',
        };
    }
    static types() {
        return {
            team: GetTeamResponseBodyTeam,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamResponseBody = GetTeamResponseBody;
class GetTeamResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTeamResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamResponse = GetTeamResponse;
class GetWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceHeaders = GetWorkspaceHeaders;
class GetWorkspaceRequest extends $tea.Model {
    static names() {
        return {
            operatorId: 'operatorId',
            withPermissionRole: 'withPermissionRole',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            withPermissionRole: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceRequest = GetWorkspaceRequest;
class GetWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            workspace: 'workspace',
        };
    }
    static types() {
        return {
            workspace: GetWorkspaceResponseBodyWorkspace,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponseBody = GetWorkspaceResponseBody;
class GetWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponse = GetWorkspaceResponse;
class GetWorkspacesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesHeaders = GetWorkspacesHeaders;
class GetWorkspacesRequest extends $tea.Model {
    static names() {
        return {
            option: 'option',
            workspaceIds: 'workspaceIds',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: GetWorkspacesRequestOption,
            workspaceIds: { 'type': 'array', 'itemType': 'string' },
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesRequest = GetWorkspacesRequest;
class GetWorkspacesResponseBody extends $tea.Model {
    static names() {
        return {
            workspaces: 'workspaces',
        };
    }
    static types() {
        return {
            workspaces: { 'type': 'array', 'itemType': GetWorkspacesResponseBodyWorkspaces },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesResponseBody = GetWorkspacesResponseBody;
class GetWorkspacesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetWorkspacesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesResponse = GetWorkspacesResponse;
class HandOverWorkspaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HandOverWorkspaceHeaders = HandOverWorkspaceHeaders;
class HandOverWorkspaceRequest extends $tea.Model {
    static names() {
        return {
            sourceOwnerId: 'sourceOwnerId',
            targetOwnerId: 'targetOwnerId',
            workspaceId: 'workspaceId',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            sourceOwnerId: 'string',
            targetOwnerId: 'string',
            workspaceId: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HandOverWorkspaceRequest = HandOverWorkspaceRequest;
class HandOverWorkspaceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HandOverWorkspaceResponseBody = HandOverWorkspaceResponseBody;
class HandOverWorkspaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HandOverWorkspaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.HandOverWorkspaceResponse = HandOverWorkspaceResponse;
class ListNodesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesHeaders = ListNodesHeaders;
class ListNodesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            parentNodeId: 'parentNodeId',
            withPermissionRole: 'withPermissionRole',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            parentNodeId: 'string',
            withPermissionRole: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesRequest = ListNodesRequest;
class ListNodesResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            nodes: 'nodes',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            nodes: { 'type': 'array', 'itemType': ListNodesResponseBodyNodes },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesResponseBody = ListNodesResponseBody;
class ListNodesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListNodesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesResponse = ListNodesResponse;
class ListTeamsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsHeaders = ListTeamsHeaders;
class ListTeamsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsRequest = ListTeamsRequest;
class ListTeamsResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            teams: 'teams',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            teams: { 'type': 'array', 'itemType': ListTeamsResponseBodyTeams },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsResponseBody = ListTeamsResponseBody;
class ListTeamsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTeamsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsResponse = ListTeamsResponse;
class ListWorkspacesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesHeaders = ListWorkspacesHeaders;
class ListWorkspacesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            orderBy: 'orderBy',
            teamId: 'teamId',
            withPermissionRole: 'withPermissionRole',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            orderBy: 'string',
            teamId: 'string',
            withPermissionRole: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesRequest = ListWorkspacesRequest;
class ListWorkspacesResponseBody extends $tea.Model {
    static names() {
        return {
            nextToken: 'nextToken',
            workspaces: 'workspaces',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            workspaces: { 'type': 'array', 'itemType': ListWorkspacesResponseBodyWorkspaces },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesResponseBody = ListWorkspacesResponseBody;
class ListWorkspacesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListWorkspacesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesResponse = ListWorkspacesResponse;
class SetDefaultHandOverUserHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetDefaultHandOverUserHeaders = SetDefaultHandOverUserHeaders;
class SetDefaultHandOverUserRequest extends $tea.Model {
    static names() {
        return {
            defaultHandoverUserId: 'defaultHandoverUserId',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            defaultHandoverUserId: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetDefaultHandOverUserRequest = SetDefaultHandOverUserRequest;
class SetDefaultHandOverUserResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetDefaultHandOverUserResponseBody = SetDefaultHandOverUserResponseBody;
class SetDefaultHandOverUserResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetDefaultHandOverUserResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetDefaultHandOverUserResponse = SetDefaultHandOverUserResponse;
class AddTeamRequestOptionIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamRequestOptionIcon = AddTeamRequestOptionIcon;
class AddTeamRequestOption extends $tea.Model {
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            icon: 'icon',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            icon: AddTeamRequestOptionIcon,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamRequestOption = AddTeamRequestOption;
class AddTeamResponseBodyTeamIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamResponseBodyTeamIcon = AddTeamResponseBodyTeamIcon;
class AddTeamResponseBodyTeam extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: AddTeamResponseBodyTeamIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            teamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddTeamResponseBodyTeam = AddTeamResponseBodyTeam;
class AddWorkspaceRequestOption extends $tea.Model {
    static names() {
        return {
            description: 'description',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            description: 'string',
            teamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceRequestOption = AddWorkspaceRequestOption;
class AddWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceResponseBodyWorkspaceIcon = AddWorkspaceResponseBodyWorkspaceIcon;
class AddWorkspaceResponseBodyWorkspace extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            permissionRole: 'permissionRole',
            rootNodeId: 'rootNodeId',
            teamId: 'teamId',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: AddWorkspaceResponseBodyWorkspaceIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            permissionRole: 'string',
            rootNodeId: 'string',
            teamId: 'string',
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddWorkspaceResponseBodyWorkspace = AddWorkspaceResponseBodyWorkspace;
class GetMineWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceResponseBodyWorkspaceIcon = GetMineWorkspaceResponseBodyWorkspaceIcon;
class GetMineWorkspaceResponseBodyWorkspace extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            permissionRole: 'permissionRole',
            rootNodeId: 'rootNodeId',
            teamId: 'teamId',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: GetMineWorkspaceResponseBodyWorkspaceIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            permissionRole: 'string',
            rootNodeId: 'string',
            teamId: 'string',
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMineWorkspaceResponseBodyWorkspace = GetMineWorkspaceResponseBodyWorkspace;
class GetNodeResponseBodyNodeStatisticalInfo extends $tea.Model {
    static names() {
        return {
            wordCount: 'wordCount',
        };
    }
    static types() {
        return {
            wordCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeResponseBodyNodeStatisticalInfo = GetNodeResponseBodyNodeStatisticalInfo;
class GetNodeResponseBodyNode extends $tea.Model {
    static names() {
        return {
            category: 'category',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            hasChildren: 'hasChildren',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            nodeId: 'nodeId',
            permissionRole: 'permissionRole',
            size: 'size',
            statisticalInfo: 'statisticalInfo',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            category: 'string',
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            nodeId: 'string',
            permissionRole: 'string',
            size: 'number',
            statisticalInfo: GetNodeResponseBodyNodeStatisticalInfo,
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeResponseBodyNode = GetNodeResponseBodyNode;
class GetNodeByUrlRequestOption extends $tea.Model {
    static names() {
        return {
            withPermissionRole: 'withPermissionRole',
            withStatisticalInfo: 'withStatisticalInfo',
        };
    }
    static types() {
        return {
            withPermissionRole: 'boolean',
            withStatisticalInfo: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlRequestOption = GetNodeByUrlRequestOption;
class GetNodeByUrlResponseBodyNodeStatisticalInfo extends $tea.Model {
    static names() {
        return {
            wordCount: 'wordCount',
        };
    }
    static types() {
        return {
            wordCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlResponseBodyNodeStatisticalInfo = GetNodeByUrlResponseBodyNodeStatisticalInfo;
class GetNodeByUrlResponseBodyNode extends $tea.Model {
    static names() {
        return {
            category: 'category',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            hasChildren: 'hasChildren',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            nodeId: 'nodeId',
            permissionRole: 'permissionRole',
            size: 'size',
            statisticalInfo: 'statisticalInfo',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            category: 'string',
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            nodeId: 'string',
            permissionRole: 'string',
            size: 'number',
            statisticalInfo: GetNodeByUrlResponseBodyNodeStatisticalInfo,
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodeByUrlResponseBodyNode = GetNodeByUrlResponseBodyNode;
class GetNodesRequestOption extends $tea.Model {
    static names() {
        return {
            withPermissionRole: 'withPermissionRole',
            withStatisticalInfo: 'withStatisticalInfo',
        };
    }
    static types() {
        return {
            withPermissionRole: 'boolean',
            withStatisticalInfo: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesRequestOption = GetNodesRequestOption;
class GetNodesResponseBodyNodesStatisticalInfo extends $tea.Model {
    static names() {
        return {
            wordCount: 'wordCount',
        };
    }
    static types() {
        return {
            wordCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesResponseBodyNodesStatisticalInfo = GetNodesResponseBodyNodesStatisticalInfo;
class GetNodesResponseBodyNodes extends $tea.Model {
    static names() {
        return {
            category: 'category',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            hasChildren: 'hasChildren',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            nodeId: 'nodeId',
            permissionRole: 'permissionRole',
            size: 'size',
            statisticalInfo: 'statisticalInfo',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            category: 'string',
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            nodeId: 'string',
            permissionRole: 'string',
            size: 'number',
            statisticalInfo: GetNodesResponseBodyNodesStatisticalInfo,
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNodesResponseBodyNodes = GetNodesResponseBodyNodes;
class GetTeamResponseBodyTeamIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamResponseBodyTeamIcon = GetTeamResponseBodyTeamIcon;
class GetTeamResponseBodyTeam extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: GetTeamResponseBodyTeamIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            teamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetTeamResponseBodyTeam = GetTeamResponseBodyTeam;
class GetWorkspaceResponseBodyWorkspaceIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponseBodyWorkspaceIcon = GetWorkspaceResponseBodyWorkspaceIcon;
class GetWorkspaceResponseBodyWorkspace extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            permissionRole: 'permissionRole',
            rootNodeId: 'rootNodeId',
            teamId: 'teamId',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: GetWorkspaceResponseBodyWorkspaceIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            permissionRole: 'string',
            rootNodeId: 'string',
            teamId: 'string',
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspaceResponseBodyWorkspace = GetWorkspaceResponseBodyWorkspace;
class GetWorkspacesRequestOption extends $tea.Model {
    static names() {
        return {
            withPermissionRole: 'withPermissionRole',
        };
    }
    static types() {
        return {
            withPermissionRole: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesRequestOption = GetWorkspacesRequestOption;
class GetWorkspacesResponseBodyWorkspacesIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesResponseBodyWorkspacesIcon = GetWorkspacesResponseBodyWorkspacesIcon;
class GetWorkspacesResponseBodyWorkspaces extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            permissionRole: 'permissionRole',
            rootNodeId: 'rootNodeId',
            teamId: 'teamId',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: GetWorkspacesResponseBodyWorkspacesIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            permissionRole: 'string',
            rootNodeId: 'string',
            teamId: 'string',
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetWorkspacesResponseBodyWorkspaces = GetWorkspacesResponseBodyWorkspaces;
class ListNodesResponseBodyNodesStatisticalInfo extends $tea.Model {
    static names() {
        return {
            wordCount: 'wordCount',
        };
    }
    static types() {
        return {
            wordCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesResponseBodyNodesStatisticalInfo = ListNodesResponseBodyNodesStatisticalInfo;
class ListNodesResponseBodyNodes extends $tea.Model {
    static names() {
        return {
            category: 'category',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            hasChildren: 'hasChildren',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            nodeId: 'nodeId',
            permissionRole: 'permissionRole',
            size: 'size',
            statisticalInfo: 'statisticalInfo',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            category: 'string',
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            nodeId: 'string',
            permissionRole: 'string',
            size: 'number',
            statisticalInfo: ListNodesResponseBodyNodesStatisticalInfo,
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListNodesResponseBodyNodes = ListNodesResponseBodyNodes;
class ListTeamsResponseBodyTeamsIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsResponseBodyTeamsIcon = ListTeamsResponseBodyTeamsIcon;
class ListTeamsResponseBodyTeams extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: ListTeamsResponseBodyTeamsIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            teamId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListTeamsResponseBodyTeams = ListTeamsResponseBodyTeams;
class ListWorkspacesResponseBodyWorkspacesIcon extends $tea.Model {
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesResponseBodyWorkspacesIcon = ListWorkspacesResponseBodyWorkspacesIcon;
class ListWorkspacesResponseBodyWorkspaces extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            cover: 'cover',
            createTime: 'createTime',
            creatorId: 'creatorId',
            description: 'description',
            icon: 'icon',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            permissionRole: 'permissionRole',
            rootNodeId: 'rootNodeId',
            teamId: 'teamId',
            type: 'type',
            url: 'url',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            cover: 'string',
            createTime: 'string',
            creatorId: 'string',
            description: 'string',
            icon: ListWorkspacesResponseBodyWorkspacesIcon,
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            permissionRole: 'string',
            rootNodeId: 'string',
            teamId: 'string',
            type: 'string',
            url: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListWorkspacesResponseBodyWorkspaces = ListWorkspacesResponseBodyWorkspaces;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request AddTeamRequest
     * @param headers AddTeamHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddTeamResponse
     */
    async addTeamWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddTeam",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/teams`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddTeamResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddTeamRequest
     * @return AddTeamResponse
     */
    async addTeam(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddTeamHeaders({});
        return await this.addTeamWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceRequest
     * @param headers AddWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return AddWorkspaceResponse
     */
    async addWorkspaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddWorkspace",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/workspaces`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request AddWorkspaceRequest
     * @return AddWorkspaceResponse
     */
    async addWorkspace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddWorkspaceHeaders({});
        return await this.addWorkspaceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request DeleteTeamRequest
     * @param headers DeleteTeamHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return DeleteTeamResponse
     */
    async deleteTeamWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteTeam",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/teams/${teamId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteTeamResponse({}));
    }
    /**
     * @summary 
     *
     * @param request DeleteTeamRequest
     * @return DeleteTeamResponse
     */
    async deleteTeam(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteTeamHeaders({});
        return await this.deleteTeamWithOptions(teamId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetDefaultHandOverUserRequest
     * @param headers GetDefaultHandOverUserHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetDefaultHandOverUserResponse
     */
    async getDefaultHandOverUserWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDefaultHandOverUser",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/managementSettings/defaultHandOverUsers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDefaultHandOverUserResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetDefaultHandOverUserRequest
     * @return GetDefaultHandOverUserResponse
     */
    async getDefaultHandOverUser(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDefaultHandOverUserHeaders({});
        return await this.getDefaultHandOverUserWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetMineWorkspaceRequest
     * @param headers GetMineWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetMineWorkspaceResponse
     */
    async getMineWorkspaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetMineWorkspace",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/mineWorkspaces`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetMineWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetMineWorkspaceRequest
     * @return GetMineWorkspaceResponse
     */
    async getMineWorkspace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMineWorkspaceHeaders({});
        return await this.getMineWorkspaceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetNodeRequest
     * @param headers GetNodeHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetNodeResponse
     */
    async getNodeWithOptions(nodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.withPermissionRole)) {
            query["withPermissionRole"] = request.withPermissionRole;
        }
        if (!tea_util_1.default.isUnset(request.withStatisticalInfo)) {
            query["withStatisticalInfo"] = request.withStatisticalInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetNode",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/nodes/${nodeId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetNodeResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetNodeRequest
     * @return GetNodeResponse
     */
    async getNode(nodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetNodeHeaders({});
        return await this.getNodeWithOptions(nodeId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetNodeByUrlRequest
     * @param headers GetNodeByUrlHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetNodeByUrlResponse
     */
    async getNodeByUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.url)) {
            body["url"] = request.url;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetNodeByUrl",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/nodes/queryByUrl`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetNodeByUrlResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetNodeByUrlRequest
     * @return GetNodeByUrlResponse
     */
    async getNodeByUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetNodeByUrlHeaders({});
        return await this.getNodeByUrlWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetNodesRequest
     * @param headers GetNodesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetNodesResponse
     */
    async getNodesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.nodeIds)) {
            body["nodeIds"] = request.nodeIds;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetNodes",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/nodes/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetNodesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetNodesRequest
     * @return GetNodesResponse
     */
    async getNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetNodesHeaders({});
        return await this.getNodesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetTeamRequest
     * @param headers GetTeamHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetTeamResponse
     */
    async getTeamWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTeam",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/teams/${teamId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTeamResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetTeamRequest
     * @return GetTeamResponse
     */
    async getTeam(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTeamHeaders({});
        return await this.getTeamWithOptions(teamId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetWorkspaceRequest
     * @param headers GetWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWorkspaceResponse
     */
    async getWorkspaceWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.withPermissionRole)) {
            query["withPermissionRole"] = request.withPermissionRole;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetWorkspace",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/workspaces/${workspaceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetWorkspaceRequest
     * @return GetWorkspaceResponse
     */
    async getWorkspace(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWorkspaceHeaders({});
        return await this.getWorkspaceWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetWorkspacesRequest
     * @param headers GetWorkspacesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetWorkspacesResponse
     */
    async getWorkspacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.workspaceIds)) {
            body["workspaceIds"] = request.workspaceIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetWorkspaces",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/workspaces/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetWorkspacesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetWorkspacesRequest
     * @return GetWorkspacesResponse
     */
    async getWorkspaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetWorkspacesHeaders({});
        return await this.getWorkspacesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request HandOverWorkspaceRequest
     * @param headers HandOverWorkspaceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return HandOverWorkspaceResponse
     */
    async handOverWorkspaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.sourceOwnerId)) {
            body["sourceOwnerId"] = request.sourceOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.targetOwnerId)) {
            body["targetOwnerId"] = request.targetOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.workspaceId)) {
            body["workspaceId"] = request.workspaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HandOverWorkspace",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/managementOperations/workspaces/handOver`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HandOverWorkspaceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request HandOverWorkspaceRequest
     * @return HandOverWorkspaceResponse
     */
    async handOverWorkspace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HandOverWorkspaceHeaders({});
        return await this.handOverWorkspaceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListNodesRequest
     * @param headers ListNodesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListNodesResponse
     */
    async listNodesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.parentNodeId)) {
            query["parentNodeId"] = request.parentNodeId;
        }
        if (!tea_util_1.default.isUnset(request.withPermissionRole)) {
            query["withPermissionRole"] = request.withPermissionRole;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListNodes",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/nodes`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListNodesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListNodesRequest
     * @return ListNodesResponse
     */
    async listNodes(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListNodesHeaders({});
        return await this.listNodesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListTeamsRequest
     * @param headers ListTeamsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListTeamsResponse
     */
    async listTeamsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTeams",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/teams`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListTeamsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListTeamsRequest
     * @return ListTeamsResponse
     */
    async listTeams(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTeamsHeaders({});
        return await this.listTeamsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request ListWorkspacesRequest
     * @param headers ListWorkspacesHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return ListWorkspacesResponse
     */
    async listWorkspacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.orderBy)) {
            query["orderBy"] = request.orderBy;
        }
        if (!tea_util_1.default.isUnset(request.teamId)) {
            query["teamId"] = request.teamId;
        }
        if (!tea_util_1.default.isUnset(request.withPermissionRole)) {
            query["withPermissionRole"] = request.withPermissionRole;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListWorkspaces",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/workspaces`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListWorkspacesResponse({}));
    }
    /**
     * @summary 
     *
     * @param request ListWorkspacesRequest
     * @return ListWorkspacesResponse
     */
    async listWorkspaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListWorkspacesHeaders({});
        return await this.listWorkspacesWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request SetDefaultHandOverUserRequest
     * @param headers SetDefaultHandOverUserHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return SetDefaultHandOverUserResponse
     */
    async setDefaultHandOverUserWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.defaultHandoverUserId)) {
            body["defaultHandoverUserId"] = request.defaultHandoverUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetDefaultHandOverUser",
            version: "wiki_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/wiki/managementSettings/defaultHandOverUsers/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetDefaultHandOverUserResponse({}));
    }
    /**
     * @summary 
     *
     * @param request SetDefaultHandOverUserRequest
     * @return SetDefaultHandOverUserResponse
     */
    async setDefaultHandOverUser(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetDefaultHandOverUserHeaders({});
        return await this.setDefaultHandOverUserWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map