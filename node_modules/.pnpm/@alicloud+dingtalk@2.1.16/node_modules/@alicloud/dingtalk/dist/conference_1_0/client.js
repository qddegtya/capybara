"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetUserMetricDataResponse = exports.GetUserMetricDataResponseBody = exports.GetUserMetricDataRequest = exports.GetUserMetricDataHeaders = exports.GetUserLastMetricResponse = exports.GetUserLastMetricResponseBody = exports.GetUserLastMetricRequest = exports.GetUserLastMetricHeaders = exports.GetHistoryConfDataListResponse = exports.GetHistoryConfDataListResponseBody = exports.GetHistoryConfDataListRequest = exports.GetHistoryConfDataListHeaders = exports.GetConfDetailDataResponse = exports.GetConfDetailDataResponseBody = exports.GetConfDetailDataRequest = exports.GetConfDetailDataHeaders = exports.GetConfDataByConferenceIdResponse = exports.GetConfDataByConferenceIdResponseBody = exports.GetConfDataByConferenceIdRequest = exports.GetConfDataByConferenceIdHeaders = exports.FocusResponse = exports.FocusResponseBody = exports.FocusRequest = exports.FocusHeaders = exports.CreateVideoConferenceResponse = exports.CreateVideoConferenceResponseBody = exports.CreateVideoConferenceRequest = exports.CreateVideoConferenceHeaders = exports.CreateScheduleConferenceResponse = exports.CreateScheduleConferenceResponseBody = exports.CreateScheduleConferenceRequest = exports.CreateScheduleConferenceHeaders = exports.CreateCustomShortLinkResponse = exports.CreateCustomShortLinkResponseBody = exports.CreateCustomShortLinkRequest = exports.CreateCustomShortLinkHeaders = exports.CohostsResponse = exports.CohostsResponseBody = exports.CohostsRequest = exports.CohostsHeaders = exports.CloseVideoConferenceResponse = exports.CloseVideoConferenceResponseBody = exports.CloseVideoConferenceRequest = exports.CloseVideoConferenceHeaders = exports.CancelScheduleConferenceResponse = exports.CancelScheduleConferenceResponseBody = exports.CancelScheduleConferenceRequest = exports.CancelScheduleConferenceHeaders = exports.MemberModelMapValue = exports.MetricMapValue = void 0;
exports.QueryScheduleConferenceResponseBody = exports.QueryScheduleConferenceRequest = exports.QueryScheduleConferenceHeaders = exports.QueryScheduleConfSettingsResponse = exports.QueryScheduleConfSettingsResponseBody = exports.QueryScheduleConfSettingsRequest = exports.QueryScheduleConfSettingsHeaders = exports.QueryConferenceMembersResponse = exports.QueryConferenceMembersResponseBody = exports.QueryConferenceMembersRequest = exports.QueryConferenceMembersHeaders = exports.QueryConferenceInfoBatchResponse = exports.QueryConferenceInfoBatchResponseBody = exports.QueryConferenceInfoBatchRequest = exports.QueryConferenceInfoBatchHeaders = exports.QueryConferenceInfoResponse = exports.QueryConferenceInfoResponseBody = exports.QueryConferenceInfoHeaders = exports.QueryCloudRecordVideoPlayInfoResponse = exports.QueryCloudRecordVideoPlayInfoResponseBody = exports.QueryCloudRecordVideoPlayInfoRequest = exports.QueryCloudRecordVideoPlayInfoHeaders = exports.QueryCloudRecordVideoResponse = exports.QueryCloudRecordVideoResponseBody = exports.QueryCloudRecordVideoRequest = exports.QueryCloudRecordVideoHeaders = exports.QueryCloudRecordTextResponse = exports.QueryCloudRecordTextResponseBody = exports.QueryCloudRecordTextRequest = exports.QueryCloudRecordTextHeaders = exports.MuteMembersResponse = exports.MuteMembersResponseBody = exports.MuteMembersRequest = exports.MuteMembersHeaders = exports.MuteAllResponse = exports.MuteAllResponseBody = exports.MuteAllRequest = exports.MuteAllHeaders = exports.LockConferenceResponse = exports.LockConferenceResponseBody = exports.LockConferenceRequest = exports.LockConferenceHeaders = exports.KickMembersResponse = exports.KickMembersResponseBody = exports.KickMembersRequest = exports.KickMembersHeaders = exports.InviteUsersResponse = exports.InviteUsersResponseBody = exports.InviteUsersRequest = exports.InviteUsersHeaders = void 0;
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = exports.MuteMembersRequestUserList = exports.KickMembersRequestUserList = exports.InviteUsersRequestPhoneInviteeList = exports.InviteUsersRequestInviteeList = exports.GetUserMetricDataResponseBodyMetricDataList = exports.GetHistoryConfDataListResponseBodyList = exports.GetConfDetailDataResponseBodyList = exports.CreateCustomShortLinkResponseBodyResult = exports.CohostsRequestUserList = exports.UpdateVideoConferenceSettingResponse = exports.UpdateVideoConferenceSettingResponseBody = exports.UpdateVideoConferenceSettingRequest = exports.UpdateVideoConferenceSettingHeaders = exports.UpdateVideoConferenceExtInfoResponse = exports.UpdateVideoConferenceExtInfoResponseBody = exports.UpdateVideoConferenceExtInfoHeaders = exports.UpdateScheduleConferenceResponse = exports.UpdateScheduleConferenceResponseBody = exports.UpdateScheduleConferenceRequest = exports.UpdateScheduleConferenceHeaders = exports.UpdateScheduleConfSettingsResponse = exports.UpdateScheduleConfSettingsResponseBody = exports.UpdateScheduleConfSettingsRequest = exports.UpdateScheduleConfSettingsHeaders = exports.StopStreamOutResponse = exports.StopStreamOutResponseBody = exports.StopStreamOutRequest = exports.StopStreamOutHeaders = exports.StopCloudRecordResponse = exports.StopCloudRecordResponseBody = exports.StopCloudRecordRequest = exports.StopCloudRecordHeaders = exports.StartStreamOutResponse = exports.StartStreamOutResponseBody = exports.StartStreamOutRequest = exports.StartStreamOutHeaders = exports.StartCloudRecordResponse = exports.StartCloudRecordResponseBody = exports.StartCloudRecordRequest = exports.StartCloudRecordHeaders = exports.QueryUserOnGoingConferenceResponse = exports.QueryUserOnGoingConferenceResponseBody = exports.QueryUserOnGoingConferenceRequest = exports.QueryUserOnGoingConferenceHeaders = exports.QueryScheduleConferenceInfoResponse = exports.QueryScheduleConferenceInfoResponseBody = exports.QueryScheduleConferenceInfoRequest = exports.QueryScheduleConferenceInfoHeaders = exports.QueryScheduleConferenceResponse = void 0;
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModel = exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = exports.QueryScheduleConferenceInfoResponseBodyConferenceList = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = exports.QueryConferenceMembersResponseBodyMemberModels = exports.QueryConferenceInfoBatchResponseBodyInfos = exports.QueryConferenceInfoBatchResponseBodyInfosUserList = exports.QueryConferenceInfoResponseBodyConfInfo = exports.QueryCloudRecordVideoResponseBodyVideoList = exports.QueryCloudRecordTextResponseBodyParagraphList = exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = void 0;
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class MetricMapValue extends $tea.Model {
    static names() {
        return {
            timestamp: 'timestamp',
            sendBitRate: 'sendBitRate',
            recvBitRate: 'recvBitRate',
            lostRate: 'lostRate',
            roundTripTime: 'roundTripTime',
            audioSendBitRate: 'audioSendBitRate',
            audioRecvBitRate: 'audioRecvBitRate',
            audioRecLevel: 'audioRecLevel',
            audioPlayLevel: 'audioPlayLevel',
            cameraSendBitRate: 'cameraSendBitRate',
            cameraRecvBitRate: 'cameraRecvBitRate',
            cameraSendResolutionActual: 'cameraSendResolutionActual',
            cameraRecvResolutionActual: 'cameraRecvResolutionActual',
            cameraSendFrame: 'cameraSendFrame',
            screenSendBitRate: 'screenSendBitRate',
            cameraRecvFrame: 'cameraRecvFrame',
            screenRecvBitRate: 'screenRecvBitRate',
            screenSendResolutionActual: 'screenSendResolutionActual',
            screenRecvResolutionActual: 'screenRecvResolutionActual',
            screenSendFrame: 'screenSendFrame',
            screenRecvFrame: 'screenRecvFrame',
            audioJitterMax: 'audioJitterMax',
            audioJitterAvg: 'audioJitterAvg',
        };
    }
    static types() {
        return {
            timestamp: 'number',
            sendBitRate: 'string',
            recvBitRate: 'string',
            lostRate: 'string',
            roundTripTime: 'string',
            audioSendBitRate: 'string',
            audioRecvBitRate: 'string',
            audioRecLevel: 'string',
            audioPlayLevel: 'string',
            cameraSendBitRate: 'string',
            cameraRecvBitRate: 'string',
            cameraSendResolutionActual: 'string',
            cameraRecvResolutionActual: 'string',
            cameraSendFrame: 'string',
            screenSendBitRate: 'string',
            cameraRecvFrame: 'string',
            screenRecvBitRate: 'string',
            screenSendResolutionActual: 'string',
            screenRecvResolutionActual: 'string',
            screenSendFrame: 'string',
            screenRecvFrame: 'string',
            audioJitterMax: 'string',
            audioJitterAvg: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MetricMapValue = MetricMapValue;
class MemberModelMapValue extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
            conferenceId: 'conferenceId',
            userNick: 'userNick',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            duration: 'duration',
            attendStatus: 'attendStatus',
            host: 'host',
            coHost: 'coHost',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            deviceType: 'deviceType',
        };
    }
    static types() {
        return {
            unionId: 'string',
            conferenceId: 'string',
            userNick: 'string',
            joinTime: 'number',
            leaveTime: 'number',
            duration: 'number',
            attendStatus: 'number',
            host: 'boolean',
            coHost: 'boolean',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            deviceType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MemberModelMapValue = MemberModelMapValue;
class CancelScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceHeaders = CancelScheduleConferenceHeaders;
class CancelScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceRequest = CancelScheduleConferenceRequest;
class CancelScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceResponseBody = CancelScheduleConferenceResponseBody;
class CancelScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceResponse = CancelScheduleConferenceResponse;
class CloseVideoConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceHeaders = CloseVideoConferenceHeaders;
class CloseVideoConferenceRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceRequest = CloseVideoConferenceRequest;
class CloseVideoConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            cause: 'cause',
            code: 'code',
        };
    }
    static types() {
        return {
            cause: 'string',
            code: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceResponseBody = CloseVideoConferenceResponseBody;
class CloseVideoConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseVideoConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceResponse = CloseVideoConferenceResponse;
class CohostsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsHeaders = CohostsHeaders;
class CohostsRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': CohostsRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsRequest = CohostsRequest;
class CohostsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsResponseBody = CohostsResponseBody;
class CohostsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CohostsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsResponse = CohostsResponse;
class CreateCustomShortLinkHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkHeaders = CreateCustomShortLinkHeaders;
class CreateCustomShortLinkRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            creatorUnionId: 'creatorUnionId',
            extensionAppBizData: 'extensionAppBizData',
            scheduleConferenceId: 'scheduleConferenceId',
            useExtensionApp: 'useExtensionApp',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            creatorUnionId: 'string',
            extensionAppBizData: 'string',
            scheduleConferenceId: 'string',
            useExtensionApp: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkRequest = CreateCustomShortLinkRequest;
class CreateCustomShortLinkResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: CreateCustomShortLinkResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponseBody = CreateCustomShortLinkResponseBody;
class CreateCustomShortLinkResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCustomShortLinkResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponse = CreateCustomShortLinkResponse;
class CreateScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceHeaders = CreateScheduleConferenceHeaders;
class CreateScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequest = CreateScheduleConferenceRequest;
class CreateScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            url: 'url',
        };
    }
    static types() {
        return {
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceResponseBody = CreateScheduleConferenceResponseBody;
class CreateScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceResponse = CreateScheduleConferenceResponse;
class CreateVideoConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceHeaders = CreateVideoConferenceHeaders;
class CreateVideoConferenceRequest extends $tea.Model {
    static names() {
        return {
            confTitle: 'confTitle',
            inviteCaller: 'inviteCaller',
            inviteUserIds: 'inviteUserIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            confTitle: 'string',
            inviteCaller: 'boolean',
            inviteUserIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceRequest = CreateVideoConferenceRequest;
class CreateVideoConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            conferencePassword: 'conferencePassword',
            externalLinkUrl: 'externalLinkUrl',
            hostPassword: 'hostPassword',
            phoneNumbers: 'phoneNumbers',
            roomCode: 'roomCode',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            conferencePassword: 'string',
            externalLinkUrl: 'string',
            hostPassword: 'string',
            phoneNumbers: { 'type': 'array', 'itemType': 'string' },
            roomCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceResponseBody = CreateVideoConferenceResponseBody;
class CreateVideoConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateVideoConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceResponse = CreateVideoConferenceResponse;
class FocusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusHeaders = FocusHeaders;
class FocusRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            action: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusRequest = FocusRequest;
class FocusResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusResponseBody = FocusResponseBody;
class FocusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: FocusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusResponse = FocusResponse;
class GetConfDataByConferenceIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdHeaders = GetConfDataByConferenceIdHeaders;
class GetConfDataByConferenceIdRequest extends $tea.Model {
    static names() {
        return {
            realData: 'realData',
        };
    }
    static types() {
        return {
            realData: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdRequest = GetConfDataByConferenceIdRequest;
class GetConfDataByConferenceIdResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdResponseBody = GetConfDataByConferenceIdResponseBody;
class GetConfDataByConferenceIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDataByConferenceIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdResponse = GetConfDataByConferenceIdResponse;
class GetConfDetailDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataHeaders = GetConfDetailDataHeaders;
class GetConfDetailDataRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            nick: 'nick',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            nick: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataRequest = GetConfDetailDataRequest;
class GetConfDetailDataResponseBody extends $tea.Model {
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetConfDetailDataResponseBodyList },
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponseBody = GetConfDetailDataResponseBody;
class GetConfDetailDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDetailDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponse = GetConfDetailDataResponse;
class GetHistoryConfDataListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListHeaders = GetHistoryConfDataListHeaders;
class GetHistoryConfDataListRequest extends $tea.Model {
    static names() {
        return {
            creatorNike: 'creatorNike',
            endTime: 'endTime',
            freeType: 'freeType',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            realData: 'realData',
            scene: 'scene',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorNike: 'string',
            endTime: 'number',
            freeType: 'string',
            maxResults: 'number',
            nextToken: 'string',
            realData: 'boolean',
            scene: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListRequest = GetHistoryConfDataListRequest;
class GetHistoryConfDataListResponseBody extends $tea.Model {
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetHistoryConfDataListResponseBodyList },
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponseBody = GetHistoryConfDataListResponseBody;
class GetHistoryConfDataListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetHistoryConfDataListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponse = GetHistoryConfDataListResponse;
class GetUserLastMetricHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricHeaders = GetUserLastMetricHeaders;
class GetUserLastMetricRequest extends $tea.Model {
    static names() {
        return {
            unionIdList: 'unionIdList',
        };
    }
    static types() {
        return {
            unionIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricRequest = GetUserLastMetricRequest;
class GetUserLastMetricResponseBody extends $tea.Model {
    static names() {
        return {
            metricMap: 'metricMap',
        };
    }
    static types() {
        return {
            metricMap: { 'type': 'map', 'keyType': 'string', 'valueType': MetricMapValue },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricResponseBody = GetUserLastMetricResponseBody;
class GetUserLastMetricResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserLastMetricResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricResponse = GetUserLastMetricResponse;
class GetUserMetricDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataHeaders = GetUserMetricDataHeaders;
class GetUserMetricDataRequest extends $tea.Model {
    static names() {
        return {
            beginTime: 'beginTime',
            endTime: 'endTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            beginTime: 'number',
            endTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataRequest = GetUserMetricDataRequest;
class GetUserMetricDataResponseBody extends $tea.Model {
    static names() {
        return {
            metricDataList: 'metricDataList',
        };
    }
    static types() {
        return {
            metricDataList: { 'type': 'array', 'itemType': GetUserMetricDataResponseBodyMetricDataList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponseBody = GetUserMetricDataResponseBody;
class GetUserMetricDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserMetricDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponse = GetUserMetricDataResponse;
class InviteUsersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersHeaders = InviteUsersHeaders;
class InviteUsersRequest extends $tea.Model {
    static names() {
        return {
            inviteeList: 'inviteeList',
            phoneInviteeList: 'phoneInviteeList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            inviteeList: { 'type': 'array', 'itemType': InviteUsersRequestInviteeList },
            phoneInviteeList: { 'type': 'array', 'itemType': InviteUsersRequestPhoneInviteeList },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequest = InviteUsersRequest;
class InviteUsersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersResponseBody = InviteUsersResponseBody;
class InviteUsersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InviteUsersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersResponse = InviteUsersResponse;
class KickMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersHeaders = KickMembersHeaders;
class KickMembersRequest extends $tea.Model {
    static names() {
        return {
            forbiddenRejoin: 'forbiddenRejoin',
            userList: 'userList',
        };
    }
    static types() {
        return {
            forbiddenRejoin: 'boolean',
            userList: { 'type': 'array', 'itemType': KickMembersRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersRequest = KickMembersRequest;
class KickMembersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersResponseBody = KickMembersResponseBody;
class KickMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: KickMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersResponse = KickMembersResponse;
class LockConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceHeaders = LockConferenceHeaders;
class LockConferenceRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
        };
    }
    static types() {
        return {
            action: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceRequest = LockConferenceRequest;
class LockConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceResponseBody = LockConferenceResponseBody;
class LockConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: LockConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceResponse = LockConferenceResponse;
class MuteAllHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllHeaders = MuteAllHeaders;
class MuteAllRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            forceMute: 'forceMute',
        };
    }
    static types() {
        return {
            action: 'string',
            forceMute: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllRequest = MuteAllRequest;
class MuteAllResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllResponseBody = MuteAllResponseBody;
class MuteAllResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteAllResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllResponse = MuteAllResponse;
class MuteMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersHeaders = MuteMembersHeaders;
class MuteMembersRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': MuteMembersRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersRequest = MuteMembersRequest;
class MuteMembersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersResponseBody = MuteMembersResponseBody;
class MuteMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersResponse = MuteMembersResponse;
class QueryCloudRecordTextHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextHeaders = QueryCloudRecordTextHeaders;
class QueryCloudRecordTextRequest extends $tea.Model {
    static names() {
        return {
            direction: 'direction',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            direction: 'string',
            maxResults: 'number',
            nextToken: 'number',
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextRequest = QueryCloudRecordTextRequest;
class QueryCloudRecordTextResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            paragraphList: 'paragraphList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            paragraphList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBody = QueryCloudRecordTextResponseBody;
class QueryCloudRecordTextResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordTextResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponse = QueryCloudRecordTextResponse;
class QueryCloudRecordVideoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoHeaders = QueryCloudRecordVideoHeaders;
class QueryCloudRecordVideoRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoRequest = QueryCloudRecordVideoRequest;
class QueryCloudRecordVideoResponseBody extends $tea.Model {
    static names() {
        return {
            videoList: 'videoList',
        };
    }
    static types() {
        return {
            videoList: { 'type': 'array', 'itemType': QueryCloudRecordVideoResponseBodyVideoList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponseBody = QueryCloudRecordVideoResponseBody;
class QueryCloudRecordVideoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponse = QueryCloudRecordVideoResponse;
class QueryCloudRecordVideoPlayInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoHeaders = QueryCloudRecordVideoPlayInfoHeaders;
class QueryCloudRecordVideoPlayInfoRequest extends $tea.Model {
    static names() {
        return {
            mediaId: 'mediaId',
            regionId: 'regionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
            regionId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoRequest = QueryCloudRecordVideoPlayInfoRequest;
class QueryCloudRecordVideoPlayInfoResponseBody extends $tea.Model {
    static names() {
        return {
            duration: 'duration',
            fileSize: 'fileSize',
            mp4FileUrl: 'mp4FileUrl',
            playUrl: 'playUrl',
            status: 'status',
        };
    }
    static types() {
        return {
            duration: 'number',
            fileSize: 'number',
            mp4FileUrl: 'string',
            playUrl: 'string',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoResponseBody = QueryCloudRecordVideoPlayInfoResponseBody;
class QueryCloudRecordVideoPlayInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoPlayInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoResponse = QueryCloudRecordVideoPlayInfoResponse;
class QueryConferenceInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoHeaders = QueryConferenceInfoHeaders;
class QueryConferenceInfoResponseBody extends $tea.Model {
    static names() {
        return {
            confInfo: 'confInfo',
        };
    }
    static types() {
        return {
            confInfo: QueryConferenceInfoResponseBodyConfInfo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponseBody = QueryConferenceInfoResponseBody;
class QueryConferenceInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponse = QueryConferenceInfoResponse;
class QueryConferenceInfoBatchHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchHeaders = QueryConferenceInfoBatchHeaders;
class QueryConferenceInfoBatchRequest extends $tea.Model {
    static names() {
        return {
            conferenceIdList: 'conferenceIdList',
        };
    }
    static types() {
        return {
            conferenceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchRequest = QueryConferenceInfoBatchRequest;
class QueryConferenceInfoBatchResponseBody extends $tea.Model {
    static names() {
        return {
            infos: 'infos',
        };
    }
    static types() {
        return {
            infos: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfos },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBody = QueryConferenceInfoBatchResponseBody;
class QueryConferenceInfoBatchResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoBatchResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponse = QueryConferenceInfoBatchResponse;
class QueryConferenceMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersHeaders = QueryConferenceMembersHeaders;
class QueryConferenceMembersRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersRequest = QueryConferenceMembersRequest;
class QueryConferenceMembersResponseBody extends $tea.Model {
    static names() {
        return {
            memberModels: 'memberModels',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            memberModels: { 'type': 'array', 'itemType': QueryConferenceMembersResponseBodyMemberModels },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponseBody = QueryConferenceMembersResponseBody;
class QueryConferenceMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponse = QueryConferenceMembersResponse;
class QueryScheduleConfSettingsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsHeaders = QueryScheduleConfSettingsHeaders;
class QueryScheduleConfSettingsRequest extends $tea.Model {
    static names() {
        return {
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsRequest = QueryScheduleConfSettingsRequest;
class QueryScheduleConfSettingsResponseBody extends $tea.Model {
    static names() {
        return {
            scheduleConfSettingModel: 'scheduleConfSettingModel',
        };
    }
    static types() {
        return {
            scheduleConfSettingModel: QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBody = QueryScheduleConfSettingsResponseBody;
class QueryScheduleConfSettingsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConfSettingsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponse = QueryScheduleConfSettingsResponse;
class QueryScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceHeaders = QueryScheduleConferenceHeaders;
class QueryScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            requestUnionId: 'requestUnionId',
        };
    }
    static types() {
        return {
            requestUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceRequest = QueryScheduleConferenceRequest;
class QueryScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
            url: 'url',
        };
    }
    static types() {
        return {
            endTime: 'number',
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceResponseBody = QueryScheduleConferenceResponseBody;
class QueryScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceResponse = QueryScheduleConferenceResponse;
class QueryScheduleConferenceInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoHeaders = QueryScheduleConferenceInfoHeaders;
class QueryScheduleConferenceInfoRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoRequest = QueryScheduleConferenceInfoRequest;
class QueryScheduleConferenceInfoResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceList: 'conferenceList',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            conferenceList: { 'type': 'array', 'itemType': QueryScheduleConferenceInfoResponseBodyConferenceList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponseBody = QueryScheduleConferenceInfoResponseBody;
class QueryScheduleConferenceInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponse = QueryScheduleConferenceInfoResponse;
class QueryUserOnGoingConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceHeaders = QueryUserOnGoingConferenceHeaders;
class QueryUserOnGoingConferenceRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceRequest = QueryUserOnGoingConferenceRequest;
class QueryUserOnGoingConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            memberModelMap: 'memberModelMap',
            onGoingConfIdList: 'onGoingConfIdList',
        };
    }
    static types() {
        return {
            memberModelMap: { 'type': 'map', 'keyType': 'string', 'valueType': MemberModelMapValue },
            onGoingConfIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceResponseBody = QueryUserOnGoingConferenceResponseBody;
class QueryUserOnGoingConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUserOnGoingConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceResponse = QueryUserOnGoingConferenceResponse;
class StartCloudRecordHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordHeaders = StartCloudRecordHeaders;
class StartCloudRecordRequest extends $tea.Model {
    static names() {
        return {
            mode: 'mode',
            smallWindowPosition: 'smallWindowPosition',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            smallWindowPosition: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordRequest = StartCloudRecordRequest;
class StartCloudRecordResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordResponseBody = StartCloudRecordResponseBody;
class StartCloudRecordResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartCloudRecordResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordResponse = StartCloudRecordResponse;
class StartStreamOutHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutHeaders = StartStreamOutHeaders;
class StartStreamOutRequest extends $tea.Model {
    static names() {
        return {
            mode: 'mode',
            needHostJoin: 'needHostJoin',
            smallWindowPosition: 'smallWindowPosition',
            streamName: 'streamName',
            streamUrlList: 'streamUrlList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            needHostJoin: 'boolean',
            smallWindowPosition: 'string',
            streamName: 'string',
            streamUrlList: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutRequest = StartStreamOutRequest;
class StartStreamOutResponseBody extends $tea.Model {
    static names() {
        return {
            failStreamMap: 'failStreamMap',
            successStreamMap: 'successStreamMap',
        };
    }
    static types() {
        return {
            failStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            successStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutResponseBody = StartStreamOutResponseBody;
class StartStreamOutResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartStreamOutResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutResponse = StartStreamOutResponse;
class StopCloudRecordHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordHeaders = StopCloudRecordHeaders;
class StopCloudRecordRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordRequest = StopCloudRecordRequest;
class StopCloudRecordResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordResponseBody = StopCloudRecordResponseBody;
class StopCloudRecordResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopCloudRecordResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordResponse = StopCloudRecordResponse;
class StopStreamOutHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutHeaders = StopStreamOutHeaders;
class StopStreamOutRequest extends $tea.Model {
    static names() {
        return {
            stopAllStream: 'stopAllStream',
            streamId: 'streamId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            stopAllStream: 'boolean',
            streamId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutRequest = StopStreamOutRequest;
class StopStreamOutResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutResponseBody = StopStreamOutResponseBody;
class StopStreamOutResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopStreamOutResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutResponse = StopStreamOutResponse;
class UpdateScheduleConfSettingsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsHeaders = UpdateScheduleConfSettingsHeaders;
class UpdateScheduleConfSettingsRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            scheduleConfSettingModel: 'scheduleConfSettingModel',
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            scheduleConfSettingModel: UpdateScheduleConfSettingsRequestScheduleConfSettingModel,
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequest = UpdateScheduleConfSettingsRequest;
class UpdateScheduleConfSettingsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsResponseBody = UpdateScheduleConfSettingsResponseBody;
class UpdateScheduleConfSettingsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateScheduleConfSettingsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsResponse = UpdateScheduleConfSettingsResponse;
class UpdateScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceHeaders = UpdateScheduleConferenceHeaders;
class UpdateScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceRequest = UpdateScheduleConferenceRequest;
class UpdateScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceResponseBody = UpdateScheduleConferenceResponseBody;
class UpdateScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceResponse = UpdateScheduleConferenceResponse;
class UpdateVideoConferenceExtInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoHeaders = UpdateVideoConferenceExtInfoHeaders;
class UpdateVideoConferenceExtInfoResponseBody extends $tea.Model {
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoResponseBody = UpdateVideoConferenceExtInfoResponseBody;
class UpdateVideoConferenceExtInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceExtInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoResponse = UpdateVideoConferenceExtInfoResponse;
class UpdateVideoConferenceSettingHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingHeaders = UpdateVideoConferenceSettingHeaders;
class UpdateVideoConferenceSettingRequest extends $tea.Model {
    static names() {
        return {
            allowUnmuteSelf: 'allowUnmuteSelf',
            autoTransferHost: 'autoTransferHost',
            forbiddenShareScreen: 'forbiddenShareScreen',
            lockConference: 'lockConference',
            muteAll: 'muteAll',
            onlyInternalEmployeesJoin: 'onlyInternalEmployeesJoin',
        };
    }
    static types() {
        return {
            allowUnmuteSelf: 'boolean',
            autoTransferHost: 'boolean',
            forbiddenShareScreen: 'boolean',
            lockConference: 'boolean',
            muteAll: 'boolean',
            onlyInternalEmployeesJoin: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingRequest = UpdateVideoConferenceSettingRequest;
class UpdateVideoConferenceSettingResponseBody extends $tea.Model {
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingResponseBody = UpdateVideoConferenceSettingResponseBody;
class UpdateVideoConferenceSettingResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceSettingResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingResponse = UpdateVideoConferenceSettingResponse;
class CohostsRequestUserList extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsRequestUserList = CohostsRequestUserList;
class CreateCustomShortLinkResponseBodyResult extends $tea.Model {
    static names() {
        return {
            customShortLink: 'customShortLink',
        };
    }
    static types() {
        return {
            customShortLink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponseBodyResult = CreateCustomShortLinkResponseBodyResult;
class GetConfDetailDataResponseBodyList extends $tea.Model {
    static names() {
        return {
            belongOrg: 'belongOrg',
            conferenceId: 'conferenceId',
            deviceType: 'deviceType',
            duration: 'duration',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            networkQuality: 'networkQuality',
            nick: 'nick',
            role: 'role',
            sessionId: 'sessionId',
            status: 'status',
            unionId: 'unionId',
            version: 'version',
        };
    }
    static types() {
        return {
            belongOrg: 'string',
            conferenceId: 'string',
            deviceType: 'string',
            duration: 'number',
            joinTime: 'number',
            leaveTime: 'number',
            networkQuality: 'string',
            nick: 'string',
            role: 'string',
            sessionId: 'string',
            status: 'string',
            unionId: 'string',
            version: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponseBodyList = GetConfDetailDataResponseBodyList;
class GetHistoryConfDataListResponseBodyList extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponseBodyList = GetHistoryConfDataListResponseBodyList;
class GetUserMetricDataResponseBodyMetricDataList extends $tea.Model {
    static names() {
        return {
            audioPlayLevel: 'audioPlayLevel',
            audioRecLevel: 'audioRecLevel',
            audioRecvBitRate: 'audioRecvBitRate',
            audioSendBitRate: 'audioSendBitRate',
            cameraRecvBitRate: 'cameraRecvBitRate',
            cameraRecvFrame: 'cameraRecvFrame',
            cameraRecvResolutionActual: 'cameraRecvResolutionActual',
            cameraSendBitRate: 'cameraSendBitRate',
            cameraSendFrame: 'cameraSendFrame',
            cameraSendResolutionActual: 'cameraSendResolutionActual',
            lostRate: 'lostRate',
            recvBitRate: 'recvBitRate',
            roundTripTime: 'roundTripTime',
            screenRecvBitRate: 'screenRecvBitRate',
            screenRecvFrame: 'screenRecvFrame',
            screenRecvResolutionActual: 'screenRecvResolutionActual',
            screenSendBitRate: 'screenSendBitRate',
            screenSendFrame: 'screenSendFrame',
            screenSendResolutionActual: 'screenSendResolutionActual',
            sendBitRate: 'sendBitRate',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            audioPlayLevel: 'string',
            audioRecLevel: 'string',
            audioRecvBitRate: 'string',
            audioSendBitRate: 'string',
            cameraRecvBitRate: 'string',
            cameraRecvFrame: 'string',
            cameraRecvResolutionActual: 'string',
            cameraSendBitRate: 'string',
            cameraSendFrame: 'string',
            cameraSendResolutionActual: 'string',
            lostRate: 'string',
            recvBitRate: 'string',
            roundTripTime: 'string',
            screenRecvBitRate: 'string',
            screenRecvFrame: 'string',
            screenRecvResolutionActual: 'string',
            screenSendBitRate: 'string',
            screenSendFrame: 'string',
            screenSendResolutionActual: 'string',
            sendBitRate: 'string',
            timestamp: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponseBodyMetricDataList = GetUserMetricDataResponseBodyMetricDataList;
class InviteUsersRequestInviteeList extends $tea.Model {
    static names() {
        return {
            nick: 'nick',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nick: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequestInviteeList = InviteUsersRequestInviteeList;
class InviteUsersRequestPhoneInviteeList extends $tea.Model {
    static names() {
        return {
            nick: 'nick',
            phoneNumber: 'phoneNumber',
        };
    }
    static types() {
        return {
            nick: 'string',
            phoneNumber: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequestPhoneInviteeList = InviteUsersRequestPhoneInviteeList;
class KickMembersRequestUserList extends $tea.Model {
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersRequestUserList = KickMembersRequestUserList;
class MuteMembersRequestUserList extends $tea.Model {
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersRequestUserList = MuteMembersRequestUserList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            word: 'word',
            wordId: 'wordId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
            word: 'string',
            wordId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            sentence: 'sentence',
            startTime: 'startTime',
            unionId: 'unionId',
            wordList: 'wordList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            sentence: 'string',
            startTime: 'number',
            unionId: 'string',
            wordList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = QueryCloudRecordTextResponseBodyParagraphListSentenceList;
class QueryCloudRecordTextResponseBodyParagraphList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            nextTtoken: 'nextTtoken',
            nickName: 'nickName',
            paragraph: 'paragraph',
            recordId: 'recordId',
            sentenceList: 'sentenceList',
            startTime: 'startTime',
            status: 'status',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            nextTtoken: 'number',
            nickName: 'string',
            paragraph: 'string',
            recordId: 'number',
            sentenceList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceList },
            startTime: 'number',
            status: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphList = QueryCloudRecordTextResponseBodyParagraphList;
class QueryCloudRecordVideoResponseBodyVideoList extends $tea.Model {
    static names() {
        return {
            duration: 'duration',
            endTime: 'endTime',
            fileSize: 'fileSize',
            mediaId: 'mediaId',
            recordId: 'recordId',
            recordType: 'recordType',
            regionId: 'regionId',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            duration: 'number',
            endTime: 'number',
            fileSize: 'number',
            mediaId: 'string',
            recordId: 'string',
            recordType: 'number',
            regionId: 'string',
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponseBodyVideoList = QueryCloudRecordVideoResponseBodyVideoList;
class QueryConferenceInfoResponseBodyConfInfo extends $tea.Model {
    static names() {
        return {
            activeNum: 'activeNum',
            attendNum: 'attendNum',
            confDuration: 'confDuration',
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            endTime: 'endTime',
            externalLinkUrl: 'externalLinkUrl',
            invitedNum: 'invitedNum',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            activeNum: 'number',
            attendNum: 'number',
            confDuration: 'number',
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            endTime: 'number',
            externalLinkUrl: 'string',
            invitedNum: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponseBodyConfInfo = QueryConferenceInfoResponseBodyConfInfo;
class QueryConferenceInfoBatchResponseBodyInfosUserList extends $tea.Model {
    static names() {
        return {
            attendStatus: 'attendStatus',
            cameraStatus: 'cameraStatus',
            micStatus: 'micStatus',
            nick: 'nick',
            rejectDescription: 'rejectDescription',
            userId: 'userId',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            cameraStatus: 'number',
            micStatus: 'number',
            nick: 'string',
            rejectDescription: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfosUserList = QueryConferenceInfoBatchResponseBodyInfosUserList;
class QueryConferenceInfoBatchResponseBodyInfos extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            mediaStatus: 'mediaStatus',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
            userList: 'userList',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            mediaStatus: 'number',
            startTime: 'number',
            status: 'number',
            title: 'string',
            userList: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfosUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfos = QueryConferenceInfoBatchResponseBodyInfos;
class QueryConferenceMembersResponseBodyMemberModels extends $tea.Model {
    static names() {
        return {
            attendStatus: 'attendStatus',
            coHost: 'coHost',
            conferenceId: 'conferenceId',
            duration: 'duration',
            host: 'host',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            unionId: 'unionId',
            userNick: 'userNick',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            coHost: 'boolean',
            conferenceId: 'string',
            duration: 'number',
            host: 'boolean',
            joinTime: 'number',
            leaveTime: 'number',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            unionId: 'string',
            userNick: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponseBodyMemberModels = QueryConferenceMembersResponseBodyMemberModels;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            autoOpenMode: 'autoOpenMode',
            clientId: 'clientId',
            coolAppCode: 'coolAppCode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            autoOpenMode: 'string',
            clientId: 'string',
            coolAppCode: 'string',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
    static names() {
        return {
            enableChat: 'enableChat',
            enableWebAnonymousJoin: 'enableWebAnonymousJoin',
            joinBeforeHost: 'joinBeforeHost',
            lockMediaStatusMicMute: 'lockMediaStatusMicMute',
            lockNick: 'lockNick',
            moziConfExtensionAppSettings: 'moziConfExtensionAppSettings',
            waitingRoom: 'waitingRoom',
        };
    }
    static types() {
        return {
            enableChat: 'number',
            enableWebAnonymousJoin: 'boolean',
            joinBeforeHost: 'number',
            lockMediaStatusMicMute: 'number',
            lockNick: 'number',
            moziConfExtensionAppSettings: { 'type': 'array', 'itemType': QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings },
            waitingRoom: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel extends $tea.Model {
    static names() {
        return {
            cohostUnionIds: 'cohostUnionIds',
            confAllowedCorpId: 'confAllowedCorpId',
            hostUnionId: 'hostUnionId',
            lockRoom: 'lockRoom',
            moziConfVirtualExtraSetting: 'moziConfVirtualExtraSetting',
            muteOnJoin: 'muteOnJoin',
            screenShareForbidden: 'screenShareForbidden',
        };
    }
    static types() {
        return {
            cohostUnionIds: { 'type': 'array', 'itemType': 'string' },
            confAllowedCorpId: 'string',
            hostUnionId: 'string',
            lockRoom: 'number',
            moziConfVirtualExtraSetting: QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting,
            muteOnJoin: 'number',
            screenShareForbidden: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel;
class QueryScheduleConferenceInfoResponseBodyConferenceList extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            endTime: 'endTime',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            endTime: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponseBodyConferenceList = QueryScheduleConferenceInfoResponseBodyConferenceList;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            autoOpenMode: 'autoOpenMode',
            coolAppCode: 'coolAppCode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            autoOpenMode: 'number',
            coolAppCode: 'string',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
    static names() {
        return {
            enableChat: 'enableChat',
            enableWebAnonymousJoin: 'enableWebAnonymousJoin',
            joinBeforeHost: 'joinBeforeHost',
            lockMediaStatusMicMute: 'lockMediaStatusMicMute',
            lockNick: 'lockNick',
            moziConfExtensionAppSettings: 'moziConfExtensionAppSettings',
            waitingRoom: 'waitingRoom',
        };
    }
    static types() {
        return {
            enableChat: 'number',
            enableWebAnonymousJoin: 'boolean',
            joinBeforeHost: 'number',
            lockMediaStatusMicMute: 'number',
            lockNick: 'number',
            moziConfExtensionAppSettings: { 'type': 'array', 'itemType': UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings },
            waitingRoom: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModel extends $tea.Model {
    static names() {
        return {
            cohostUnionIds: 'cohostUnionIds',
            confAllowedCorpId: 'confAllowedCorpId',
            hostUnionId: 'hostUnionId',
            lockRoom: 'lockRoom',
            moziConfVirtualExtraSetting: 'moziConfVirtualExtraSetting',
            muteOnJoin: 'muteOnJoin',
            screenShareForbidden: 'screenShareForbidden',
        };
    }
    static types() {
        return {
            cohostUnionIds: { 'type': 'array', 'itemType': 'string' },
            confAllowedCorpId: 'string',
            hostUnionId: 'string',
            lockRoom: 'number',
            moziConfVirtualExtraSetting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting,
            muteOnJoin: 'number',
            screenShareForbidden: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModel = UpdateScheduleConfSettingsRequestScheduleConfSettingModel;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * @summary 
     *
     * @param request CancelScheduleConferenceRequest
     * @param headers CancelScheduleConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CancelScheduleConferenceResponse
     */
    async cancelScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CancelScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CancelScheduleConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CancelScheduleConferenceRequest
     * @return CancelScheduleConferenceResponse
     */
    async cancelScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CancelScheduleConferenceHeaders({});
        return await this.cancelScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CloseVideoConferenceRequest
     * @param headers CloseVideoConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CloseVideoConferenceResponse
     */
    async closeVideoConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloseVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseVideoConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CloseVideoConferenceRequest
     * @return CloseVideoConferenceResponse
     */
    async closeVideoConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseVideoConferenceHeaders({});
        return await this.closeVideoConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CohostsRequest
     * @param headers CohostsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CohostsResponse
     */
    async cohostsWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Cohosts",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/coHosts/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CohostsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CohostsRequest
     * @return CohostsResponse
     */
    async cohosts(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CohostsHeaders({});
        return await this.cohostsWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateCustomShortLinkRequest
     * @param headers CreateCustomShortLinkHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateCustomShortLinkResponse
     */
    async createCustomShortLinkWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.extensionAppBizData)) {
            body["extensionAppBizData"] = request.extensionAppBizData;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        if (!tea_util_1.default.isUnset(request.useExtensionApp)) {
            body["useExtensionApp"] = request.useExtensionApp;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCustomShortLink",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/customShortLinks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateCustomShortLinkResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateCustomShortLinkRequest
     * @return CreateCustomShortLinkResponse
     */
    async createCustomShortLink(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCustomShortLinkHeaders({});
        return await this.createCustomShortLinkWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateScheduleConferenceRequest
     * @param headers CreateScheduleConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateScheduleConferenceResponse
     */
    async createScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateScheduleConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateScheduleConferenceRequest
     * @return CreateScheduleConferenceResponse
     */
    async createScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateScheduleConferenceHeaders({});
        return await this.createScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request CreateVideoConferenceRequest
     * @param headers CreateVideoConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return CreateVideoConferenceResponse
     */
    async createVideoConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.confTitle)) {
            body["confTitle"] = request.confTitle;
        }
        if (!tea_util_1.default.isUnset(request.inviteCaller)) {
            body["inviteCaller"] = request.inviteCaller;
        }
        if (!tea_util_1.default.isUnset(request.inviteUserIds)) {
            body["inviteUserIds"] = request.inviteUserIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateVideoConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request CreateVideoConferenceRequest
     * @return CreateVideoConferenceResponse
     */
    async createVideoConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateVideoConferenceHeaders({});
        return await this.createVideoConferenceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request FocusRequest
     * @param headers FocusHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return FocusResponse
     */
    async focusWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Focus",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/focus`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new FocusResponse({}));
    }
    /**
     * @summary 
     *
     * @param request FocusRequest
     * @return FocusResponse
     */
    async focus(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FocusHeaders({});
        return await this.focusWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary conferenceId
     *
     * @param request GetConfDataByConferenceIdRequest
     * @param headers GetConfDataByConferenceIdHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetConfDataByConferenceIdResponse
     */
    async getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDataByConferenceId",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDataByConferenceIdResponse({}));
    }
    /**
     * @summary conferenceId
     *
     * @param request GetConfDataByConferenceIdRequest
     * @return GetConfDataByConferenceIdResponse
     */
    async getConfDataByConferenceId(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDataByConferenceIdHeaders({});
        return await this.getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary conferenceId
     *
     * @param request GetConfDetailDataRequest
     * @param headers GetConfDetailDataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetConfDetailDataResponse
     */
    async getConfDetailDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.nick)) {
            query["nick"] = request.nick;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDetailData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/details`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDetailDataResponse({}));
    }
    /**
     * @summary conferenceId
     *
     * @param request GetConfDetailDataRequest
     * @return GetConfDetailDataResponse
     */
    async getConfDetailData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDetailDataHeaders({});
        return await this.getConfDetailDataWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request GetHistoryConfDataListRequest
     * @param headers GetHistoryConfDataListHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetHistoryConfDataListResponse
     */
    async getHistoryConfDataListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.creatorNike)) {
            query["creatorNike"] = request.creatorNike;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.freeType)) {
            query["freeType"] = request.freeType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        if (!tea_util_1.default.isUnset(request.scene)) {
            query["scene"] = request.scene;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            query["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetHistoryConfDataList",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/histories/dataLists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetHistoryConfDataListResponse({}));
    }
    /**
     * @summary 
     *
     * @param request GetHistoryConfDataListRequest
     * @return GetHistoryConfDataListResponse
     */
    async getHistoryConfDataList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetHistoryConfDataListHeaders({});
        return await this.getHistoryConfDataListWithOptions(request, headers, runtime);
    }
    /**
     * @summary conferenceIdunionId
     *
     * @param request GetUserLastMetricRequest
     * @param headers GetUserLastMetricHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetUserLastMetricResponse
     */
    async getUserLastMetricWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionIdList)) {
            body["unionIdList"] = request.unionIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetUserLastMetric",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/lastMetricDatas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserLastMetricResponse({}));
    }
    /**
     * @summary conferenceIdunionId
     *
     * @param request GetUserLastMetricRequest
     * @return GetUserLastMetricResponse
     */
    async getUserLastMetric(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserLastMetricHeaders({});
        return await this.getUserLastMetricWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary conferenceIdunionId
     *
     * @param request GetUserMetricDataRequest
     * @param headers GetUserMetricDataHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return GetUserMetricDataResponse
     */
    async getUserMetricDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.beginTime)) {
            query["beginTime"] = request.beginTime;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserMetricData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/metricDatas`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserMetricDataResponse({}));
    }
    /**
     * @summary conferenceIdunionId
     *
     * @param request GetUserMetricDataRequest
     * @return GetUserMetricDataResponse
     */
    async getUserMetricData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserMetricDataHeaders({});
        return await this.getUserMetricDataWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request InviteUsersRequest
     * @param headers InviteUsersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return InviteUsersResponse
     */
    async inviteUsersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.inviteeList)) {
            body["inviteeList"] = request.inviteeList;
        }
        if (!tea_util_1.default.isUnset(request.phoneInviteeList)) {
            body["phoneInviteeList"] = request.phoneInviteeList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InviteUsers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/users/invite`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InviteUsersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request InviteUsersRequest
     * @return InviteUsersResponse
     */
    async inviteUsers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InviteUsersHeaders({});
        return await this.inviteUsersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request KickMembersRequest
     * @param headers KickMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return KickMembersResponse
     */
    async kickMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.forbiddenRejoin)) {
            body["forbiddenRejoin"] = request.forbiddenRejoin;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "KickMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/kick`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new KickMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request KickMembersRequest
     * @return KickMembersResponse
     */
    async kickMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new KickMembersHeaders({});
        return await this.kickMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request LockConferenceRequest
     * @param headers LockConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return LockConferenceResponse
     */
    async lockConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "LockConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/lock`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new LockConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request LockConferenceRequest
     * @return LockConferenceResponse
     */
    async lockConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new LockConferenceHeaders({});
        return await this.lockConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MuteAllRequest
     * @param headers MuteAllHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MuteAllResponse
     */
    async muteAllWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.forceMute)) {
            body["forceMute"] = request.forceMute;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteAll",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/allMembers/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteAllResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MuteAllRequest
     * @return MuteAllResponse
     */
    async muteAll(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteAllHeaders({});
        return await this.muteAllWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request MuteMembersRequest
     * @param headers MuteMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return MuteMembersResponse
     */
    async muteMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request MuteMembersRequest
     * @return MuteMembersResponse
     */
    async muteMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteMembersHeaders({});
        return await this.muteMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordTextRequest
     * @param headers QueryCloudRecordTextHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCloudRecordTextResponse
     */
    async queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordText",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getTexts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordTextResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordTextRequest
     * @return QueryCloudRecordTextResponse
     */
    async queryCloudRecordText(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordTextHeaders({});
        return await this.queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordVideoRequest
     * @param headers QueryCloudRecordVideoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCloudRecordVideoResponse
     */
    async queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getVideos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordVideoRequest
     * @return QueryCloudRecordVideoResponse
     */
    async queryCloudRecordVideo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoHeaders({});
        return await this.queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordVideoPlayInfoRequest
     * @param headers QueryCloudRecordVideoPlayInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryCloudRecordVideoPlayInfoResponse
     */
    async queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            query["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["regionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideoPlayInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/videos/getPlayInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoPlayInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryCloudRecordVideoPlayInfoRequest
     * @return QueryCloudRecordVideoPlayInfoResponse
     */
    async queryCloudRecordVideoPlayInfo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoPlayInfoHeaders({});
        return await this.queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers QueryConferenceInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryConferenceInfoResponse
     */
    async queryConferenceInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @return QueryConferenceInfoResponse
     */
    async queryConferenceInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoHeaders({});
        return await this.queryConferenceInfoWithOptions(conferenceId, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryConferenceInfoBatchRequest
     * @param headers QueryConferenceInfoBatchHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryConferenceInfoBatchResponse
     */
    async queryConferenceInfoBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conferenceIdList)) {
            body["conferenceIdList"] = request.conferenceIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfoBatch",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoBatchResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryConferenceInfoBatchRequest
     * @return QueryConferenceInfoBatchResponse
     */
    async queryConferenceInfoBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoBatchHeaders({});
        return await this.queryConferenceInfoBatchWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryConferenceMembersRequest
     * @param headers QueryConferenceMembersHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryConferenceMembersResponse
     */
    async queryConferenceMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceMembersResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryConferenceMembersRequest
     * @return QueryConferenceMembersResponse
     */
    async queryConferenceMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceMembersHeaders({});
        return await this.queryConferenceMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConfSettingsRequest
     * @param headers QueryScheduleConfSettingsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryScheduleConfSettingsResponse
     */
    async queryScheduleConfSettingsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            query["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConfSettings",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/settings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConfSettingsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConfSettingsRequest
     * @return QueryScheduleConfSettingsResponse
     */
    async queryScheduleConfSettings(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConfSettingsHeaders({});
        return await this.queryScheduleConfSettingsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConferenceRequest
     * @param headers QueryScheduleConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryScheduleConferenceResponse
     */
    async queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.requestUnionId)) {
            query["requestUnionId"] = request.requestUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/${scheduleConferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConferenceRequest
     * @return QueryScheduleConferenceResponse
     */
    async queryScheduleConference(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceHeaders({});
        return await this.queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConferenceInfoRequest
     * @param headers QueryScheduleConferenceInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryScheduleConferenceInfoResponse
     */
    async queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/scheduleConferences/${scheduleConferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryScheduleConferenceInfoRequest
     * @return QueryScheduleConferenceInfoResponse
     */
    async queryScheduleConferenceInfo(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceInfoHeaders({});
        return await this.queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request QueryUserOnGoingConferenceRequest
     * @param headers QueryUserOnGoingConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return QueryUserOnGoingConferenceResponse
     */
    async queryUserOnGoingConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUserOnGoingConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/users/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUserOnGoingConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request QueryUserOnGoingConferenceRequest
     * @return QueryUserOnGoingConferenceResponse
     */
    async queryUserOnGoingConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserOnGoingConferenceHeaders({});
        return await this.queryUserOnGoingConferenceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request StartCloudRecordRequest
     * @param headers StartCloudRecordHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return StartCloudRecordResponse
     */
    async startCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartCloudRecordResponse({}));
    }
    /**
     * @summary 
     *
     * @param request StartCloudRecordRequest
     * @return StartCloudRecordResponse
     */
    async startCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartCloudRecordHeaders({});
        return await this.startCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request StartStreamOutRequest
     * @param headers StartStreamOutHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return StartStreamOutResponse
     */
    async startStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.needHostJoin)) {
            body["needHostJoin"] = request.needHostJoin;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.streamName)) {
            body["streamName"] = request.streamName;
        }
        if (!tea_util_1.default.isUnset(request.streamUrlList)) {
            body["streamUrlList"] = request.streamUrlList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartStreamOutResponse({}));
    }
    /**
     * @summary 
     *
     * @param request StartStreamOutRequest
     * @return StartStreamOutResponse
     */
    async startStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartStreamOutHeaders({});
        return await this.startStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request StopCloudRecordRequest
     * @param headers StopCloudRecordHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return StopCloudRecordResponse
     */
    async stopCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopCloudRecordResponse({}));
    }
    /**
     * @summary 
     *
     * @param request StopCloudRecordRequest
     * @return StopCloudRecordResponse
     */
    async stopCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopCloudRecordHeaders({});
        return await this.stopCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request StopStreamOutRequest
     * @param headers StopStreamOutHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return StopStreamOutResponse
     */
    async stopStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.stopAllStream)) {
            body["stopAllStream"] = request.stopAllStream;
        }
        if (!tea_util_1.default.isUnset(request.streamId)) {
            body["streamId"] = request.streamId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopStreamOutResponse({}));
    }
    /**
     * @summary 
     *
     * @param request StopStreamOutRequest
     * @return StopStreamOutResponse
     */
    async stopStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopStreamOutHeaders({});
        return await this.stopStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateScheduleConfSettingsRequest
     * @param headers UpdateScheduleConfSettingsHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateScheduleConfSettingsResponse
     */
    async updateScheduleConfSettingsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConfSettingModel)) {
            body["scheduleConfSettingModel"] = request.scheduleConfSettingModel;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateScheduleConfSettings",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/settings`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateScheduleConfSettingsResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateScheduleConfSettingsRequest
     * @return UpdateScheduleConfSettingsResponse
     */
    async updateScheduleConfSettings(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateScheduleConfSettingsHeaders({});
        return await this.updateScheduleConfSettingsWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateScheduleConferenceRequest
     * @param headers UpdateScheduleConferenceHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateScheduleConferenceResponse
     */
    async updateScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateScheduleConferenceResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateScheduleConferenceRequest
     * @return UpdateScheduleConferenceResponse
     */
    async updateScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateScheduleConferenceHeaders({});
        return await this.updateScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param headers UpdateVideoConferenceExtInfoHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateVideoConferenceExtInfoResponse
     */
    async updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceExtInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/extInfo`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceExtInfoResponse({}));
    }
    /**
     * @summary 
     *
     * @return UpdateVideoConferenceExtInfoResponse
     */
    async updateVideoConferenceExtInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceExtInfoHeaders({});
        return await this.updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime);
    }
    /**
     * @summary 
     *
     * @param request UpdateVideoConferenceSettingRequest
     * @param headers UpdateVideoConferenceSettingHeaders
     * @param runtime runtime options for this request RuntimeOptions
     * @return UpdateVideoConferenceSettingResponse
     */
    async updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.allowUnmuteSelf)) {
            body["allowUnmuteSelf"] = request.allowUnmuteSelf;
        }
        if (!tea_util_1.default.isUnset(request.autoTransferHost)) {
            body["autoTransferHost"] = request.autoTransferHost;
        }
        if (!tea_util_1.default.isUnset(request.forbiddenShareScreen)) {
            body["forbiddenShareScreen"] = request.forbiddenShareScreen;
        }
        if (!tea_util_1.default.isUnset(request.lockConference)) {
            body["lockConference"] = request.lockConference;
        }
        if (!tea_util_1.default.isUnset(request.muteAll)) {
            body["muteAll"] = request.muteAll;
        }
        if (!tea_util_1.default.isUnset(request.onlyInternalEmployeesJoin)) {
            body["onlyInternalEmployeesJoin"] = request.onlyInternalEmployeesJoin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceSetting",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceSettingResponse({}));
    }
    /**
     * @summary 
     *
     * @param request UpdateVideoConferenceSettingRequest
     * @return UpdateVideoConferenceSettingResponse
     */
    async updateVideoConferenceSetting(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceSettingHeaders({});
        return await this.updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map